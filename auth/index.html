<!DOCTYPE html>
<html class="no-js" lang="">
  <head>
    <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
    <meta charset="utf-8" />
    <title>Turnkey Recovery and Auth</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        text-align: center;
        font-family: "Lucida Sans", "Lucida Sans Regular", "Lucida Grande",
          "Lucida Sans Unicode", Geneva, Verdana, sans-serif;
        max-width: 1024px;
        margin: auto;
      }
      label {
        display: inline-block;
        width: 8em;
      }
      input[type="text"] {
        width: 40em;
        margin: 0.5em;
        font-family: "Courier New", Courier, monospace;
        font-size: 1em;
        height: 1.8em;
        color: rgb(18, 87, 18);
        border: 1px rgb(217, 240, 221) solid;
        border-radius: 4px;
      }
      input:disabled {
        background-color: rgb(239, 243, 240);
      }
      #decrypted {
        width: 60em;
        background-color: rgb(58, 152, 81);
        color: white;
        height: 2em;
        font-weight: bold;
        text-align: center;
      }
      #reset {
        color: white;
        width: 7em;
        font-size: 1em;
        padding: 0.38em;
        border-radius: 4px;
        background-color: rgb(187, 100, 100);
        border: 1px rgb(112, 42, 42) solid;
        cursor: pointer;
      }
      #init,
      #inject,
      #stamp {
        color: white;
        width: 7em;
        font-size: 1em;
        padding: 0.38em;
        border-radius: 4px;
        background-color: rgb(50, 44, 44);
        border: 1px rgb(33, 33, 33) solid;
        cursor: pointer;
      }
      #message-log {
        border: 1px #2a2828 solid;
        padding: 0 0.7em;
        border-radius: 4px;
        margin-top: 2em;
        max-width: 800px;
        margin: auto;
      }
      #message-log p {
        font-size: 0.9em;
        text-align: left;
        word-break: break-all;
      }
      .hidden {
        display: none;
      }
    </style>
    <script type="module">
      import GrafanaFaroWebSdk from "./grafana-faro-web-sdk.js";
      import GrafanaFaroWebTracing from "./grafana-faro-web-tracing.js";

      // set environment based on the host
      let environment = "development";
      const host = window.location.host;
      if (host === "auth.turnkey.com") {
        environment = "production";
      } else if (host === "auth.preprod.turnkey.engineering") {
        environment = "preprod";
      }

      const faro = GrafanaFaroWebSdk.initializeFaro({
        url: "https://faro-collector-prod-us-central-0.grafana.net/collect/208ef3024d71da6062bd867dbd1f8b34",
        app: {
          name: "email-auth",
          version: "1.0.0",
          environment: environment,
        },
        trackGeolocation: false,
      });

      const grafanaTracing = GrafanaFaroWebTracing({}, GrafanaFaroWebSdk);

      faro.instrumentations.add(new grafanaTracing.TracingInstrumentation());
    </script>
  </head>

  <body>
    <h2>Init Recovery or Auth</h2>
    <p>
      <em
        >This public key will be sent along with your email inside of a new
        <code>INIT_USER_EMAIL_RECOVERY</code> or
        <code>EMAIL_AUTH</code> activity</em
      >
    </p>
    <form>
      <label>Embedded key</label>
      <input type="text" name="embedded-key" id="embedded-key" disabled />
      <button id="reset">Reset Key</button>
      <button id="init">Init Key</button>
    </form>
    <br />
    <br />
    <br />
    <h2>Inject Credential Bundle</h2>
    <p>
      <em
        >The credential bundle will come from your email. This bundle can then
        be used for email recovery or auth. We can simulate this locally: see
        instructions
        <a
          href="https://github.com/tkhq/frames#running-local-auth"
          target="_blank"
          >here</a
        >. A credential bundle is composed of a public key and an encrypted
        payload. The payload is encrypted to this document's embedded key
        (stored in local storage and displayed above). The scheme relies on
        <a target="_blank" href="https://datatracker.ietf.org/doc/rfc9180/"
          >HPKE (RFC 9180)</a
        ></em
      >.
    </p>
    <form>
      <label>Bundle</label>
      <input type="text" name="credential-bundle" id="credential-bundle" />
      <button id="inject">Inject Bundle</button>
    </form>
    <br />
    <br />
    <br />
    <h2>Stamp</h2>
    <p>
      <em
        >Once you've injected the credential bundle, the credential is ready to
        sign. A new <code>RECOVER</code> activity for example. This iframe
        doesn't know anything about Turnkey activity however, it's a simple
        stamper!</em
      >
    </p>
    <form>
      <label>Payload</label>
      <input type="text" name="payload" id="payload" />
      <button id="stamp">Stamp</button>
    </form>
    <br />
    <br />
    <br />
    <h2>Message log</h2>
    <p>
      <em
        >Below we display a log of the messages sent / received. The forms above
        send messages, and the code communicates results by sending events via
        the <code>postMessage</code> API.</em
      >
    </p>
    <div id="message-log"></div>

    <!--
    Script defining important helpers.
    These helpers are unit-testable, so most of the logic should be written here.
  -->
    <script>
      window.isInitEmbeddedKeyRunByDomContentLoaded = false;
      window.TKHQ = (function () {
        /** constant for LocalStorage */
        var TURNKEY_EMBEDDED_KEY = "TURNKEY_EMBEDDED_KEY";
        var TURNKEY_EMBEDDED_KEY_TTL_IN_MILLIS = 1000 * 60 * 60 * 48; // 48 hours in milliseconds

        var parentFrameMessageChannelPort = null;

        /**
         * Creates a new public/private key pair and persists it in localStorage
         * @return boolean indicating whether an embedded key has been set
         */
        var initEmbeddedKey = async function (
          ttl = TURNKEY_EMBEDDED_KEY_TTL_IN_MILLIS
        ) {
          var retrievedKey = await getEmbeddedKey();
          if (retrievedKey === null) {
            var targetKey = await generateTargetKey();
            setEmbeddedKey(targetKey, ttl);
            return true;
          } else {
            return false;
            // Nothing to do, key is correctly initialized!
          }
        };

        var setParentFrameMessageChannelPort = function (port) {
          parentFrameMessageChannelPort = port;
        };

        /*
         * Generate a key to encrypt to and export it as a JSON Web Key.
         */
        var generateTargetKey = async function () {
          var p256key = await crypto.subtle.generateKey(
            {
              name: "ECDH",
              namedCurve: "P-256",
            },
            true,
            ["deriveBits"]
          );

          return await crypto.subtle.exportKey("jwk", p256key.privateKey);
        };

        /**
         * Gets the current embedded private key JWK.
         * @return `null` if not found.
         */
        var getEmbeddedKey = function () {
          var jwtKey = getItemWithExpiry(TURNKEY_EMBEDDED_KEY);
          if (!jwtKey) {
            return null;
          } else {
            return JSON.parse(jwtKey);
          }
        };

        /**
         * Sets the current embedded private key JWK in local storage.
         * @param {string} targetKey the private key JWK
         * @param {number} ttl (optional) if unset, default to TURNKEY_EMBEDDED_KEY_TTL_IN_MILLIS
         */
        var setEmbeddedKey = function (
          targetKey,
          ttl = TURNKEY_EMBEDDED_KEY_TTL_IN_MILLIS
        ) {
          return setItemWithExpiry(
            TURNKEY_EMBEDDED_KEY,
            JSON.stringify(targetKey),
            ttl
          );
        };

        /**
         * Removes the embedded key from local storage.
         */
        var resetEmbeddedKey = function () {
          window.localStorage.removeItem(TURNKEY_EMBEDDED_KEY);
        };

        /**
         * Set an item in localStorage with an expiration time
         * @param {string} key
         * @param {string} value
         * @param {number} ttl expiration time in milliseconds
         */
        var setItemWithExpiry = function (key, value, ttl) {
          const now = new Date();
          const item = {
            value: value,
            expiry: now.getTime() + ttl,
          };
          window.localStorage.setItem(key, JSON.stringify(item));
        };

        /**
         * Get an item from localStorage. If it has expired, remove
         * the item from localStorage and return null.
         * @param {string} key
         */
        const getItemWithExpiry = (key) => {
          const itemStr = window.localStorage.getItem(key);

          if (!itemStr) {
            return null;
          }

          const item = JSON.parse(itemStr);

          if (!item.hasOwnProperty("expiry") || !item.hasOwnProperty("value")) {
            window.localStorage.removeItem(key);
            return null;
          }

          const now = new Date();
          if (now.getTime() > item.expiry) {
            window.localStorage.removeItem(key);
            return null;
          }
          return item.value;
        };

        /**
         * Takes a hex string (e.g. "e4567abc") and returns an array buffer (Uint8Array)
         * @param {string} hexString
         * @param {number} length: optional expected length of the resulting buffer
         * @returns {Uint8Array}
         */
        var uint8arrayFromHexString = function (hexString, length) {
          var hexRegex = /^[0-9A-Fa-f]+$/;
          if (
            !hexString ||
            hexString.length % 2 != 0 ||
            !hexRegex.test(hexString)
          ) {
            const errorMessage = `cannot create uint8array from invalid hex string: ${hexString}`;
            reportError(errorMessage);
            throw new Error(errorMessage);
          }
          var buffer = new Uint8Array(
            hexString.match(/../g).map((h) => parseInt(h, 16))
          );
          if (!length) {
            return buffer;
          }
          var paddedBuffer = new Uint8Array(length);
          paddedBuffer.set(buffer, length - buffer.length);
          return paddedBuffer;
        };

        /**
         * Takes a Uint8Array and returns a hex string
         * @param {Uint8Array} buffer
         * @return {string}
         */
        var uint8arrayToHexString = function (buffer) {
          return [...buffer]
            .map((x) => x.toString(16).padStart(2, "0"))
            .join("");
        };

        /**
         * Additional Associated Data (AAD) in the format dictated by the enclave_encrypt crate.
         */
        var additionalAssociatedData = function (senderPubBuf, receiverPubBuf) {
          var s = Array.from(new Uint8Array(senderPubBuf));
          var r = Array.from(new Uint8Array(receiverPubBuf));
          return new Uint8Array([...s, ...r]);
        };

        /**
         * Encodes a buffer into base64url
         * @param {Uint8Array} byteArray
         */
        function base64urlEncode(byteArray) {
          return btoa(
            Array.from(byteArray)
              .map((val) => {
                return String.fromCharCode(val);
              })
              .join("")
          )
            .replace(/\+/g, "-")
            .replace(/\//g, "_")
            .replace(/\=/g, "");
        }

        /**
         * Decodes a base64-encoded string into a buffer
         * @param {string} s
         * @return {Uint8Array}
         */
        function base64urlDecode(s) {
          var binaryString = atob(s.replace(/\-/g, "+").replace(/\_/g, "/"));
          var bytes = new Uint8Array(binaryString.length);
          for (var i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return bytes;
        }

        /**
         * Decodes a base58check-encoded string into a buffer
         * This function throws an error when the string is too small, doesn't have the proper checksum, or contains invalid characters.
         * Inspired by https://gist.github.com/diafygi/90a3e80ca1c2793220e5/
         * @param {string} s
         * @return {Uint8Array}
         */
        async function base58checkDecode(s) {
          if (s.length < 5) {
            const errorMessage = `cannot base58-decode a string of length < 5 (found length ${s.length})`;
            reportError(errorMessage);
            throw new Error(errorMessage);
          }

          // See https://en.bitcoin.it/wiki/Base58Check_encoding
          var alphabet =
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
          var decoded = BigInt(0);
          var decodedBytes = [];
          var leadingZeros = [];
          for (var i = 0; i < s.length; i++) {
            if (alphabet.indexOf(s[i]) === -1) {
              const errorMessage = `cannot base58-decode: ${s[i]} isn't a valid character`;
              reportError(errorMessage);
              throw new Error(errorMessage);
            }
            var carry = alphabet.indexOf(s[i]);

            // If the current base58 digit is 0, append a 0 byte.
            // "i == leadingZeros.length" can only be true if we have not seen non-zero bytes so far.
            // If we had seen a non-zero byte, carry wouldn't be 0, and i would be strictly more than `leadingZeros.length`
            if (carry == 0 && i === leadingZeros.length) {
              leadingZeros.push(0);
            }

            var j = 0;
            while (j < decodedBytes.length || carry > 0) {
              var currentByte = decodedBytes[j];

              // shift the current byte 58 units and add the carry amount
              // (or just add the carry amount if this is a new byte -- undefined case)
              if (currentByte === undefined) {
                currentByte = carry;
              } else {
                currentByte = currentByte * 58 + carry;
              }

              // find the new carry amount (1-byte shift of current byte value)
              carry = currentByte >> 8;
              // reset the current byte to the remainder (the carry amount will pass on the overflow)
              decodedBytes[j] = currentByte % 256;
              j++;
            }
          }

          var result = leadingZeros.concat(decodedBytes.reverse());

          var foundChecksum = result.slice(result.length - 4);

          var msg = result.slice(0, result.length - 4);
          var checksum1 = await crypto.subtle.digest(
            "SHA-256",
            new Uint8Array(msg)
          );
          var checksum2 = await crypto.subtle.digest(
            "SHA-256",
            new Uint8Array(checksum1)
          );
          var computedChecksum = Array.from(new Uint8Array(checksum2)).slice(
            0,
            4
          );

          if (computedChecksum.toString() != foundChecksum.toString()) {
            const errorMessage = `unable to decode credential bundle. checksums do not match: computed ${computedChecksum} but found ${foundChecksum}`;
            reportError(errorMessage);
            throw new Error(errorMessage);
          }

          return new Uint8Array(msg);
        }

        /**
         * `SubtleCrypto.sign(...)` outputs signature in IEEE P1363 format:
         * - https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#ecdsa
         *
         * Turnkey expects the signature encoding to be DER-encoded ASN.1:
         * - https://github.com/tkhq/tkcli/blob/7f0159af5a73387ff050647180d1db4d3a3aa033/src/internal/apikey/apikey.go#L149
         *
         * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L114
         *
         * Transform an ECDSA signature in IEEE 1363 encoding to DER encoding.
         *
         * @param {Uint8Array} ieee the ECDSA signature in IEEE encoding
         * @return ECDSA signature in DER encoding
         */
        function convertEcdsaIeee1363ToDer(ieee) {
          if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {
            const errorMessage = `Invalid IEEE P1363 signature encoding. Length: ${ieee.length}`;
            reportError(errorMessage);
            throw new Error(errorMessage);
          }
          const r = toUnsignedBigNum(ieee.subarray(0, ieee.length / 2));
          const s = toUnsignedBigNum(
            ieee.subarray(ieee.length / 2, ieee.length)
          );
          let offset = 0;
          const length = 1 + 1 + r.length + 1 + 1 + s.length;
          let der;
          if (length >= 128) {
            der = new Uint8Array(length + 3);
            der[offset++] = 48;
            der[offset++] = 128 + 1;
            der[offset++] = length;
          } else {
            der = new Uint8Array(length + 2);
            der[offset++] = 48;
            der[offset++] = length;
          }
          der[offset++] = 2;
          der[offset++] = r.length;
          der.set(r, offset);
          offset += r.length;
          der[offset++] = 2;
          der[offset++] = s.length;
          der.set(s, offset);
          return der;
        }

        /**
         * (private function, only called by `convertEcdsaIeee1363ToDer`)
         * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L311
         *
         * Transform a big integer in big endian to minimal unsigned form which has
         * no extra zero at the beginning except when the highest bit is set.
         *
         * @param {Uint8Array} bytes
         *
         */
        function toUnsignedBigNum(bytes) {
          // Remove zero prefixes.
          let start = 0;
          while (start < bytes.length && bytes[start] == 0) {
            start++;
          }
          if (start == bytes.length) {
            start = bytes.length - 1;
          }
          let extraZero = 0;

          // If the 1st bit is not zero, add 1 zero byte.
          if ((bytes[start] & 128) == 128) {
            // Add extra zero.
            extraZero = 1;
          }
          const res = new Uint8Array(bytes.length - start + extraZero);
          res.set(bytes.subarray(start), extraZero);
          return res;
        }

        /**
         * Code modified from https://github.com/github/webauthn-json/blob/e932b3585fa70b0bd5b5a4012ba7dbad7b0a0d0f/src/webauthn-json/base64url.ts#L23
         * @param {string} input
         */
        var stringToBase64urlString = function (input) {
          const base64String = btoa(input);
          return base64String
            .replace(/\+/g, "-")
            .replace(/\//g, "_")
            .replace(/=/g, "");
        };

        /**
         * Function to send a message.
         *
         * If this page is embedded as an iframe we'll send a postMessage
         * in one of two ways depending on the version of @turnkey/iframe-stamper:
         *   1. newer versions (>=v2.1.0) pass a MessageChannel MessagePort from the parent frame for postMessages.
         *   2. older versions (<v2.1.0) still use the contentWindow so we will postMessage to the window.parent for backwards compatibility.
         *
         * Otherwise we'll display it in the DOM.
         * @param type message type. Can be "PUBLIC_KEY_CREATED", "BUNDLE_INJECTED" or "STAMP"
         * @param value message value
         * @param requestId serves as an idempotency key to match incoming requests. Backwards compatible: if not provided, it isn't passed in.
         */
        var sendMessageUp = function (type, value, requestId) {
          if (type === "ERROR") {
            window.faro?.api?.pushError([value], {
              context: {
                requestId: requestId,
              },
              level: "error",
            });
          }

          const message = {
            type: type,
            value: value,
          };

          // Only include requestId if it was provided
          if (requestId) {
            message.requestId = requestId;
          }

          if (parentFrameMessageChannelPort) {
            parentFrameMessageChannelPort.postMessage(message);
          } else if (window.parent !== window) {
            window.parent.postMessage(
              {
                type: type,
                value: value,
              },
              "*"
            );
          }
          logMessage(`⬆️ Sent message ${type}: ${value}`);
        };

        /**
         * Function to log a message and persist it in the page's DOM.
         */
        var logMessage = function (content) {
          var messageLog = document.getElementById("message-log");
          var message = document.createElement("p");
          message.innerText = content;
          messageLog.appendChild(message);
        };

        /**
         * Function to report errors to Grafana Faro.
         */
        var reportError = function (errorMessage) {
          window.faro?.api?.pushError([errorMessage], {
            level: "error",
          });
        };

        /**
         * Convert a JSON Web Key private key to a public key and export the public
         * key in raw format.
         * @return {Uint8array}
         */
        var p256JWKPrivateToPublic = async function (jwkPrivate) {
          // make a copy so we don't modify the underlying object
          const jwkPrivateCopy = { ...jwkPrivate };
          // change jwk so it will be imported as a public key
          delete jwkPrivateCopy.d;
          jwkPrivateCopy.key_ops = ["verify"];

          var publicKey = await window.crypto.subtle.importKey(
            "jwk",
            jwkPrivateCopy,
            { name: "ECDSA", namedCurve: "P-256" },
            true,
            ["verify"]
          );
          var buffer = await crypto.subtle.exportKey("raw", publicKey);
          return new Uint8Array(buffer);
        };

        /**
         * Returns a CryptoKey from a P256 private key bytes
         * This is a bit awkward because webcrypto can't import raw private key bytes.
         * We use some custom crypto code to derive the public key from the private key bytes.
         * Note that this is NOT security sensitive because browsers validate x/y coordinate
         * when performing `crypto.subtle.importKey` operations.
         * @param {Uint8Array} privateKeyBytes
         */
        var importCredential = async function (privateKeyBytes) {
          var privateKeyHexString = uint8arrayToHexString(privateKeyBytes);
          var privateKey = BigInt("0x" + privateKeyHexString);
          var publicKeyPoint = P256Generator.multiply(privateKey);

          return await window.crypto.subtle.importKey(
            "jwk",
            {
              kty: "EC",
              crv: "P-256",
              d: bigIntToBase64Url(privateKey, 32),
              x: bigIntToBase64Url(publicKeyPoint.x.num, 32),
              y: bigIntToBase64Url(publicKeyPoint.y.num, 32),
              ext: true,
            },
            {
              name: "ECDSA",
              namedCurve: "P-256",
            },
            true,
            ["sign"]
          );
        };

        /**
         * Converts a `BigInt` into a base64url encoded string
         * @param {BigInt} num
         * @param {number} length: optional number of bytes contained in the resulting string
         * @return {string}
         */
        var bigIntToBase64Url = function (num, length) {
          var hexString = num.toString(16);
          // Add an extra 0 to the start of the string to get a valid hex string (even length)
          // (e.g. 0x0123 instead of 0x123)
          var hexString = hexString.padStart(
            Math.ceil(hexString.length / 2) * 2,
            0
          );
          var buffer = uint8arrayFromHexString(hexString, length);
          return base64urlEncode(buffer);
        };

        /**
         * Converts a `BigInt` into a hex encoded string
         * @param {BigInt} num
         * @param {number} length: expected length of the resulting hex string
         * @return {string}
         */
        var bigIntToHex = function (num, length) {
          var hexString = num.toString(16);
          if (hexString.length > length) {
            const errorMessage = `number cannot fit in a hex string of ${length} characters`;
            reportError(errorMessage);
            throw new Error(errorMessage);
          }
          // Add an extra 0 to the start of the string to get to `length`
          return hexString.padStart(length, 0);
        };

        /**
         * Accepts a public key array buffer, and returns a buffer with the compressed version of the public key
         * @param {Uint8Array} rawPublicKey
         */
        var compressRawPublicKey = function (rawPublicKey) {
          const len = rawPublicKey.byteLength;

          // Drop the y coordinate
          // Uncompressed key is in the form 0x04||x||y
          // `len >>> 1` is a more concise way to write `floor(len/2)`
          var compressedBytes = rawPublicKey.slice(0, (1 + len) >>> 1);

          // Encode the parity of `y` in first bit
          // `BYTE & 0x01` tests for parity and returns 0x00 when even, or 0x01 when odd
          // Then `0x02 | <parity test result>` yields either 0x02 (even case) or 0x03 (odd).
          compressedBytes[0] = 0x02 | (rawPublicKey[len - 1] & 0x01);
          return compressedBytes;
        };

        /**
         * Accepts a public key array buffer, and returns a buffer with the uncompressed version of the public key
         * @param {Uint8Array} rawPublicKey
         * @return {Uint8Array} the uncompressed bytes
         */
        var uncompressRawPublicKey = function (rawPublicKey) {
          const len = rawPublicKey.byteLength;

          // point[0] must be 2 (false) or 3 (true).
          // this maps to the initial "02" or "03" prefix
          const lsb = rawPublicKey[0] === 3;
          const x = BigInt(
            "0x" + uint8arrayToHexString(rawPublicKey.subarray(1))
          );

          // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).
          const p = BigInt(
            "115792089210356248762697446949407573530086143415290314195533631308867097853951"
          );
          const b = BigInt(
            "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"
          );
          const a = p - BigInt(3);

          // Now compute y based on x
          const rhs = ((x * x + a) * x + b) % p;
          let y = modSqrt(rhs, p);
          if (lsb !== testBit(y, 0)) {
            y = (p - y) % p;
          }

          if (x < BigInt(0) || x >= p) {
            const errorMessage = "x is out of range";
            reportError(errorMessage);
            throw new Error(errorMessage);
          }

          if (y < BigInt(0) || y >= p) {
            const errorMessage = "y is out of range";
            reportError(errorMessage);
            throw new Error(errorMessage);
          }

          var uncompressedHexString =
            "04" + bigIntToHex(x, 64) + bigIntToHex(y, 64);
          return uint8arrayFromHexString(uncompressedHexString);
        };

        /**
         * Private helper to compute square root modulo p
         */
        function modSqrt(x, p) {
          if (p <= BigInt(0)) {
            const errorMessage = "p must be positive";
            reportError(errorMessage);
            throw new Error(errorMessage);
          }
          const base = x % p;
          // The currently supported NIST curves P-256, P-384, and P-521 all satisfy
          // p % 4 == 3.  However, although currently a no-op, the following check
          // should be left in place in case other curves are supported in the future.
          if (testBit(p, 0) && /* istanbul ignore next */ testBit(p, 1)) {
            // Case p % 4 == 3 (applies to NIST curves P-256, P-384, and P-521)
            // q = (p + 1) / 4
            const q = (p + BigInt(1)) >> BigInt(2);
            const squareRoot = modPow(base, q, p);
            if ((squareRoot * squareRoot) % p !== base) {
              const errorMessage = "could not find a modular square root";
              reportError(errorMessage);
              throw new Error(errorMessage);
            }
            return squareRoot;
          }
          // Skipping other elliptic curve types that require Cipolla's algorithm.
          const errorMessage = `unsupported modulus value: ${p}`;
          reportError(errorMessage);
          throw new Error(errorMessage);
        }

        /**
         * Private helper function used by `modSqrt`
         */
        function modPow(b, exp, p) {
          if (exp === BigInt(0)) {
            return BigInt(1);
          }
          let result = b;
          const exponentBitString = exp.toString(2);
          for (let i = 1; i < exponentBitString.length; ++i) {
            result = (result * result) % p;
            if (exponentBitString[i] === "1") {
              result = (result * b) % p;
            }
          }
          return result;
        }

        /**
         * Another private helper function used as part of `modSqrt`
         */
        function testBit(n, i) {
          const m = BigInt(1) << BigInt(i);
          return (n & m) !== BigInt(0);
        }

        /**********************************************************************************************
         * Start of private crypto implementation for P256 public key derivation from a private key.
         * ----
         * IMPORTANT NOTE: below we implement basic field arithmetic for P256
         * This is only used to compute public point from a secret key inside of
         * `importCredential` above. If something goes wrong with the code below
         * the web crypto API will simply refuse to import the key.
         * None of the functions below are returned from the closure to minimize the risk of misuse.
         *********************************************************************************************/

        /**
         * P256FieldElement represents a finite field element
         * The field is set to be the P256 prime:
         * 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
         */
        var P256FieldElement = function (num) {
          this.num = BigInt(num);
          this.prime = BigInt(
            "0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"
          );
        };
        P256FieldElement.prototype.eq = function (other) {
          return this.num === other.num;
        };
        P256FieldElement.prototype.add = function (other) {
          num = this.num + other.num;
          return new P256FieldElement(num % this.prime);
        };
        P256FieldElement.prototype.sub = function (other) {
          res = (this.num - other.num) % this.prime;
          if (res < BigInt(0)) {
            res += this.prime;
          }
          return new P256FieldElement(res);
        };
        P256FieldElement.prototype.mul = function (other) {
          if (typeof other === "bigint") {
            coefficient = other;
          } else if (typeof other === "number") {
            coefficient = BigInt(other);
          } else if (other instanceof P256FieldElement) {
            coefficient = other.num;
          } else {
            const errorMessage = `Cannot multiply element. Expected a BigInt, a Number or a P256FieldElement. Got: ${other}`;
            reportError(errorMessage);
            throw new Error(errorMessage);
          }
          num = (this.num * coefficient) % this.prime;
          return new P256FieldElement(num);
        };
        P256FieldElement.prototype.div = function (other) {
          // This uses fermat's little theorem (https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)
          // => if p is prime, then for any integer a: a**(p-1) % p = 1
          // => we can compute inverses for any a: 1/a = a**(p-2) % p
          return new P256FieldElement(other.num)
            .pow(this.prime - BigInt(2))
            .mul(this.num);
        };
        P256FieldElement.prototype.pow = function (exponent) {
          var exponent = BigInt(exponent);
          var base = this.num % this.prime;
          // Pretty standard double-and-add loop
          var result = 1n;
          while (exponent > BigInt(0)) {
            if (exponent % BigInt(2)) {
              result = (result * base) % this.prime;
            }
            exponent = exponent / BigInt(2);
            base = (base * base) % this.prime;
          }
          return new P256FieldElement(result);
        };

        /**
         * P256Point is a point (x, y) on the following elliptic curve:
         *     y**2 = x**3 + ax + b
         *     (where x and y are both finite field elements on the P256 field)
         * https://www.secg.org/sec2-v2.pdf, https://neuromancer.sk/std/nist/P-256
         *
         * We only define + and * since that's what's needed for public key derivation.
         */
        P256Point = function (x, y) {
          if (!x instanceof P256FieldElement) {
            const errorMessage = `expected a P256FieldElement for x. Got: ${x}`;
            reportError(errorMessage);
            throw new Error(errorMessage);
          }
          this.x = x;

          if (!y instanceof P256FieldElement) {
            const errorMessage = `expected a P256FieldElement for y. Got: ${y}`;
            reportError(errorMessage);
            throw new Error(errorMessage);
          }
          this.y = y;
          this.a = new P256FieldElement(
            BigInt(
              "0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"
            )
          );
          this.b = new P256FieldElement(
            BigInt(
              "0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"
            )
          );

          if (this.x === null && this.y === null) {
            // Point at infinity
            return;
          }

          var left = this.y.pow(2).num;
          var right = this.x.pow(3).add(this.x.mul(this.a)).add(this.b).num;

          if (left != right) {
            // y**2 = x**3 + 7 is the elliptic curve equation
            const errorMessage = `Not on the P256 curve! y**2 (${left}) != x3 + ax + b (${right})`;
            reportError(errorMessage);
            throw new Error(errorMessage);
          }
        };

        /**
         * Addition is a complex operation because of the number of cases involved.
         * The point at infinity is represented by (x=null, y=null), and represents the logical "0".
         * So, to compute `A.add(B)`:
         * - Case 1a: if A is 0, return B (0+B=B)
         * - Case 1b: if B is 0, return A (A+0=A)
         * - Case 2: if A and B have the same x but different y coordinates, they're
         *           opposite points: B is "-A". So, A+B=A+(-A)=0 (return point at infinity)
         * - Case 3: if A and B are the same and at y=0, the A->B line is tangent to the y axis
         *           -> return point at infinity
         * - Case 4: if A and B are the same (with y≠0), the formula for the result R (x3, y3):
         *           s = (3*x1**2 + a) / 2*y1
         *           x3 = s**2 - 2*x1
         *           y3 = s*(x1 - x3) - y1
         *           -> return (x3, y3)
         * - Case 5: general case (different x coordinates). To get R (x3, y3) from A and B:
         *           s = (y2 -y1) / (x2 - x1)
         *           x3 = s**2 - x1 - x2
         *           y3 = s*(x1 - x3) - y1
         *           -> return (x3, y3)
         *
         * See https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_addition for helpful visuals
         */
        P256Point.prototype.add = function (other) {
          if (this.x === null) {
            return other;
          } /* 1a */
          if (other.x === null) {
            return this;
          } /* 1b */

          /* 2 */
          if (this.x.eq(other.x) === true && this.y.eq(this.y) === false) {
            return new P256Point(null, null);
          }

          /* 3 */
          if (
            this.x.eq(other.x) &&
            this.y.eq(other.y) &&
            this.y.eq(new P256FieldElement(0))
          ) {
            return new P256Point(null, null);
          }

          /* 4 */
          if (this.x.eq(other.x) && this.y.eq(other.y)) {
            s = this.x.pow(2).mul(3).add(this.a).div(this.y.mul(2));
            x = s.pow(2).sub(this.x.mul(2));
            y = s.mul(this.x.sub(x)).sub(this.y);
            return new P256Point(x, y);
          }

          /* 5 */
          if (this.x.eq(other.x) === false) {
            s = other.y.sub(this.y).div(other.x.sub(this.x));
            x = s.pow(2).sub(this.x).sub(other.x);
            y = s.mul(this.x.sub(x)).sub(this.y);
            return new P256Point(x, y);
          }
          const errorMessage = `cannot handle addition of (${this.x}, ${this.y}) with (${other.x}, ${other.y})`;
          reportError(errorMessage);
          throw new Error(errorMessage);
        };
        /**
         * Multiplication uses addition. Nothing crazy here.
         * We start with "0" (point at infinity). Then we add increasing powers of 2.
         * So, to multiply A by e.g. 25 (25 is 11001 in binary), we add 1*A, then compute
         * 2*A, 4*A, 8*A by successive additions. Then add 8*A, then compute 16*A, then
         * add 16*A.
         */
        P256Point.prototype.multiply = function (coefficient) {
          var coef = BigInt(coefficient);
          var current = this;
          var result = new P256Point(null, null);
          while (coef) {
            if (coef & BigInt(1)) {
              result = result.add(current);
            }
            current = current.add(current);
            coef >>= BigInt(1);
          }
          return result;
        };

        /**
         * This is the P256 base point (aka generator)
         * See https://www.secg.org/sec2-v2.pdf and https://neuromancer.sk/std/nist/P-256
         */
        var P256Generator = new P256Point(
          new P256FieldElement(
            BigInt(
              "0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"
            )
          ),
          new P256FieldElement(
            BigInt(
              "0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
            )
          )
        );

        /**********************************************************************************************
         * End of private crypto implementation for P256 public key derivation from a private key.
         *********************************************************************************************/

        return {
          initEmbeddedKey,
          getEmbeddedKey,
          generateTargetKey,
          setItemWithExpiry,
          getItemWithExpiry,
          getEmbeddedKey,
          setEmbeddedKey,
          resetEmbeddedKey,
          importCredential,
          compressRawPublicKey,
          uncompressRawPublicKey,
          p256JWKPrivateToPublic,
          convertEcdsaIeee1363ToDer,
          sendMessageUp,
          setParentFrameMessageChannelPort,
          logMessage,
          reportError,
          base64urlEncode,
          base64urlDecode,
          base58checkDecode,
          bigIntToHex,
          stringToBase64urlString,
          uint8arrayToHexString,
          uint8arrayFromHexString,
          additionalAssociatedData,
        };
      })();
    </script>

    <script type="module">
      // Vendor @hpke/core from https://esm.sh/@hpke/core@1.2.7
      import * as hpke from "./hpke-core.js";

      // In memory spot for the credential to live. We do NOT persist it to localStorage.
      var CREDENTIAL_BYTES = null;

      // persist the MessageChannel object so we can use it to communicate with the parent window
      var iframeMessagePort = null;

      // controllers to remove event listeners
      const messageListenerController = new AbortController();
      const turnkeyInitController = new AbortController();

      /**
       * DOM Event handlers to power the recovery and auth flows in standalone mode
       * Instead of receiving events from the parent page, forms trigger them.
       * This is useful for debugging as well.
       */
      var addDOMEventListeners = function () {
        document.getElementById("inject").addEventListener(
          "click",
          async function (e) {
            e.preventDefault();
            window.postMessage({
              type: "INJECT_CREDENTIAL_BUNDLE",
              value: document.getElementById("credential-bundle").value,
            });
          },
          false
        );
        document.getElementById("stamp").addEventListener(
          "click",
          async function (e) {
            e.preventDefault();
            window.postMessage({
              type: "STAMP_REQUEST",
              value: document.getElementById("payload").value,
            });
          },
          false
        );
        // Reset isn't a completely accurate name for this because this only clears the key, without regenerating a fresh one
        document.getElementById("reset").addEventListener(
          "click",
          async function (e) {
            e.preventDefault();
            window.postMessage({ type: "RESET_EMBEDDED_KEY" });
          },
          false
        );
      };

      /**
       * Message Event Handlers to process messages from the parent frame
       */
      var messageEventListener = async function (event) {
        if (
          event.data &&
          (event.data["type"] == "INJECT_CREDENTIAL_BUNDLE" ||
            event.data["type"] == "INJECT_RECOVERY_BUNDLE")
        ) {
          TKHQ.logMessage(
            `⬇️ Received message ${event.data["type"]}: ${event.data["value"]}`
          );
          try {
            await onInjectBundle(event.data["value"], event.data["requestId"]);
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString(), event.data["requestId"]);
          }
        }
        if (event.data && event.data["type"] == "STAMP_REQUEST") {
          TKHQ.logMessage(
            `⬇️ Received message ${event.data["type"]}: ${event.data["value"]}`
          );
          try {
            await onStampRequest(event.data["value"], event.data["requestId"]);
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString(), event.data["requestId"]);
          }
        }
        if (event.data && event.data["type"] == "RESET_EMBEDDED_KEY") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}`);
          try {
            await onResetEmbeddedKey(event.data["requestId"]);
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString());
          }
        }
        if (event.data && event.data["type"] == "GET_EMBEDDED_PUBLIC_KEY") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}`);
          try {
            await onGetEmbeddedPublicKey(event.data["requestId"]);
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString());
          }
        }
        if (event.data && event.data["type"] == "INIT_EMBEDDED_KEY") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}`);
          try {
            await onInitEmbeddedKey(event.data["requestId"]);
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString());
          }
        }
      };

      /**
       * Initialize the embedded key and set up the DOM and message event listeners
       */
      document.addEventListener(
        "DOMContentLoaded",
        async function () {
          window.isInitEmbeddedKeyRunByDomContentLoaded =
            await TKHQ.initEmbeddedKey();
          var embeddedKeyJwk = await TKHQ.getEmbeddedKey();
          var targetPubBuf = await TKHQ.p256JWKPrivateToPublic(embeddedKeyJwk);
          var targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
          document.getElementById("embedded-key").value = targetPubHex;

          window.addEventListener("message", messageEventListener, {
            capture: false,
            signal: messageListenerController.signal,
          });

          addDOMEventListeners();

          TKHQ.sendMessageUp("PUBLIC_KEY_READY", targetPubHex);
        },
        false
      );

      window.addEventListener(
        "message",
        async function (event) {
          /**
           * @turnkey/iframe-stamper >= v2.1.0 is using a MessageChannel to communicate with the parent frame.
           * The parent frame sends a TURNKEY_INIT_MESSAGE_CHANNEL event with the MessagePort.
           * If we receive this event, we want to remove the message event listener that was added in the DOMContentLoaded event to avoid processing messages twice.
           * We persist the MessagePort so we can use it to communicate with the parent window in subsequent calls to TKHQ.sendMessageUp
           */
          if (
            event.data &&
            event.data["type"] == "TURNKEY_INIT_MESSAGE_CHANNEL" &&
            event.ports?.[0]
          ) {
            // remove the message event listener that was added in the DOMContentLoaded event
            messageListenerController.abort();

            iframeMessagePort = event.ports[0];
            iframeMessagePort.onmessage = messageEventListener;

            TKHQ.setParentFrameMessageChannelPort(iframeMessagePort);

            let iframeKeyTtl = TKHQ.TURNKEY_EMBEDDED_KEY_TTL_IN_MILLIS;
            if (
              event.data.dangerouslyOverrideIframeKeyTtl &&
              typeof event.data.dangerouslyOverrideIframeKeyTtl === "number" &&
              event.data.dangerouslyOverrideIframeKeyTtl > 0
            ) {
              iframeKeyTtl = event.data.dangerouslyOverrideIframeKeyTtl;
            }
            if (window.isInitEmbeddedKeyRunByDomContentLoaded) {
              await TKHQ.resetEmbeddedKey();
              document.getElementById("embedded-key").value = "";
            }
            await TKHQ.initEmbeddedKey(iframeKeyTtl);

            var embeddedKeyJwk = await TKHQ.getEmbeddedKey();
            var targetPubBuf = await TKHQ.p256JWKPrivateToPublic(
              embeddedKeyJwk
            );
            var targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
            document.getElementById("embedded-key").value = targetPubHex;

            TKHQ.sendMessageUp("PUBLIC_KEY_READY", targetPubHex);

            // remove the listener for TURNKEY_INIT_MESSAGE_CHANNEL after it's been processed
            turnkeyInitController.abort();
          }
        },
        { signal: turnkeyInitController.signal }
      );

      /**
       * Function triggered when INJECT_CREDENTIAL_BUNDLE event is received.
       * The `bundle` param is the concatenation of a public key and an encrypted payload, and then base64 encoded
       * Example: A6ZPGAlxBRZhjKWky4RpXnHVceGzJjTuBrzKvMGnIgZ3r6JD4D1iiSg_m-y_u0BgJKI397Xjn0wgu17w9wuRooEp-F38m4ql57FgQ7sX9nQA
       * @param {string} bundle
       * @param {string} requestId
       */
      var onInjectBundle = async function (bundle, requestId) {
        if (
          // Non-alphanumerical characters in base64url: - and _. These aren't in base58.
          bundle.indexOf("-") === -1 &&
          bundle.indexOf("_") === -1 &&
          // Uppercase o (O), uppercase i (I), lowercase L (l), and 0 aren't in the character set either.
          bundle.indexOf("O") === -1 &&
          bundle.indexOf("I") === -1 &&
          bundle.indexOf("l") === -1 &&
          bundle.indexOf("0") === -1
        ) {
          // If none of these characters are in the bundle we assume it's a base58check-encoded string
          // This isn't perfect: there's a small chance that a base64url-encoded string doesn't have any of these characters by chance!
          // But we accept this risk given this branching is only here to support our transition to base58check.
          // I hear you'd like to quantify this risk? Let's do it.
          // Assuming random bytes in our bundle and a bundle length of 33 (public key, compressed) + 48 (encrypted cred) = 81 bytes.
          // The odds of a byte being in the overlap set between base58 and base64url is 58/64=0.90625.
          // Which means the odds of a 81 bytes string being in the overlap character set for its entire length is...
          // ... 0.90625^81 = 0.0003444209703
          // Are you convinced that this is good enough? I am :)
          var bundleBytes = await TKHQ.base58checkDecode(bundle);
        } else {
          var bundleBytes = TKHQ.base64urlDecode(bundle);
        }

        if (bundleBytes.byteLength <= 33) {
          const errorMessage = `bundle size ${bundleBytes.byteLength} is too low. Expecting a compressed public key (33 bytes) and an encrypted credential`;
          TKHQ.reportError(errorMessage);
          throw new Error(errorMessage);
        }

        var compressedEncappedKeyBuf = bundleBytes.subarray(0, 33);
        var ciphertextBuf = bundleBytes.subarray(33);
        var embeddedKeyJwk = await TKHQ.getEmbeddedKey();

        // Decompress the compressed key
        var encappedKeyBuf = TKHQ.uncompressRawPublicKey(
          compressedEncappedKeyBuf
        );

        var credentialBytes = await HpkeDecrypt({
          ciphertextBuf,
          encappedKeyBuf,
          receiverPrivJwk: embeddedKeyJwk,
        });

        CREDENTIAL_BYTES = new Uint8Array(credentialBytes);
        TKHQ.sendMessageUp("BUNDLE_INJECTED", true, requestId);
      };

      /**
       * Function triggered when GET_EMBEDDED_PUBLIC_KEY event is received.
       * @param {string} requestId: idempotency key
       */
      var onGetEmbeddedPublicKey = async function (requestId) {
        var embeddedKeyJwk = await TKHQ.getEmbeddedKey();

        // If we don't have an embedded key, return an empty string as the public key
        if (!embeddedKeyJwk) {
          TKHQ.sendMessageUp("EMBEDDED_PUBLIC_KEY", "", requestId);
        }

        var targetPubBuf = await TKHQ.p256JWKPrivateToPublic(embeddedKeyJwk);
        var targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);

        TKHQ.sendMessageUp("EMBEDDED_PUBLIC_KEY", targetPubHex, requestId);
      };

      /**
       * Function triggered when INIT_EMBEDDED_KEY event is received.
       * @param {string} requestId: idempotency key
       */
      var onInitEmbeddedKey = async function (requestId) {
        await TKHQ.initEmbeddedKey();
        var embeddedKeyJwk = await TKHQ.getEmbeddedKey();
        var targetPubBuf = await TKHQ.p256JWKPrivateToPublic(embeddedKeyJwk);
        var targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
        document.getElementById("embedded-key").value = targetPubHex;

        TKHQ.sendMessageUp("EMBEDDED_PUBLIC_KEY", targetPubHex, requestId);
      };

      /**
       * Removes the embedded key from local storage.
       */
      var onResetEmbeddedKey = async function (requestId) {
        await TKHQ.resetEmbeddedKey();
        document.getElementById("embedded-key").value = "";

        TKHQ.sendMessageUp("EMBEDDED_KEY_RESET", null, requestId);
      };

      /**
       * Function triggered when STAMP_REQUEST event is received.
       * @param {string} payload: payload to sign
       * @param {string} requestId: idempotency key
       */
      var onStampRequest = async function (payload, requestId) {
        if (CREDENTIAL_BYTES === null) {
          const errorMessage =
            "cannot sign payload without credential. Credential bytes are null. Has a credential bundle been injected into the iframe?";
          TKHQ.reportError(errorMessage);
          throw new Error(errorMessage);
        }
        var key = await TKHQ.importCredential(CREDENTIAL_BYTES);
        var signatureIeee1363 = await window.crypto.subtle.sign(
          {
            name: "ECDSA",
            hash: { name: "SHA-256" },
          },
          key,
          new TextEncoder().encode(payload)
        );

        var derSignature = TKHQ.convertEcdsaIeee1363ToDer(
          new Uint8Array(signatureIeee1363)
        );
        var derSignatureHexString = TKHQ.uint8arrayToHexString(derSignature);

        // This is a bit of a pain, but we need to go through this:
        // - Key needs to be exported to JWK first
        // - Then imported without the private "d" component, and exported to get the public key
        //   ^^ (that's what `p256JWKPrivateToPublic` does)
        // - Finally, compress the public key.
        var jwkKey = await crypto.subtle.exportKey("jwk", key);
        var publicKey = await TKHQ.p256JWKPrivateToPublic(jwkKey);
        var compressedPublicKey = TKHQ.compressRawPublicKey(publicKey);

        var stamp = {
          publicKey: TKHQ.uint8arrayToHexString(compressedPublicKey),
          scheme: "SIGNATURE_SCHEME_TK_API_P256",
          signature: derSignatureHexString,
        };

        var stampHeaderValue = TKHQ.stringToBase64urlString(
          JSON.stringify(stamp)
        );
        TKHQ.sendMessageUp("STAMP", stampHeaderValue, requestId);
      };

      /**
       * Decrypt the ciphertext (ArrayBuffer) given an encapsulation key (ArrayBuffer)
       * and the receivers private key (JSON Web Key).
       */
      var HpkeDecrypt = async function ({
        ciphertextBuf,
        encappedKeyBuf,
        receiverPrivJwk,
      }) {
        var kemContext = new hpke.DhkemP256HkdfSha256();
        var receiverPriv = await kemContext.importKey(
          "jwk",
          { ...receiverPrivJwk },
          false
        );

        var suite = new hpke.CipherSuite({
          kem: kemContext,
          kdf: new hpke.HkdfSha256(),
          aead: new hpke.Aes256Gcm(),
        });

        var recipientCtx = await suite.createRecipientContext({
          recipientKey: receiverPriv,
          enc: encappedKeyBuf,
          info: new TextEncoder().encode("turnkey_hpke"),
        });

        var receiverPubBuf = await TKHQ.p256JWKPrivateToPublic(receiverPrivJwk);
        var aad = TKHQ.additionalAssociatedData(encappedKeyBuf, receiverPubBuf);
        var res;
        try {
          res = await recipientCtx.open(ciphertextBuf, aad);
        } catch (e) {
          const errorMessage = `unable to decrypt bundle using embedded key. the bundle may be incorrect. failed with error: ${e.toString()}`;
          TKHQ.reportError(errorMessage);
          throw new Error(errorMessage);
        }
        return res;
      };
    </script>
  </body>
</html>
