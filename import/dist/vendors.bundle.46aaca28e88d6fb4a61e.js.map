{"version":3,"file":"vendors.bundle.46aaca28e88d6fb4a61e.js","mappings":"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","sources":["webpack://import/./node_modules/@hpke/common/esm/src/errors.js","webpack://import/./node_modules/@hpke/common/esm/_dnt.shims.js","webpack://import/./node_modules/@hpke/common/esm/src/algorithm.js","webpack://import/./node_modules/@hpke/common/esm/src/identifiers.js","webpack://import/./node_modules/@hpke/common/esm/src/consts.js","webpack://import/./node_modules/@hpke/common/esm/src/interfaces/kemInterface.js","webpack://import/./node_modules/@hpke/common/esm/src/utils/misc.js","webpack://import/./node_modules/@hpke/common/esm/src/kems/dhkem.js","webpack://import/./node_modules/@hpke/common/esm/src/interfaces/dhkemPrimitives.js","webpack://import/./node_modules/@hpke/common/esm/src/utils/bignum.js","webpack://import/./node_modules/@hpke/common/esm/src/kems/dhkemPrimitives/ec.js","webpack://import/./node_modules/@hpke/common/esm/src/kdfs/hkdf.js","webpack://import/./node_modules/@hpke/common/esm/src/interfaces/aeadEncryptionContext.js","webpack://import/./node_modules/@hpke/common/esm/src/curve/montgomery.js","webpack://import/./node_modules/@hpke/core/esm/src/aeads/aesGcm.js","webpack://import/./node_modules/@hpke/core/esm/src/utils/emitNotSupported.js","webpack://import/./node_modules/@hpke/core/esm/src/exporterContext.js","webpack://import/./node_modules/@hpke/core/esm/src/encryptionContext.js","webpack://import/./node_modules/@hpke/core/esm/src/mutex.js","webpack://import/./node_modules/@hpke/core/esm/src/recipientContext.js","webpack://import/./node_modules/@hpke/core/esm/src/senderContext.js","webpack://import/./node_modules/@hpke/core/esm/src/cipherSuiteNative.js","webpack://import/./node_modules/@hpke/core/esm/src/kems/dhkemNative.js","webpack://import/./node_modules/@hpke/core/esm/src/native.js","webpack://import/./node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/x25519.js","webpack://import/./node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/x448.js","webpack://import/../shared/node_modules/bech32/dist/index.js"],"sourcesContent":["/**\n * The base error class of hpke-js.\n * @group Errors\n */\nexport class HpkeError extends Error {\n    constructor(e) {\n        let message;\n        if (e instanceof Error) {\n            message = e.message;\n        }\n        else if (typeof e === \"string\") {\n            message = e;\n        }\n        else {\n            message = \"\";\n        }\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\n/**\n * Invalid parameter.\n * @group Errors\n */\nexport class InvalidParamError extends HpkeError {\n}\n/**\n * KEM input or output validation failure.\n * @group Errors\n */\nexport class ValidationError extends HpkeError {\n}\n/**\n * Public or private key serialization failure.\n * @group Errors\n */\nexport class SerializeError extends HpkeError {\n}\n/**\n * Public or private key deserialization failure.\n * @group Errors\n */\nexport class DeserializeError extends HpkeError {\n}\n/**\n * encap() failure.\n * @group Errors\n */\nexport class EncapError extends HpkeError {\n}\n/**\n * decap() failure.\n * @group Errors\n */\nexport class DecapError extends HpkeError {\n}\n/**\n * Secret export failure.\n * @group Errors\n */\nexport class ExportError extends HpkeError {\n}\n/**\n * seal() failure.\n * @group Errors\n */\nexport class SealError extends HpkeError {\n}\n/**\n * open() failure.\n * @group Errors\n */\nexport class OpenError extends HpkeError {\n}\n/**\n * Sequence number overflow on the encryption context.\n * @group Errors\n */\nexport class MessageLimitReachedError extends HpkeError {\n}\n/**\n * Key pair derivation failure.\n * @group Errors\n */\nexport class DeriveKeyPairError extends HpkeError {\n}\n/**\n * Not supported failure.\n * @group Errors\n */\nexport class NotSupportedError extends HpkeError {\n}\n","const dntGlobals = {};\nexport const dntGlobalThis = createMergeProxy(globalThis, dntGlobals);\nfunction createMergeProxy(baseObj, extObj) {\n    return new Proxy(baseObj, {\n        get(_target, prop, _receiver) {\n            if (prop in extObj) {\n                return extObj[prop];\n            }\n            else {\n                return baseObj[prop];\n            }\n        },\n        set(_target, prop, value) {\n            if (prop in extObj) {\n                delete extObj[prop];\n            }\n            baseObj[prop] = value;\n            return true;\n        },\n        deleteProperty(_target, prop) {\n            let success = false;\n            if (prop in extObj) {\n                delete extObj[prop];\n                success = true;\n            }\n            if (prop in baseObj) {\n                delete baseObj[prop];\n                success = true;\n            }\n            return success;\n        },\n        ownKeys(_target) {\n            const baseKeys = Reflect.ownKeys(baseObj);\n            const extKeys = Reflect.ownKeys(extObj);\n            const extKeysSet = new Set(extKeys);\n            return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];\n        },\n        defineProperty(_target, prop, desc) {\n            if (prop in extObj) {\n                delete extObj[prop];\n            }\n            Reflect.defineProperty(baseObj, prop, desc);\n            return true;\n        },\n        getOwnPropertyDescriptor(_target, prop) {\n            if (prop in extObj) {\n                return Reflect.getOwnPropertyDescriptor(extObj, prop);\n            }\n            else {\n                return Reflect.getOwnPropertyDescriptor(baseObj, prop);\n            }\n        },\n        has(_target, prop) {\n            return prop in extObj || prop in baseObj;\n        },\n    });\n}\n","import * as dntShim from \"../_dnt.shims.js\";\nimport { NotSupportedError } from \"./errors.js\";\nasync function loadSubtleCrypto() {\n    if (dntShim.dntGlobalThis !== undefined && globalThis.crypto !== undefined) {\n        // Browsers, Node.js >= v19, Cloudflare Workers, Bun, etc.\n        return globalThis.crypto.subtle;\n    }\n    // Node.js <= v18\n    try {\n        // @ts-ignore: to ignore \"crypto\"\n        const { webcrypto } = await import(\"crypto\"); // node:crypto\n        return webcrypto.subtle;\n    }\n    catch (e) {\n        throw new NotSupportedError(e);\n    }\n}\nexport class NativeAlgorithm {\n    constructor() {\n        Object.defineProperty(this, \"_api\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    async _setup() {\n        if (this._api !== undefined) {\n            return;\n        }\n        this._api = await loadSubtleCrypto();\n    }\n}\n","/**\n * The supported HPKE modes.\n */\nexport const Mode = {\n    Base: 0x00,\n    Psk: 0x01,\n    Auth: 0x02,\n    AuthPsk: 0x03,\n};\n/**\n * The supported Key Encapsulation Mechanism (KEM) identifiers.\n */\nexport const KemId = {\n    NotAssigned: 0x0000,\n    DhkemP256HkdfSha256: 0x0010,\n    DhkemP384HkdfSha384: 0x0011,\n    DhkemP521HkdfSha512: 0x0012,\n    DhkemSecp256k1HkdfSha256: 0x0013,\n    DhkemX25519HkdfSha256: 0x0020,\n    DhkemX448HkdfSha512: 0x0021,\n    HybridkemX25519Kyber768: 0x0030,\n    MlKem512: 0x0040,\n    MlKem768: 0x0041,\n    MlKem1024: 0x0042,\n    XWing: 0x647a,\n};\n/**\n * The supported Key Derivation Function (KDF) identifiers.\n */\nexport const KdfId = {\n    HkdfSha256: 0x0001,\n    HkdfSha384: 0x0002,\n    HkdfSha512: 0x0003,\n};\n/**\n * The supported Authenticated Encryption with Associated Data (AEAD) identifiers.\n */\nexport const AeadId = {\n    Aes128Gcm: 0x0001,\n    Aes256Gcm: 0x0002,\n    Chacha20Poly1305: 0x0003,\n    ExportOnly: 0xFFFF,\n};\n","// The input length limit (psk, psk_id, info, exporter_context, ikm).\nexport const INPUT_LENGTH_LIMIT = 8192;\nexport const INFO_LENGTH_LIMIT = 65536;\n// The minimum length of a PSK.\nexport const MINIMUM_PSK_LENGTH = 32;\n// b\"\"\nexport const EMPTY = new Uint8Array(0);\n","// b\"KEM\"\nexport const SUITE_ID_HEADER_KEM = new Uint8Array([\n    75,\n    69,\n    77,\n    0,\n    0,\n]);\n","import * as dntShim from \"../../_dnt.shims.js\";\nimport { KemId } from \"../identifiers.js\";\nexport const isDenoV1 = () => \n// deno-lint-ignore no-explicit-any\ndntShim.dntGlobalThis.process === undefined;\n/**\n * Checks whether the runtime is Deno or not (Node.js).\n * @returns boolean - true if the runtime is Deno, false Node.js.\n */\nexport function isDeno() {\n    // deno-lint-ignore no-explicit-any\n    if (dntShim.dntGlobalThis.process === undefined) {\n        return true;\n    }\n    // deno-lint-ignore no-explicit-any\n    return dntShim.dntGlobalThis.process?.versions?.deno !== undefined;\n}\n/**\n * Checks whetehr the type of input is CryptoKeyPair or not.\n */\nexport const isCryptoKeyPair = (x) => typeof x === \"object\" &&\n    x !== null &&\n    typeof x.privateKey === \"object\" &&\n    typeof x.publicKey === \"object\";\n/**\n * Converts integer to octet string. I2OSP implementation.\n */\nexport function i2Osp(n, w) {\n    if (w <= 0) {\n        throw new Error(\"i2Osp: too small size\");\n    }\n    if (n >= 256 ** w) {\n        throw new Error(\"i2Osp: too large integer\");\n    }\n    const ret = new Uint8Array(w);\n    for (let i = 0; i < w && n; i++) {\n        ret[w - (i + 1)] = n % 256;\n        n = n >> 8;\n    }\n    return ret;\n}\n/**\n * Concatenates two Uint8Arrays.\n * @param a Uint8Array\n * @param b Uint8Array\n * @returns Concatenated Uint8Array\n */\nexport function concat(a, b) {\n    const ret = new Uint8Array(a.length + b.length);\n    ret.set(a, 0);\n    ret.set(b, a.length);\n    return ret;\n}\n/**\n * Decodes Base64Url-encoded data.\n * @param v Base64Url-encoded string\n * @returns Uint8Array\n */\nexport function base64UrlToBytes(v) {\n    const base64 = v.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const byteString = atob(base64);\n    const ret = new Uint8Array(byteString.length);\n    for (let i = 0; i < byteString.length; i++) {\n        ret[i] = byteString.charCodeAt(i);\n    }\n    return ret;\n}\n/**\n * Encodes Uint8Array to Base64Url.\n * @param v Uint8Array\n * @returns Base64Url-encoded string\n */\nexport function bytesToBase64Url(v) {\n    return btoa(String.fromCharCode(...v))\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=*$/g, \"\");\n}\n/**\n * Decodes hex string to Uint8Array.\n * @param v Hex string\n * @returns Uint8Array\n * @throws Error if the input is not a hex string.\n */\nexport function hexToBytes(v) {\n    if (v.length === 0) {\n        return new Uint8Array([]);\n    }\n    const res = v.match(/[\\da-f]{2}/gi);\n    if (res == null) {\n        throw new Error(\"Not hex string.\");\n    }\n    return new Uint8Array(res.map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n/**\n * Encodes Uint8Array to hex string.\n * @param v Uint8Array\n * @returns Hex string\n */\nexport function bytesToHex(v) {\n    return [...v].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n}\n/**\n * Converts KemId to KeyAlgorithm.\n * @param kem KemId\n * @returns KeyAlgorithm\n */\nexport function kemToKeyGenAlgorithm(kem) {\n    switch (kem) {\n        case KemId.DhkemP256HkdfSha256:\n            return {\n                name: \"ECDH\",\n                namedCurve: \"P-256\",\n            };\n        case KemId.DhkemP384HkdfSha384:\n            return {\n                name: \"ECDH\",\n                namedCurve: \"P-384\",\n            };\n        case KemId.DhkemP521HkdfSha512:\n            return {\n                name: \"ECDH\",\n                namedCurve: \"P-521\",\n            };\n        default:\n            // case KemId.DhkemX25519HkdfSha256\n            return {\n                name: \"X25519\",\n            };\n    }\n}\nexport async function loadSubtleCrypto() {\n    if (dntShim.dntGlobalThis !== undefined && globalThis.crypto !== undefined) {\n        // Browsers, Node.js >= v19, Cloudflare Workers, Bun, etc.\n        return globalThis.crypto.subtle;\n    }\n    // Node.js <= v18\n    try {\n        // @ts-ignore: to ignore \"crypto\"\n        const { webcrypto } = await import(\"crypto\"); // node:crypto\n        return webcrypto.subtle;\n    }\n    catch (_e) {\n        throw new Error(\"Failed to load SubtleCrypto\");\n    }\n}\nexport async function loadCrypto() {\n    if (dntShim.dntGlobalThis !== undefined && globalThis.crypto !== undefined) {\n        // Browsers, Node.js >= v19, Cloudflare Workers, Bun, etc.\n        return globalThis.crypto;\n    }\n    // Node.js <= v18\n    try {\n        // @ts-ignore: to ignore \"crypto\"\n        const { webcrypto } = await import(\"crypto\"); // node:crypto\n        return webcrypto;\n    }\n    catch (_e) {\n        throw new Error(\"Web Cryptograph API not supported\");\n    }\n}\n/**\n * XOR for Uint8Array.\n */\nexport function xor(a, b) {\n    if (a.byteLength !== b.byteLength) {\n        throw new Error(\"xor: different length inputs\");\n    }\n    const buf = new Uint8Array(a.byteLength);\n    for (let i = 0; i < a.byteLength; i++) {\n        buf[i] = a[i] ^ b[i];\n    }\n    return buf;\n}\n","import { EMPTY, INPUT_LENGTH_LIMIT } from \"../consts.js\";\nimport { DecapError, EncapError, InvalidParamError } from \"../errors.js\";\nimport { SUITE_ID_HEADER_KEM } from \"../interfaces/kemInterface.js\";\nimport { concat, i2Osp, isCryptoKeyPair } from \"../utils/misc.js\";\n// b\"eae_prk\"\nconst LABEL_EAE_PRK = new Uint8Array([101, 97, 101, 95, 112, 114, 107]);\n// b\"shared_secret\"\n// deno-fmt-ignore\nconst LABEL_SHARED_SECRET = new Uint8Array([\n    115, 104, 97, 114, 101, 100, 95, 115, 101, 99,\n    114, 101, 116,\n]);\nfunction concat3(a, b, c) {\n    const ret = new Uint8Array(a.length + b.length + c.length);\n    ret.set(a, 0);\n    ret.set(b, a.length);\n    ret.set(c, a.length + b.length);\n    return ret;\n}\nexport class Dhkem {\n    constructor(id, prim, kdf) {\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_prim\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_kdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.id = id;\n        this._prim = prim;\n        this._kdf = kdf;\n        const suiteId = new Uint8Array(SUITE_ID_HEADER_KEM);\n        suiteId.set(i2Osp(this.id, 2), 3);\n        this._kdf.init(suiteId);\n    }\n    async serializePublicKey(key) {\n        return await this._prim.serializePublicKey(key);\n    }\n    async deserializePublicKey(key) {\n        return await this._prim.deserializePublicKey(key);\n    }\n    async serializePrivateKey(key) {\n        return await this._prim.serializePrivateKey(key);\n    }\n    async deserializePrivateKey(key) {\n        return await this._prim.deserializePrivateKey(key);\n    }\n    async importKey(format, key, isPublic = true) {\n        return await this._prim.importKey(format, key, isPublic);\n    }\n    async generateKeyPair() {\n        return await this._prim.generateKeyPair();\n    }\n    async deriveKeyPair(ikm) {\n        if (ikm.byteLength > INPUT_LENGTH_LIMIT) {\n            throw new InvalidParamError(\"Too long ikm\");\n        }\n        return await this._prim.deriveKeyPair(ikm);\n    }\n    async encap(params) {\n        let ke;\n        if (params.ekm === undefined) {\n            ke = await this.generateKeyPair();\n        }\n        else if (isCryptoKeyPair(params.ekm)) {\n            // params.ekm is only used for testing.\n            ke = params.ekm;\n        }\n        else {\n            // params.ekm is only used for testing.\n            ke = await this.deriveKeyPair(params.ekm);\n        }\n        const enc = await this._prim.serializePublicKey(ke.publicKey);\n        const pkrm = await this._prim.serializePublicKey(params.recipientPublicKey);\n        try {\n            let dh;\n            if (params.senderKey === undefined) {\n                dh = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));\n            }\n            else {\n                const sks = isCryptoKeyPair(params.senderKey)\n                    ? params.senderKey.privateKey\n                    : params.senderKey;\n                const dh1 = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));\n                const dh2 = new Uint8Array(await this._prim.dh(sks, params.recipientPublicKey));\n                dh = concat(dh1, dh2);\n            }\n            let kemContext;\n            if (params.senderKey === undefined) {\n                kemContext = concat(new Uint8Array(enc), new Uint8Array(pkrm));\n            }\n            else {\n                const pks = isCryptoKeyPair(params.senderKey)\n                    ? params.senderKey.publicKey\n                    : await this._prim.derivePublicKey(params.senderKey);\n                const pksm = await this._prim.serializePublicKey(pks);\n                kemContext = concat3(new Uint8Array(enc), new Uint8Array(pkrm), new Uint8Array(pksm));\n            }\n            const sharedSecret = await this._generateSharedSecret(dh, kemContext);\n            return {\n                enc: enc,\n                sharedSecret: sharedSecret,\n            };\n        }\n        catch (e) {\n            throw new EncapError(e);\n        }\n    }\n    async decap(params) {\n        const pke = await this._prim.deserializePublicKey(params.enc);\n        const skr = isCryptoKeyPair(params.recipientKey)\n            ? params.recipientKey.privateKey\n            : params.recipientKey;\n        const pkr = isCryptoKeyPair(params.recipientKey)\n            ? params.recipientKey.publicKey\n            : await this._prim.derivePublicKey(params.recipientKey);\n        const pkrm = await this._prim.serializePublicKey(pkr);\n        try {\n            let dh;\n            if (params.senderPublicKey === undefined) {\n                dh = new Uint8Array(await this._prim.dh(skr, pke));\n            }\n            else {\n                const dh1 = new Uint8Array(await this._prim.dh(skr, pke));\n                const dh2 = new Uint8Array(await this._prim.dh(skr, params.senderPublicKey));\n                dh = concat(dh1, dh2);\n            }\n            let kemContext;\n            if (params.senderPublicKey === undefined) {\n                kemContext = concat(new Uint8Array(params.enc), new Uint8Array(pkrm));\n            }\n            else {\n                const pksm = await this._prim.serializePublicKey(params.senderPublicKey);\n                kemContext = new Uint8Array(params.enc.byteLength + pkrm.byteLength + pksm.byteLength);\n                kemContext.set(new Uint8Array(params.enc), 0);\n                kemContext.set(new Uint8Array(pkrm), params.enc.byteLength);\n                kemContext.set(new Uint8Array(pksm), params.enc.byteLength + pkrm.byteLength);\n            }\n            return await this._generateSharedSecret(dh, kemContext);\n        }\n        catch (e) {\n            throw new DecapError(e);\n        }\n    }\n    async _generateSharedSecret(dh, kemContext) {\n        const labeledIkm = this._kdf.buildLabeledIkm(LABEL_EAE_PRK, dh);\n        const labeledInfo = this._kdf.buildLabeledInfo(LABEL_SHARED_SECRET, kemContext, this.secretSize);\n        return await this._kdf.extractAndExpand(EMPTY.buffer, labeledIkm.buffer, labeledInfo.buffer, this.secretSize);\n    }\n}\n","// The key usages for KEM.\nexport const KEM_USAGES = [\"deriveBits\"];\n// b\"dkp_prk\"\nexport const LABEL_DKP_PRK = new Uint8Array([\n    100,\n    107,\n    112,\n    95,\n    112,\n    114,\n    107,\n]);\n// b\"sk\"\nexport const LABEL_SK = new Uint8Array([115, 107]);\n","/**\n * The minimum inplementation of bignum to derive an EC key pair.\n */\nexport class Bignum {\n    constructor(size) {\n        Object.defineProperty(this, \"_num\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._num = new Uint8Array(size);\n    }\n    val() {\n        return this._num;\n    }\n    reset() {\n        this._num.fill(0);\n    }\n    set(src) {\n        if (src.length !== this._num.length) {\n            throw new Error(\"Bignum.set: invalid argument\");\n        }\n        this._num.set(src);\n    }\n    isZero() {\n        for (let i = 0; i < this._num.length; i++) {\n            if (this._num[i] !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    lessThan(v) {\n        if (v.length !== this._num.length) {\n            throw new Error(\"Bignum.lessThan: invalid argument\");\n        }\n        for (let i = 0; i < this._num.length; i++) {\n            if (this._num[i] < v[i]) {\n                return true;\n            }\n            if (this._num[i] > v[i]) {\n                return false;\n            }\n        }\n        return false;\n    }\n}\n","import { NativeAlgorithm } from \"../../algorithm.js\";\nimport { EMPTY } from \"../../consts.js\";\nimport { DeriveKeyPairError, DeserializeError, NotSupportedError, SerializeError, } from \"../../errors.js\";\nimport { KemId } from \"../../identifiers.js\";\nimport { KEM_USAGES, LABEL_DKP_PRK } from \"../../interfaces/dhkemPrimitives.js\";\nimport { Bignum } from \"../../utils/bignum.js\";\nimport { base64UrlToBytes, i2Osp } from \"../../utils/misc.js\";\n// b\"candidate\"\n// deno-fmt-ignore\nconst LABEL_CANDIDATE = new Uint8Array([\n    99, 97, 110, 100, 105, 100, 97, 116, 101,\n]);\n// the order of the curve being used.\n// deno-fmt-ignore\nconst ORDER_P_256 = new Uint8Array([\n    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84,\n    0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51,\n]);\n// deno-fmt-ignore\nconst ORDER_P_384 = new Uint8Array([\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,\n    0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a,\n    0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73,\n]);\n// deno-fmt-ignore\nconst ORDER_P_521 = new Uint8Array([\n    0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xfa, 0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f,\n    0x96, 0x6b, 0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09,\n    0xa5, 0xd0, 0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c,\n    0x47, 0xae, 0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38,\n    0x64, 0x09,\n]);\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_P_256 = new Uint8Array([\n    48, 65, 2, 1, 0, 48, 19, 6, 7, 42,\n    134, 72, 206, 61, 2, 1, 6, 8, 42, 134,\n    72, 206, 61, 3, 1, 7, 4, 39, 48, 37,\n    2, 1, 1, 4, 32,\n]);\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_P_384 = new Uint8Array([\n    48, 78, 2, 1, 0, 48, 16, 6, 7, 42,\n    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,\n    4, 0, 34, 4, 55, 48, 53, 2, 1, 1,\n    4, 48,\n]);\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_P_521 = new Uint8Array([\n    48, 96, 2, 1, 0, 48, 16, 6, 7, 42,\n    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,\n    4, 0, 35, 4, 73, 48, 71, 2, 1, 1,\n    4, 66,\n]);\nexport class Ec extends NativeAlgorithm {\n    constructor(kem, hkdf) {\n        super();\n        Object.defineProperty(this, \"_hkdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_alg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nPk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nSk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nDh\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // EC specific arguments for deriving key pair.\n        Object.defineProperty(this, \"_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_bitmask\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pkcs8AlgId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._hkdf = hkdf;\n        switch (kem) {\n            case KemId.DhkemP256HkdfSha256:\n                this._alg = { name: \"ECDH\", namedCurve: \"P-256\" };\n                this._nPk = 65;\n                this._nSk = 32;\n                this._nDh = 32;\n                this._order = ORDER_P_256;\n                this._bitmask = 0xFF;\n                this._pkcs8AlgId = PKCS8_ALG_ID_P_256;\n                break;\n            case KemId.DhkemP384HkdfSha384:\n                this._alg = { name: \"ECDH\", namedCurve: \"P-384\" };\n                this._nPk = 97;\n                this._nSk = 48;\n                this._nDh = 48;\n                this._order = ORDER_P_384;\n                this._bitmask = 0xFF;\n                this._pkcs8AlgId = PKCS8_ALG_ID_P_384;\n                break;\n            default:\n                // case KemId.DhkemP521HkdfSha512:\n                this._alg = { name: \"ECDH\", namedCurve: \"P-521\" };\n                this._nPk = 133;\n                this._nSk = 66;\n                this._nDh = 66;\n                this._order = ORDER_P_521;\n                this._bitmask = 0x01;\n                this._pkcs8AlgId = PKCS8_ALG_ID_P_521;\n                break;\n        }\n    }\n    async serializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._api.exportKey(\"raw\", key);\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, true);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async serializePrivateKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            if (!(\"d\" in jwk)) {\n                throw new Error(\"Not private key\");\n            }\n            return base64UrlToBytes(jwk[\"d\"]).buffer;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePrivateKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, false);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async importKey(format, key, isPublic) {\n        await this._setup();\n        try {\n            if (format === \"raw\") {\n                return await this._importRawKey(key, isPublic);\n            }\n            // jwk\n            if (key instanceof ArrayBuffer) {\n                throw new Error(\"Invalid jwk key format\");\n            }\n            return await this._importJWK(key, isPublic);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async generateKeyPair() {\n        await this._setup();\n        try {\n            return await this._api.generateKey(this._alg, true, KEM_USAGES);\n        }\n        catch (e) {\n            throw new NotSupportedError(e);\n        }\n    }\n    async deriveKeyPair(ikm) {\n        await this._setup();\n        try {\n            const dkpPrk = await this._hkdf.labeledExtract(EMPTY.buffer, LABEL_DKP_PRK, new Uint8Array(ikm));\n            const bn = new Bignum(this._nSk);\n            for (let counter = 0; bn.isZero() || !bn.lessThan(this._order); counter++) {\n                if (counter > 255) {\n                    throw new Error(\"Faild to derive a key pair\");\n                }\n                const bytes = new Uint8Array(await this._hkdf.labeledExpand(dkpPrk, LABEL_CANDIDATE, i2Osp(counter, 1), this._nSk));\n                bytes[0] = bytes[0] & this._bitmask;\n                bn.set(bytes);\n            }\n            const sk = await this._deserializePkcs8Key(bn.val());\n            bn.reset();\n            return {\n                privateKey: sk,\n                publicKey: await this.derivePublicKey(sk),\n            };\n        }\n        catch (e) {\n            throw new DeriveKeyPairError(e);\n        }\n    }\n    async derivePublicKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            delete jwk[\"d\"];\n            delete jwk[\"key_ops\"];\n            return await this._api.importKey(\"jwk\", jwk, this._alg, true, []);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async dh(sk, pk) {\n        try {\n            await this._setup();\n            const bits = await this._api.deriveBits({\n                name: \"ECDH\",\n                public: pk,\n            }, sk, this._nDh * 8);\n            return bits;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async _importRawKey(key, isPublic) {\n        if (isPublic && key.byteLength !== this._nPk) {\n            throw new Error(\"Invalid public key for the ciphersuite\");\n        }\n        if (!isPublic && key.byteLength !== this._nSk) {\n            throw new Error(\"Invalid private key for the ciphersuite\");\n        }\n        if (isPublic) {\n            return await this._api.importKey(\"raw\", key, this._alg, true, []);\n        }\n        return await this._deserializePkcs8Key(new Uint8Array(key));\n    }\n    async _importJWK(key, isPublic) {\n        if (typeof key.crv === \"undefined\" || key.crv !== this._alg.namedCurve) {\n            throw new Error(`Invalid crv: ${key.crv}`);\n        }\n        if (isPublic) {\n            if (typeof key.d !== \"undefined\") {\n                throw new Error(\"Invalid key: `d` should not be set\");\n            }\n            return await this._api.importKey(\"jwk\", key, this._alg, true, []);\n        }\n        if (typeof key.d === \"undefined\") {\n            throw new Error(\"Invalid key: `d` not found\");\n        }\n        return await this._api.importKey(\"jwk\", key, this._alg, true, KEM_USAGES);\n    }\n    async _deserializePkcs8Key(k) {\n        const pkcs8Key = new Uint8Array(this._pkcs8AlgId.length + k.length);\n        pkcs8Key.set(this._pkcs8AlgId, 0);\n        pkcs8Key.set(k, this._pkcs8AlgId.length);\n        return await this._api.importKey(\"pkcs8\", pkcs8Key, this._alg, true, KEM_USAGES);\n    }\n}\n","import { EMPTY } from \"../consts.js\";\nimport { InvalidParamError } from \"../errors.js\";\nimport { KdfId } from \"../identifiers.js\";\nimport { NativeAlgorithm } from \"../algorithm.js\";\n// b\"HPKE-v1\"\nconst HPKE_VERSION = new Uint8Array([72, 80, 75, 69, 45, 118, 49]);\nexport class HkdfNative extends NativeAlgorithm {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha256\n        });\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_suiteId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: EMPTY\n        });\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-256\",\n                length: 256,\n            }\n        });\n    }\n    init(suiteId) {\n        this._suiteId = suiteId;\n    }\n    buildLabeledIkm(label, ikm) {\n        this._checkInit();\n        const ret = new Uint8Array(7 + this._suiteId.byteLength + label.byteLength + ikm.byteLength);\n        ret.set(HPKE_VERSION, 0);\n        ret.set(this._suiteId, 7);\n        ret.set(label, 7 + this._suiteId.byteLength);\n        ret.set(ikm, 7 + this._suiteId.byteLength + label.byteLength);\n        return ret;\n    }\n    buildLabeledInfo(label, info, len) {\n        this._checkInit();\n        const ret = new Uint8Array(9 + this._suiteId.byteLength + label.byteLength + info.byteLength);\n        ret.set(new Uint8Array([0, len]), 0);\n        ret.set(HPKE_VERSION, 2);\n        ret.set(this._suiteId, 9);\n        ret.set(label, 9 + this._suiteId.byteLength);\n        ret.set(info, 9 + this._suiteId.byteLength + label.byteLength);\n        return ret;\n    }\n    async extract(salt, ikm) {\n        await this._setup();\n        if (salt.byteLength === 0) {\n            salt = new ArrayBuffer(this.hashSize);\n        }\n        if (salt.byteLength !== this.hashSize) {\n            throw new InvalidParamError(\"The salt length must be the same as the hashSize\");\n        }\n        const key = await this._api.importKey(\"raw\", salt, this.algHash, false, [\n            \"sign\",\n        ]);\n        return await this._api.sign(\"HMAC\", key, ikm);\n    }\n    async expand(prk, info, len) {\n        await this._setup();\n        const key = await this._api.importKey(\"raw\", prk, this.algHash, false, [\n            \"sign\",\n        ]);\n        const okm = new ArrayBuffer(len);\n        const p = new Uint8Array(okm);\n        let prev = EMPTY;\n        const mid = new Uint8Array(info);\n        const tail = new Uint8Array(1);\n        if (len > 255 * this.hashSize) {\n            throw new Error(\"Entropy limit reached\");\n        }\n        const tmp = new Uint8Array(this.hashSize + mid.length + 1);\n        for (let i = 1, cur = 0; cur < p.length; i++) {\n            tail[0] = i;\n            tmp.set(prev, 0);\n            tmp.set(mid, prev.length);\n            tmp.set(tail, prev.length + mid.length);\n            prev = new Uint8Array(await this._api.sign(\"HMAC\", key, tmp.slice(0, prev.length + mid.length + 1)));\n            if (p.length - cur >= prev.length) {\n                p.set(prev, cur);\n                cur += prev.length;\n            }\n            else {\n                p.set(prev.slice(0, p.length - cur), cur);\n                cur += p.length - cur;\n            }\n        }\n        return okm;\n    }\n    async extractAndExpand(salt, ikm, info, len) {\n        await this._setup();\n        const baseKey = await this._api.importKey(\"raw\", ikm, \"HKDF\", false, [\"deriveBits\"]);\n        return await this._api.deriveBits({\n            name: \"HKDF\",\n            hash: this.algHash.hash,\n            salt: salt,\n            info: info,\n        }, baseKey, len * 8);\n    }\n    async labeledExtract(salt, label, ikm) {\n        return await this.extract(salt, this.buildLabeledIkm(label, ikm).buffer);\n    }\n    async labeledExpand(prk, label, info, len) {\n        return await this.expand(prk, this.buildLabeledInfo(label, info, len).buffer, len);\n    }\n    _checkInit() {\n        if (this._suiteId === EMPTY) {\n            throw new Error(\"Not initialized. Call init()\");\n        }\n    }\n}\nexport class HkdfSha256Native extends HkdfNative {\n    constructor() {\n        super(...arguments);\n        /** KdfId.HkdfSha256 (0x0001) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha256\n        });\n        /** 32 */\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n        /** The parameters for Web Cryptography API */\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-256\",\n                length: 256,\n            }\n        });\n    }\n}\nexport class HkdfSha384Native extends HkdfNative {\n    constructor() {\n        super(...arguments);\n        /** KdfId.HkdfSha384 (0x0002) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha384\n        });\n        /** 48 */\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 48\n        });\n        /** The parameters for Web Cryptography API */\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-384\",\n                length: 384,\n            }\n        });\n    }\n}\nexport class HkdfSha512Native extends HkdfNative {\n    constructor() {\n        super(...arguments);\n        /** KdfId.HkdfSha512 (0x0003) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha512\n        });\n        /** 64 */\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 64\n        });\n        /** The parameters for Web Cryptography API */\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-512\",\n                length: 512,\n            }\n        });\n    }\n}\n","// The key usages for AEAD.\nexport const AEAD_USAGES = [\"encrypt\", \"decrypt\"];\n","/**\n * This file is based on noble-curves (https://github.com/paulmillr/noble-curves).\n *\n * noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com)\n *\n * The original file is located at:\n * https://github.com/paulmillr/noble-curves/blob/b9d49d2b41d550571a0c5be443ecb62109fa3373/src/abstract/montgomery.ts\n */\n/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes, aInRange, bytesToNumberLE, copyBytes, numberToBytesLE, randomBytesAsync, validateObject, } from \"../utils/noble.js\";\nimport { createKeygen } from \"./curve.js\";\nimport { mod } from \"./modular.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n    validateObject(curve, {\n        adjustScalarBytes: \"function\",\n        powPminus2: \"function\",\n    });\n    return Object.freeze({ ...curve });\n}\nexport function montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n    const is25519 = type === \"x25519\";\n    if (!is25519 && type !== \"x448\")\n        throw new Error(\"invalid type\");\n    const randomBytes_ = rand || randomBytesAsync;\n    const montgomeryBits = is25519 ? 255 : 448;\n    const fieldLen = is25519 ? 32 : 56;\n    const Gu = is25519 ? BigInt(9) : BigInt(5);\n    // RFC 7748 #5:\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n    // (156326 - 2) / 4 = 39081 for curve448/X448\n    // const a = is25519 ? 156326n : 486662n;\n    const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n    // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n    // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n    // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n    const maxAdded = is25519\n        ? BigInt(8) * _2n ** BigInt(251) - _1n\n        : BigInt(4) * _2n ** BigInt(445) - _1n;\n    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n    const modP = (n) => mod(n, P);\n    const GuBytes = encodeU(Gu);\n    function encodeU(u) {\n        return numberToBytesLE(modP(u), fieldLen);\n    }\n    function decodeU(u) {\n        const _u = copyBytes(abytes(u, fieldLen, \"uCoordinate\"));\n        // RFC: When receiving such an array, implementations of X25519\n        // (but not X448) MUST mask the most significant bit in the final byte.\n        if (is25519)\n            _u[31] &= 127; // 0b0111_1111\n        // RFC: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.  The non-canonical\n        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n        // - 1 through 2^448 - 1 for X448.\n        return modP(bytesToNumberLE(_u));\n    }\n    function decodeScalar(scalar) {\n        return bytesToNumberLE(adjustScalarBytes(copyBytes(abytes(scalar, fieldLen, \"scalar\"))));\n    }\n    function scalarMult(scalar, u) {\n        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n        // Some public keys are useless, of low-order. Curve author doesn't think\n        // it needs to be validated, but we do it nonetheless.\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error(\"invalid private or public key received\");\n        return encodeU(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    const getPublicKey = scalarMultBase;\n    const getSharedSecret = scalarMult;\n    // cswap from RFC7748 \"example code\"\n    function cswap(swap, x_2, x_3) {\n        // dummy = mask(swap) AND (x_2 XOR x_3)\n        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n        // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n        return { x_2, x_3 };\n    }\n    /**\n     * Montgomery x-only multiplication ladder.\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(u, scalar) {\n        aInRange(\"u\", u, _0n, P);\n        aInRange(\"scalar\", scalar, minScalar, maxScalar);\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n    }\n    const lengths = {\n        secretKey: fieldLen,\n        publicKey: fieldLen,\n        seed: fieldLen,\n    };\n    const randomSecretKey = async (seed) => {\n        if (seed === undefined) {\n            seed = await randomBytes_(fieldLen);\n        }\n        abytes(seed, lengths.seed, \"seed\");\n        return seed;\n    };\n    const utils = { randomSecretKey };\n    return Object.freeze({\n        keygen: createKeygen(randomSecretKey, getPublicKey),\n        getSharedSecret,\n        getPublicKey,\n        scalarMult,\n        scalarMultBase,\n        utils,\n        GuBytes: GuBytes.slice(),\n        lengths,\n    });\n}\n","import { AEAD_USAGES, AeadId, NativeAlgorithm } from \"@hpke/common\";\nexport class AesGcmContext extends NativeAlgorithm {\n    constructor(key) {\n        super();\n        Object.defineProperty(this, \"_rawKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_key\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        this._rawKey = key;\n    }\n    async seal(iv, data, aad) {\n        await this._setupKey();\n        const alg = {\n            name: \"AES-GCM\",\n            iv: iv,\n            additionalData: aad,\n        };\n        const ct = await this._api.encrypt(alg, this._key, data);\n        return ct;\n    }\n    async open(iv, data, aad) {\n        await this._setupKey();\n        const alg = {\n            name: \"AES-GCM\",\n            iv: iv,\n            additionalData: aad,\n        };\n        const pt = await this._api.decrypt(alg, this._key, data);\n        return pt;\n    }\n    async _setupKey() {\n        if (this._key !== undefined) {\n            return;\n        }\n        await this._setup();\n        const key = await this._importKey(this._rawKey);\n        (new Uint8Array(this._rawKey)).fill(0);\n        this._key = key;\n        return;\n    }\n    async _importKey(key) {\n        return await this._api.importKey(\"raw\", key, { name: \"AES-GCM\" }, true, AEAD_USAGES);\n    }\n}\n/**\n * The AES-128-GCM for HPKE AEAD implementing {@link AeadInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes128Gcm`.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class Aes128Gcm {\n    constructor() {\n        /** AeadId.Aes128Gcm (0x0001) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: AeadId.Aes128Gcm\n        });\n        /** 16 */\n        Object.defineProperty(this, \"keySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 16\n        });\n        /** 12 */\n        Object.defineProperty(this, \"nonceSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 12\n        });\n        /** 16 */\n        Object.defineProperty(this, \"tagSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 16\n        });\n    }\n    createEncryptionContext(key) {\n        return new AesGcmContext(key);\n    }\n}\n/**\n * The AES-256-GCM for HPKE AEAD implementing {@link AeadInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes256Gcm`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes256Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes256Gcm(),\n * });\n * ```\n */\nexport class Aes256Gcm extends Aes128Gcm {\n    constructor() {\n        super(...arguments);\n        /** AeadId.Aes256Gcm (0x0002) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: AeadId.Aes256Gcm\n        });\n        /** 32 */\n        Object.defineProperty(this, \"keySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n        /** 12 */\n        Object.defineProperty(this, \"nonceSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 12\n        });\n        /** 16 */\n        Object.defineProperty(this, \"tagSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 16\n        });\n    }\n}\n","import { NotSupportedError } from \"@hpke/common\";\nexport function emitNotSupported() {\n    return new Promise((_resolve, reject) => {\n        reject(new NotSupportedError(\"Not supported\"));\n    });\n}\n","import { ExportError, INPUT_LENGTH_LIMIT, InvalidParamError, } from \"@hpke/common\";\nimport { emitNotSupported } from \"./utils/emitNotSupported.js\";\n// b\"sec\"\nconst LABEL_SEC = new Uint8Array([115, 101, 99]);\nexport class ExporterContextImpl {\n    constructor(api, kdf, exporterSecret) {\n        Object.defineProperty(this, \"_api\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exporterSecret\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_kdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._api = api;\n        this._kdf = kdf;\n        this.exporterSecret = exporterSecret;\n    }\n    async seal(_data, _aad) {\n        return await emitNotSupported();\n    }\n    async open(_data, _aad) {\n        return await emitNotSupported();\n    }\n    async export(exporterContext, len) {\n        if (exporterContext.byteLength > INPUT_LENGTH_LIMIT) {\n            throw new InvalidParamError(\"Too long exporter context\");\n        }\n        try {\n            return await this._kdf.labeledExpand(this.exporterSecret, LABEL_SEC, new Uint8Array(exporterContext), len);\n        }\n        catch (e) {\n            throw new ExportError(e);\n        }\n    }\n}\nexport class RecipientExporterContextImpl extends ExporterContextImpl {\n}\nexport class SenderExporterContextImpl extends ExporterContextImpl {\n    constructor(api, kdf, exporterSecret, enc) {\n        super(api, kdf, exporterSecret);\n        Object.defineProperty(this, \"enc\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.enc = enc;\n        return;\n    }\n}\n","import { i2Osp, MessageLimitReachedError, xor } from \"@hpke/common\";\nimport { ExporterContextImpl } from \"./exporterContext.js\";\nexport class EncryptionContextImpl extends ExporterContextImpl {\n    constructor(api, kdf, params) {\n        super(api, kdf, params.exporterSecret);\n        // AEAD id.\n        Object.defineProperty(this, \"_aead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The length in bytes of a key for the algorithm.\n        Object.defineProperty(this, \"_nK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The length in bytes of a nonce for the algorithm.\n        Object.defineProperty(this, \"_nN\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The length in bytes of an authentication tag for the algorithm.\n        Object.defineProperty(this, \"_nT\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The end-to-end encryption key information.\n        Object.defineProperty(this, \"_ctx\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (params.key === undefined || params.baseNonce === undefined ||\n            params.seq === undefined) {\n            throw new Error(\"Required parameters are missing\");\n        }\n        this._aead = params.aead;\n        this._nK = this._aead.keySize;\n        this._nN = this._aead.nonceSize;\n        this._nT = this._aead.tagSize;\n        const key = this._aead.createEncryptionContext(params.key);\n        this._ctx = {\n            key: key,\n            baseNonce: params.baseNonce,\n            seq: params.seq,\n        };\n    }\n    computeNonce(k) {\n        const seqBytes = i2Osp(k.seq, k.baseNonce.byteLength);\n        return xor(k.baseNonce, seqBytes).buffer;\n    }\n    incrementSeq(k) {\n        // if (this.seq >= (1 << (8 * this.baseNonce.byteLength)) - 1) {\n        if (k.seq > Number.MAX_SAFE_INTEGER) {\n            throw new MessageLimitReachedError(\"Message limit reached\");\n        }\n        k.seq += 1;\n        return;\n    }\n}\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _Mutex_locked;\nexport class Mutex {\n    constructor() {\n        _Mutex_locked.set(this, Promise.resolve());\n    }\n    async lock() {\n        let releaseLock;\n        const nextLock = new Promise((resolve) => {\n            releaseLock = resolve;\n        });\n        const previousLock = __classPrivateFieldGet(this, _Mutex_locked, \"f\");\n        __classPrivateFieldSet(this, _Mutex_locked, nextLock, \"f\");\n        await previousLock;\n        return releaseLock;\n    }\n}\n_Mutex_locked = new WeakMap();\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _RecipientContextImpl_mutex;\nimport { EMPTY, OpenError } from \"@hpke/common\";\nimport { EncryptionContextImpl } from \"./encryptionContext.js\";\nimport { Mutex } from \"./mutex.js\";\nexport class RecipientContextImpl extends EncryptionContextImpl {\n    constructor() {\n        super(...arguments);\n        _RecipientContextImpl_mutex.set(this, void 0);\n    }\n    async open(data, aad = EMPTY.buffer) {\n        __classPrivateFieldSet(this, _RecipientContextImpl_mutex, __classPrivateFieldGet(this, _RecipientContextImpl_mutex, \"f\") ?? new Mutex(), \"f\");\n        const release = await __classPrivateFieldGet(this, _RecipientContextImpl_mutex, \"f\").lock();\n        let pt;\n        try {\n            pt = await this._ctx.key.open(this.computeNonce(this._ctx), data, aad);\n        }\n        catch (e) {\n            throw new OpenError(e);\n        }\n        finally {\n            release();\n        }\n        this.incrementSeq(this._ctx);\n        return pt;\n    }\n}\n_RecipientContextImpl_mutex = new WeakMap();\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _SenderContextImpl_mutex;\nimport { EMPTY, SealError } from \"@hpke/common\";\nimport { EncryptionContextImpl } from \"./encryptionContext.js\";\nimport { Mutex } from \"./mutex.js\";\nexport class SenderContextImpl extends EncryptionContextImpl {\n    constructor(api, kdf, params, enc) {\n        super(api, kdf, params);\n        Object.defineProperty(this, \"enc\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        _SenderContextImpl_mutex.set(this, void 0);\n        this.enc = enc;\n    }\n    async seal(data, aad = EMPTY.buffer) {\n        __classPrivateFieldSet(this, _SenderContextImpl_mutex, __classPrivateFieldGet(this, _SenderContextImpl_mutex, \"f\") ?? new Mutex(), \"f\");\n        const release = await __classPrivateFieldGet(this, _SenderContextImpl_mutex, \"f\").lock();\n        let ct;\n        try {\n            ct = await this._ctx.key.seal(this.computeNonce(this._ctx), data, aad);\n        }\n        catch (e) {\n            throw new SealError(e);\n        }\n        finally {\n            release();\n        }\n        this.incrementSeq(this._ctx);\n        return ct;\n    }\n}\n_SenderContextImpl_mutex = new WeakMap();\n","import { AeadId, EMPTY, i2Osp, INFO_LENGTH_LIMIT, INPUT_LENGTH_LIMIT, InvalidParamError, MINIMUM_PSK_LENGTH, Mode, NativeAlgorithm, } from \"@hpke/common\";\nimport { RecipientExporterContextImpl, SenderExporterContextImpl, } from \"./exporterContext.js\";\nimport { RecipientContextImpl } from \"./recipientContext.js\";\nimport { SenderContextImpl } from \"./senderContext.js\";\n// b\"base_nonce\"\n// deno-fmt-ignore\nconst LABEL_BASE_NONCE = new Uint8Array([\n    98, 97, 115, 101, 95, 110, 111, 110, 99, 101,\n]);\n// b\"exp\"\nconst LABEL_EXP = new Uint8Array([101, 120, 112]);\n// b\"info_hash\"\n// deno-fmt-ignore\nconst LABEL_INFO_HASH = new Uint8Array([\n    105, 110, 102, 111, 95, 104, 97, 115, 104,\n]);\n// b\"key\"\nconst LABEL_KEY = new Uint8Array([107, 101, 121]);\n// b\"psk_id_hash\"\n// deno-fmt-ignore\nconst LABEL_PSK_ID_HASH = new Uint8Array([\n    112, 115, 107, 95, 105, 100, 95, 104, 97, 115, 104,\n]);\n// b\"secret\"\nconst LABEL_SECRET = new Uint8Array([115, 101, 99, 114, 101, 116]);\n// b\"HPKE\"\n// deno-fmt-ignore\nconst SUITE_ID_HEADER_HPKE = new Uint8Array([\n    72, 80, 75, 69, 0, 0, 0, 0, 0, 0,\n]);\n/**\n * The Hybrid Public Key Encryption (HPKE) ciphersuite,\n * which is implemented using only\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n *\n * This is the super class of {@link CipherSuite} and the same as\n * {@link https://jsr.io/@hpke/core/doc/~/CipherSuite | @hpke/core#CipherSuite} as follows:\n * which supports only the ciphersuites that can be implemented on the native\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n * Therefore, the following cryptographic algorithms are not supported for now:\n *   - DHKEM(X25519, HKDF-SHA256)\n *   - DHKEM(X448, HKDF-SHA512)\n *   - ChaCha20Poly1305\n *\n * In addtion, the HKDF functions contained in this class can only derive\n * keys of the same length as the `hashSize`.\n *\n * If you want to use the unsupported cryptographic algorithms\n * above or derive keys longer than the `hashSize`,\n * please use {@link CipherSuite}.\n *\n * This class provides following functions:\n *\n * - Creates encryption contexts both for senders and recipients.\n *   - {@link createSenderContext}\n *   - {@link createRecipientContext}\n * - Provides single-shot encryption API.\n *   - {@link seal}\n *   - {@link open}\n *\n * The calling of the constructor of this class is the starting\n * point for HPKE operations for both senders and recipients.\n *\n * @example Use only ciphersuites supported by Web Cryptography API.\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n *   CipherSuite,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n *\n * @example Use a ciphersuite which is currently not supported by Web Cryptography API.\n *\n * ```ts\n * import { Aes128Gcm, HkdfSha256, CipherSuite } from \"@hpke/core\";\n * // Use an extension module.\n * import { DhkemX25519HkdfSha256 } from \"@hpke/dhkem-x25519\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemX25519HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class CipherSuiteNative extends NativeAlgorithm {\n    /**\n     * @param params A set of parameters for building a cipher suite.\n     *\n     * If the error occurred, throws {@link InvalidParamError}.\n     *\n     * @throws {@link InvalidParamError}\n     */\n    constructor(params) {\n        super();\n        Object.defineProperty(this, \"_kem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_kdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_aead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_suiteId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // KEM\n        if (typeof params.kem === \"number\") {\n            throw new InvalidParamError(\"KemId cannot be used\");\n        }\n        this._kem = params.kem;\n        // KDF\n        if (typeof params.kdf === \"number\") {\n            throw new InvalidParamError(\"KdfId cannot be used\");\n        }\n        this._kdf = params.kdf;\n        // AEAD\n        if (typeof params.aead === \"number\") {\n            throw new InvalidParamError(\"AeadId cannot be used\");\n        }\n        this._aead = params.aead;\n        this._suiteId = new Uint8Array(SUITE_ID_HEADER_HPKE);\n        this._suiteId.set(i2Osp(this._kem.id, 2), 4);\n        this._suiteId.set(i2Osp(this._kdf.id, 2), 6);\n        this._suiteId.set(i2Osp(this._aead.id, 2), 8);\n        this._kdf.init(this._suiteId);\n    }\n    /**\n     * Gets the KEM context of the ciphersuite.\n     */\n    get kem() {\n        return this._kem;\n    }\n    /**\n     * Gets the KDF context of the ciphersuite.\n     */\n    get kdf() {\n        return this._kdf;\n    }\n    /**\n     * Gets the AEAD context of the ciphersuite.\n     */\n    get aead() {\n        return this._aead;\n    }\n    /**\n     * Creates an encryption context for a sender.\n     *\n     * If the error occurred, throws {@link DecapError} | {@link ValidationError}.\n     *\n     * @param params A set of parameters for the sender encryption context.\n     * @returns A sender encryption context.\n     * @throws {@link EncapError}, {@link ValidationError}\n     */\n    async createSenderContext(params) {\n        this._validateInputLength(params);\n        await this._setup();\n        const dh = await this._kem.encap(params);\n        let mode;\n        if (params.psk !== undefined) {\n            mode = params.senderKey !== undefined ? Mode.AuthPsk : Mode.Psk;\n        }\n        else {\n            mode = params.senderKey !== undefined ? Mode.Auth : Mode.Base;\n        }\n        return await this._keyScheduleS(mode, dh.sharedSecret, dh.enc, params);\n    }\n    /**\n     * Creates an encryption context for a recipient.\n     *\n     * If the error occurred, throws {@link DecapError}\n     * | {@link DeserializeError} | {@link ValidationError}.\n     *\n     * @param params A set of parameters for the recipient encryption context.\n     * @returns A recipient encryption context.\n     * @throws {@link DecapError}, {@link DeserializeError}, {@link ValidationError}\n     */\n    async createRecipientContext(params) {\n        this._validateInputLength(params);\n        await this._setup();\n        const sharedSecret = await this._kem.decap(params);\n        let mode;\n        if (params.psk !== undefined) {\n            mode = params.senderPublicKey !== undefined ? Mode.AuthPsk : Mode.Psk;\n        }\n        else {\n            mode = params.senderPublicKey !== undefined ? Mode.Auth : Mode.Base;\n        }\n        return await this._keyScheduleR(mode, sharedSecret, params);\n    }\n    /**\n     * Encrypts a message to a recipient.\n     *\n     * If the error occurred, throws `EncapError` | `MessageLimitReachedError` | `SealError` | `ValidationError`.\n     *\n     * @param params A set of parameters for building a sender encryption context.\n     * @param pt A plain text as bytes to be encrypted.\n     * @param aad Additional authenticated data as bytes fed by an application.\n     * @returns A cipher text and an encapsulated key as bytes.\n     * @throws {@link EncapError}, {@link MessageLimitReachedError}, {@link SealError}, {@link ValidationError}\n     */\n    async seal(params, pt, aad = EMPTY.buffer) {\n        const ctx = await this.createSenderContext(params);\n        return {\n            ct: await ctx.seal(pt, aad),\n            enc: ctx.enc,\n        };\n    }\n    /**\n     * Decrypts a message from a sender.\n     *\n     * If the error occurred, throws `DecapError` | `DeserializeError` | `OpenError` | `ValidationError`.\n     *\n     * @param params A set of parameters for building a recipient encryption context.\n     * @param ct An encrypted text as bytes to be decrypted.\n     * @param aad Additional authenticated data as bytes fed by an application.\n     * @returns A decrypted plain text as bytes.\n     * @throws {@link DecapError}, {@link DeserializeError}, {@link OpenError}, {@link ValidationError}\n     */\n    async open(params, ct, aad = EMPTY.buffer) {\n        const ctx = await this.createRecipientContext(params);\n        return await ctx.open(ct, aad);\n    }\n    // private verifyPskInputs(mode: Mode, params: KeyScheduleParams) {\n    //   const gotPsk = (params.psk !== undefined);\n    //   const gotPskId = (params.psk !== undefined && params.psk.id.byteLength > 0);\n    //   if (gotPsk !== gotPskId) {\n    //     throw new Error('Inconsistent PSK inputs');\n    //   }\n    //   if (gotPsk && (mode === Mode.Base || mode === Mode.Auth)) {\n    //     throw new Error('PSK input provided when not needed');\n    //   }\n    //   if (!gotPsk && (mode === Mode.Psk || mode === Mode.AuthPsk)) {\n    //     throw new Error('Missing required PSK input');\n    //   }\n    //   return;\n    // }\n    async _keySchedule(mode, sharedSecret, params) {\n        // Currently, there is no point in executing this function\n        // because this hpke library does not allow users to explicitly specify the mode.\n        //\n        // this.verifyPskInputs(mode, params);\n        const pskId = params.psk === undefined\n            ? EMPTY\n            : new Uint8Array(params.psk.id);\n        const pskIdHash = await this._kdf.labeledExtract(EMPTY.buffer, LABEL_PSK_ID_HASH, pskId);\n        const info = params.info === undefined\n            ? EMPTY\n            : new Uint8Array(params.info);\n        const infoHash = await this._kdf.labeledExtract(EMPTY.buffer, LABEL_INFO_HASH, info);\n        const keyScheduleContext = new Uint8Array(1 + pskIdHash.byteLength + infoHash.byteLength);\n        keyScheduleContext.set(new Uint8Array([mode]), 0);\n        keyScheduleContext.set(new Uint8Array(pskIdHash), 1);\n        keyScheduleContext.set(new Uint8Array(infoHash), 1 + pskIdHash.byteLength);\n        const psk = params.psk === undefined\n            ? EMPTY\n            : new Uint8Array(params.psk.key);\n        const ikm = this._kdf.buildLabeledIkm(LABEL_SECRET, psk)\n            .buffer;\n        const exporterSecretInfo = this._kdf.buildLabeledInfo(LABEL_EXP, keyScheduleContext, this._kdf.hashSize).buffer;\n        const exporterSecret = await this._kdf.extractAndExpand(sharedSecret, ikm, exporterSecretInfo, this._kdf.hashSize);\n        if (this._aead.id === AeadId.ExportOnly) {\n            return { aead: this._aead, exporterSecret: exporterSecret };\n        }\n        const keyInfo = this._kdf.buildLabeledInfo(LABEL_KEY, keyScheduleContext, this._aead.keySize).buffer;\n        const key = await this._kdf.extractAndExpand(sharedSecret, ikm, keyInfo, this._aead.keySize);\n        const baseNonceInfo = this._kdf.buildLabeledInfo(LABEL_BASE_NONCE, keyScheduleContext, this._aead.nonceSize).buffer;\n        const baseNonce = await this._kdf.extractAndExpand(sharedSecret, ikm, baseNonceInfo, this._aead.nonceSize);\n        return {\n            aead: this._aead,\n            exporterSecret: exporterSecret,\n            key: key,\n            baseNonce: new Uint8Array(baseNonce),\n            seq: 0,\n        };\n    }\n    async _keyScheduleS(mode, sharedSecret, enc, params) {\n        const res = await this._keySchedule(mode, sharedSecret, params);\n        if (res.key === undefined) {\n            return new SenderExporterContextImpl(this._api, this._kdf, res.exporterSecret, enc);\n        }\n        return new SenderContextImpl(this._api, this._kdf, res, enc);\n    }\n    async _keyScheduleR(mode, sharedSecret, params) {\n        const res = await this._keySchedule(mode, sharedSecret, params);\n        if (res.key === undefined) {\n            return new RecipientExporterContextImpl(this._api, this._kdf, res.exporterSecret);\n        }\n        return new RecipientContextImpl(this._api, this._kdf, res);\n    }\n    _validateInputLength(params) {\n        if (params.info !== undefined &&\n            params.info.byteLength > INFO_LENGTH_LIMIT) {\n            throw new InvalidParamError(\"Too long info\");\n        }\n        if (params.psk !== undefined) {\n            if (params.psk.key.byteLength < MINIMUM_PSK_LENGTH) {\n                throw new InvalidParamError(`PSK must have at least ${MINIMUM_PSK_LENGTH} bytes`);\n            }\n            if (params.psk.key.byteLength > INPUT_LENGTH_LIMIT) {\n                throw new InvalidParamError(\"Too long psk.key\");\n            }\n            if (params.psk.id.byteLength > INPUT_LENGTH_LIMIT) {\n                throw new InvalidParamError(\"Too long psk.id\");\n            }\n        }\n        return;\n    }\n}\n","import { Dhkem, Ec, HkdfSha256Native, HkdfSha384Native, HkdfSha512Native, KemId, } from \"@hpke/common\";\nexport class DhkemP256HkdfSha256Native extends Dhkem {\n    constructor() {\n        const kdf = new HkdfSha256Native();\n        const prim = new Ec(KemId.DhkemP256HkdfSha256, kdf);\n        super(KemId.DhkemP256HkdfSha256, prim, kdf);\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KemId.DhkemP256HkdfSha256\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 65\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 65\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n    }\n}\nexport class DhkemP384HkdfSha384Native extends Dhkem {\n    constructor() {\n        const kdf = new HkdfSha384Native();\n        const prim = new Ec(KemId.DhkemP384HkdfSha384, kdf);\n        super(KemId.DhkemP384HkdfSha384, prim, kdf);\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KemId.DhkemP384HkdfSha384\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 48\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 97\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 97\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 48\n        });\n    }\n}\nexport class DhkemP521HkdfSha512Native extends Dhkem {\n    constructor() {\n        const kdf = new HkdfSha512Native();\n        const prim = new Ec(KemId.DhkemP521HkdfSha512, kdf);\n        super(KemId.DhkemP521HkdfSha512, prim, kdf);\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KemId.DhkemP521HkdfSha512\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 64\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 133\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 133\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 64\n        });\n    }\n}\n","import { HkdfSha256Native, HkdfSha384Native, HkdfSha512Native, } from \"@hpke/common\";\nimport { CipherSuiteNative } from \"./cipherSuiteNative.js\";\nimport { DhkemP256HkdfSha256Native, DhkemP384HkdfSha384Native, DhkemP521HkdfSha512Native, } from \"./kems/dhkemNative.js\";\n/**\n * The Hybrid Public Key Encryption (HPKE) ciphersuite,\n * which is implemented using only\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n *\n * This class is the same as\n * {@link https://jsr.io/@hpke/core/doc/~/CipherSuiteNative | @hpke/core#CipherSuiteNative} as follows:\n * which supports only the ciphersuites that can be implemented on the native\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n * Therefore, the following cryptographic algorithms are not supported for now:\n * - `DHKEM(X25519, HKDF-SHA256)`\n * - `DHKEM(X448, HKDF-SHA512)`\n * - `ChaCha20Poly1305`\n *\n * In addtion, the HKDF functions contained in this `CipherSuiteNative`\n * class can only derive keys of the same length as the `hashSize`.\n *\n * If you want to use the unsupported cryptographic algorithms\n * above or derive keys longer than the `hashSize`,\n * please use {@link https://jsr.io/@hpke/hpke-js/doc/~/CipherSuite | hpke-js#CipherSuite}.\n *\n * This class provides following functions:\n *\n * - Creates encryption contexts both for senders and recipients.\n *     - {@link createSenderContext}\n *     - {@link createRecipientContext}\n * - Provides single-shot encryption API.\n *     - {@link seal}\n *     - {@link open}\n *\n * The calling of the constructor of this class is the starting\n * point for HPKE operations for both senders and recipients.\n *\n * @example Use only ciphersuites supported by Web Cryptography API.\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n *   CipherSuite,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n *\n * @example Use a ciphersuite which is currently not supported by Web Cryptography API.\n *\n * ```ts\n * import { Aes128Gcm, HkdfSha256, CipherSuite } from \"@hpke/core\";\n * import { DhkemX25519HkdfSha256 } from \"@hpke/dhkem-x25519\";\n * const suite = new CipherSuite({\n *   kem: new DhkemX25519HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class CipherSuite extends CipherSuiteNative {\n}\n/**\n * The DHKEM(P-256, HKDF-SHA256) for HPKE KEM implementing {@link KemInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP256HkdfSha256`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class DhkemP256HkdfSha256 extends DhkemP256HkdfSha256Native {\n}\n/**\n * The DHKEM(P-384, HKDF-SHA384) for HPKE KEM implementing {@link KemInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP384HkdfSha384`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP384HkdfSha384,\n *   HkdfSha384,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP384HkdfSha384(),\n *   kdf: new HkdfSha384(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class DhkemP384HkdfSha384 extends DhkemP384HkdfSha384Native {\n}\n/**\n * The DHKEM(P-521, HKDF-SHA512) for HPKE KEM implementing {@link KemInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP521HkdfSha512`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes256Gcm,\n *   CipherSuite,\n *   DhkemP521HkdfSha512,\n *   HkdfSha512,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP521HkdfSha512(),\n *   kdf: new HkdfSha512(),\n *   aead: new Aes256Gcm(),\n * });\n * ```\n */\nexport class DhkemP521HkdfSha512 extends DhkemP521HkdfSha512Native {\n}\n/**\n * The HKDF-SHA256 for HPKE KDF implementing {@link KdfInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha256`.\n *\n * The KDF class can only derive keys of the same length as the `hashSize`.\n * If you want to derive keys longer than the `hashSize`,\n * please use {@link https://jsr.io/@hpke/hpke-js/doc/~/CipherSuite | hpke-js#CipherSuite}.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class HkdfSha256 extends HkdfSha256Native {\n}\n/**\n * The HKDF-SHA384 for HPKE KDF implementing {@link KdfInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha384`.\n *\n * The KDF class can only derive keys of the same length as the `hashSize`.\n * If you want to derive keys longer than the `hashSize`,\n * please use {@link https://jsr.io/@hpke/hpke-js/doc/~/CipherSuite | hpke-js#CipherSuite}.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP384HkdfSha384,\n *   HkdfSha384,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP384HkdfSha384(),\n *   kdf: new HkdfSha384(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class HkdfSha384 extends HkdfSha384Native {\n}\n/**\n * The HKDF-SHA512 for HPKE KDF implementing {@link KdfInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha512`.\n *\n * The KDF class can only derive keys of the same length as the `hashSize`.\n * If you want to derive keys longer than the `hashSize`,\n * please use {@link https://jsr.io/@hpke/hpke-js/doc/~/CipherSuite | hpke-js#CipherSuite}.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes256Gcm,\n *   CipherSuite,\n *   DhkemP521HkdfSha512,\n *   HkdfSha512,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP521HkdfSha512(),\n *   kdf: new HkdfSha512(),\n *   aead: new Aes256Gcm(),\n * });\n * ```\n */\nexport class HkdfSha512 extends HkdfSha512Native {\n}\n","import { base64UrlToBytes, DeriveKeyPairError, DeserializeError, EMPTY, KEM_USAGES, LABEL_DKP_PRK, LABEL_SK, NativeAlgorithm, NotSupportedError, SerializeError, } from \"@hpke/common\";\nconst ALG_NAME = \"X25519\";\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_X25519 = new Uint8Array([\n    0x30, 0x2e, 0x02, 0x01, 0x00, 0x30, 0x05, 0x06,\n    0x03, 0x2b, 0x65, 0x6e, 0x04, 0x22, 0x04, 0x20,\n]);\nexport class X25519 extends NativeAlgorithm {\n    constructor(hkdf) {\n        super();\n        Object.defineProperty(this, \"_hkdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_alg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nPk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nSk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nDh\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pkcs8AlgId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._alg = { name: ALG_NAME };\n        this._hkdf = hkdf;\n        this._nPk = 32;\n        this._nSk = 32;\n        this._nDh = 32;\n        this._pkcs8AlgId = PKCS8_ALG_ID_X25519;\n    }\n    async serializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._api.exportKey(\"raw\", key);\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, true);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async serializePrivateKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            if (!(\"d\" in jwk)) {\n                throw new Error(\"Not private key\");\n            }\n            return base64UrlToBytes(jwk[\"d\"]).buffer;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePrivateKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, false);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async importKey(format, key, isPublic) {\n        await this._setup();\n        try {\n            if (format === \"raw\") {\n                return await this._importRawKey(key, isPublic);\n            }\n            // jwk\n            if (key instanceof ArrayBuffer) {\n                throw new Error(\"Invalid jwk key format\");\n            }\n            return await this._importJWK(key, isPublic);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async generateKeyPair() {\n        await this._setup();\n        try {\n            return await this._api.generateKey(ALG_NAME, true, KEM_USAGES);\n        }\n        catch (e) {\n            throw new NotSupportedError(e);\n        }\n    }\n    async deriveKeyPair(ikm) {\n        await this._setup();\n        try {\n            const dkpPrk = await this._hkdf.labeledExtract(EMPTY.buffer, LABEL_DKP_PRK, new Uint8Array(ikm));\n            const rawSk = await this._hkdf.labeledExpand(dkpPrk, LABEL_SK, EMPTY, this._nSk);\n            const rawSkBytes = new Uint8Array(rawSk);\n            const sk = await this._deserializePkcs8Key(rawSkBytes);\n            rawSkBytes.fill(0);\n            return {\n                privateKey: sk,\n                publicKey: await this.derivePublicKey(sk),\n            };\n        }\n        catch (e) {\n            throw new DeriveKeyPairError(e);\n        }\n    }\n    async derivePublicKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            delete jwk[\"d\"];\n            delete jwk[\"key_ops\"];\n            return await this._api.importKey(\"jwk\", jwk, this._alg, true, []);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async dh(sk, pk) {\n        await this._setup();\n        try {\n            const bits = await this._api.deriveBits({\n                name: ALG_NAME,\n                public: pk,\n            }, sk, this._nDh * 8);\n            return bits;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async _importRawKey(key, isPublic) {\n        if (isPublic && key.byteLength !== this._nPk) {\n            throw new Error(\"Invalid public key for the ciphersuite\");\n        }\n        if (!isPublic && key.byteLength !== this._nSk) {\n            throw new Error(\"Invalid private key for the ciphersuite\");\n        }\n        if (isPublic) {\n            return await this._api.importKey(\"raw\", key, this._alg, true, []);\n        }\n        return await this._deserializePkcs8Key(new Uint8Array(key));\n    }\n    async _importJWK(key, isPublic) {\n        if (typeof key.kty === \"undefined\" || key.kty !== \"OKP\") {\n            throw new Error(`Invalid kty: ${key.crv}`);\n        }\n        if (typeof key.crv === \"undefined\" || key.crv !== ALG_NAME) {\n            throw new Error(`Invalid crv: ${key.crv}`);\n        }\n        if (isPublic) {\n            if (typeof key.d !== \"undefined\") {\n                throw new Error(\"Invalid key: `d` should not be set\");\n            }\n            return await this._api.importKey(\"jwk\", key, this._alg, true, []);\n        }\n        if (typeof key.d === \"undefined\") {\n            throw new Error(\"Invalid key: `d` not found\");\n        }\n        return await this._api.importKey(\"jwk\", key, this._alg, true, KEM_USAGES);\n    }\n    async _deserializePkcs8Key(k) {\n        const pkcs8Key = new Uint8Array(this._pkcs8AlgId.length + k.length);\n        pkcs8Key.set(this._pkcs8AlgId, 0);\n        pkcs8Key.set(k, this._pkcs8AlgId.length);\n        return await this._api.importKey(\"pkcs8\", pkcs8Key, this._alg, true, KEM_USAGES);\n    }\n}\n","import { base64UrlToBytes, DeriveKeyPairError, DeserializeError, EMPTY, KEM_USAGES, LABEL_DKP_PRK, LABEL_SK, NativeAlgorithm, NotSupportedError, SerializeError, } from \"@hpke/common\";\nconst ALG_NAME = \"X448\";\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_X448 = new Uint8Array([\n    0x30, 0x46, 0x02, 0x01, 0x00, 0x30, 0x05, 0x06,\n    0x03, 0x2b, 0x65, 0x6f, 0x04, 0x3a, 0x04, 0x38,\n]);\nexport class X448 extends NativeAlgorithm {\n    constructor(hkdf) {\n        super();\n        Object.defineProperty(this, \"_hkdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_alg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nPk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nSk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nDh\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pkcs8AlgId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._alg = { name: ALG_NAME };\n        this._hkdf = hkdf;\n        this._nPk = 56;\n        this._nSk = 56;\n        this._nDh = 56;\n        this._pkcs8AlgId = PKCS8_ALG_ID_X448;\n    }\n    async serializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._api.exportKey(\"raw\", key);\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, true);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async serializePrivateKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            if (!(\"d\" in jwk)) {\n                throw new Error(\"Not private key\");\n            }\n            return base64UrlToBytes(jwk[\"d\"]).buffer;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePrivateKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, false);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async importKey(format, key, isPublic) {\n        await this._setup();\n        try {\n            if (format === \"raw\") {\n                return await this._importRawKey(key, isPublic);\n            }\n            // jwk\n            if (key instanceof ArrayBuffer) {\n                throw new Error(\"Invalid jwk key format\");\n            }\n            return await this._importJWK(key, isPublic);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async generateKeyPair() {\n        await this._setup();\n        try {\n            return await this._api.generateKey(ALG_NAME, true, KEM_USAGES);\n        }\n        catch (e) {\n            throw new NotSupportedError(e);\n        }\n    }\n    async deriveKeyPair(ikm) {\n        await this._setup();\n        try {\n            const dkpPrk = await this._hkdf.labeledExtract(EMPTY.buffer, LABEL_DKP_PRK, new Uint8Array(ikm));\n            const rawSk = await this._hkdf.labeledExpand(dkpPrk, LABEL_SK, EMPTY, this._nSk);\n            const rawSkBytes = new Uint8Array(rawSk);\n            const sk = await this._deserializePkcs8Key(rawSkBytes);\n            rawSkBytes.fill(0);\n            return {\n                privateKey: sk,\n                publicKey: await this.derivePublicKey(sk),\n            };\n        }\n        catch (e) {\n            throw new DeriveKeyPairError(e);\n        }\n    }\n    async derivePublicKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            delete jwk[\"d\"];\n            delete jwk[\"key_ops\"];\n            return await this._api.importKey(\"jwk\", jwk, this._alg, true, []);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async dh(sk, pk) {\n        await this._setup();\n        try {\n            const bits = await this._api.deriveBits({\n                name: ALG_NAME,\n                public: pk,\n            }, sk, this._nDh * 8);\n            return bits;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async _importRawKey(key, isPublic) {\n        if (isPublic && key.byteLength !== this._nPk) {\n            throw new Error(\"Invalid public key for the ciphersuite\");\n        }\n        if (!isPublic && key.byteLength !== this._nSk) {\n            throw new Error(\"Invalid private key for the ciphersuite\");\n        }\n        if (isPublic) {\n            return await this._api.importKey(\"raw\", key, this._alg, true, []);\n        }\n        return await this._deserializePkcs8Key(new Uint8Array(key));\n    }\n    async _importJWK(key, isPublic) {\n        if (typeof key.kty === \"undefined\" || key.kty !== \"OKP\") {\n            throw new Error(`Invalid kty: ${key.crv}`);\n        }\n        if (typeof key.crv === \"undefined\" || key.crv !== ALG_NAME) {\n            throw new Error(`Invalid crv: ${key.crv}`);\n        }\n        if (isPublic) {\n            if (typeof key.d !== \"undefined\") {\n                throw new Error(\"Invalid key: `d` should not be set\");\n            }\n            return await this._api.importKey(\"jwk\", key, this._alg, true, []);\n        }\n        if (typeof key.d === \"undefined\") {\n            throw new Error(\"Invalid key: `d` not found\");\n        }\n        return await this._api.importKey(\"jwk\", key, this._alg, true, KEM_USAGES);\n    }\n    async _deserializePkcs8Key(k) {\n        const pkcs8Key = new Uint8Array(this._pkcs8AlgId.length + k.length);\n        pkcs8Key.set(this._pkcs8AlgId, 0);\n        pkcs8Key.set(k, this._pkcs8AlgId.length);\n        return await this._api.importKey(\"pkcs8\", pkcs8Key, this._alg, true, KEM_USAGES);\n    }\n}\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n    const x = ALPHABET.charAt(z);\n    ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            return 'Invalid prefix (' + prefix + ')';\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            return 'Excess padding';\n        if ((value << (outBits - bits)) & maxV)\n            return 'Non-zero padding';\n    }\n    return result;\n}\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n}\nfunction fromWords(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n    throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n    let ENCODING_CONST;\n    if (encoding === 'bech32') {\n        ENCODING_CONST = 1;\n    }\n    else {\n        ENCODING_CONST = 0x2bc830a3;\n    }\n    function encode(prefix, words, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (prefix.length + 7 + words.length > LIMIT)\n            throw new TypeError('Exceeds length limit');\n        prefix = prefix.toLowerCase();\n        // determine chk mod\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            throw new Error(chk);\n        let result = prefix + '1';\n        for (let i = 0; i < words.length; ++i) {\n            const x = words[i];\n            if (x >> 5 !== 0)\n                throw new Error('Non 5-bit word');\n            chk = polymodStep(chk) ^ x;\n            result += ALPHABET.charAt(x);\n        }\n        for (let i = 0; i < 6; ++i) {\n            chk = polymodStep(chk);\n        }\n        chk ^= ENCODING_CONST;\n        for (let i = 0; i < 6; ++i) {\n            const v = (chk >> ((5 - i) * 5)) & 0x1f;\n            result += ALPHABET.charAt(v);\n        }\n        return result;\n    }\n    function __decode(str, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (str.length < 8)\n            return str + ' too short';\n        if (str.length > LIMIT)\n            return 'Exceeds length limit';\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        const uppered = str.toUpperCase();\n        if (str !== lowered && str !== uppered)\n            return 'Mixed-case string ' + str;\n        str = lowered;\n        const split = str.lastIndexOf('1');\n        if (split === -1)\n            return 'No separator character for ' + str;\n        if (split === 0)\n            return 'Missing prefix for ' + str;\n        const prefix = str.slice(0, split);\n        const wordChars = str.slice(split + 1);\n        if (wordChars.length < 6)\n            return 'Data too short';\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            return chk;\n        const words = [];\n        for (let i = 0; i < wordChars.length; ++i) {\n            const c = wordChars.charAt(i);\n            const v = ALPHABET_MAP[c];\n            if (v === undefined)\n                return 'Unknown character ' + c;\n            chk = polymodStep(chk) ^ v;\n            // not in the checksum?\n            if (i + 6 >= wordChars.length)\n                continue;\n            words.push(v);\n        }\n        if (chk !== ENCODING_CONST)\n            return 'Invalid checksum for ' + str;\n        return { prefix, words };\n    }\n    function decodeUnsafe(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n    }\n    function decode(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n        throw new Error(res);\n    }\n    return {\n        decodeUnsafe,\n        decode,\n        encode,\n        toWords,\n        fromWordsUnsafe,\n        fromWords,\n    };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');\n"],"names":["HpkeError","Error","constructor","e","message","super","this","name","EncapError","DecapError","ExportError","SealError","OpenError","MessageLimitReachedError","DeriveKeyPairError","dntGlobalThis","baseObj","globalThis","extObj","Proxy","get","_target","prop","_receiver","set","value","deleteProperty","success","ownKeys","baseKeys","Reflect","extKeys","extKeysSet","Set","filter","k","has","defineProperty","desc","getOwnPropertyDescriptor","NativeAlgorithm","Object","enumerable","configurable","writable","undefined","_setup","_api","async","crypto","subtle","webcrypto","loadSubtleCrypto","INPUT_LENGTH_LIMIT","Uint8Array","x","privateKey","publicKey","n","w","ret","i","a","b","length","LABEL_EAE_PRK","LABEL_SHARED_SECRET","Dhkem","id","prim","kdf","_prim","_kdf","suiteId","init","serializePublicKey","key","deserializePublicKey","serializePrivateKey","deserializePrivateKey","importKey","format","isPublic","generateKeyPair","deriveKeyPair","ikm","byteLength","encap","params","ke","ekm","enc","pkrm","recipientPublicKey","dh","kemContext","senderKey","sks","pks","derivePublicKey","pksm","c","concat3","sharedSecret","_generateSharedSecret","decap","pke","skr","recipientKey","pkr","senderPublicKey","labeledIkm","buildLabeledIkm","labeledInfo","buildLabeledInfo","secretSize","extractAndExpand","buffer","KEM_USAGES","Bignum","size","_num","val","reset","fill","src","isZero","lessThan","v","LABEL_CANDIDATE","ORDER_P_256","ORDER_P_384","ORDER_P_521","PKCS8_ALG_ID_P_256","PKCS8_ALG_ID_P_384","PKCS8_ALG_ID_P_521","Ec","kem","hkdf","_hkdf","_alg","namedCurve","_nPk","_nSk","_nDh","_order","_bitmask","_pkcs8AlgId","exportKey","_importRawKey","jwk","base64","replace","byteString","atob","charCodeAt","base64UrlToBytes","ArrayBuffer","_importJWK","generateKey","dkpPrk","labeledExtract","bn","counter","bytes","labeledExpand","sk","_deserializePkcs8Key","pk","deriveBits","public","crv","d","pkcs8Key","HPKE_VERSION","HkdfNative","hash","_suiteId","label","_checkInit","info","len","extract","salt","hashSize","algHash","sign","expand","prk","okm","p","prev","mid","tail","tmp","cur","slice","baseKey","HkdfSha256Native","arguments","AEAD_USAGES","BigInt","AesGcmContext","_rawKey","seal","iv","data","aad","_setupKey","alg","additionalData","encrypt","_key","open","decrypt","_importKey","Aes128Gcm","createEncryptionContext","Aes256Gcm","emitNotSupported","Promise","_resolve","reject","LABEL_SEC","ExporterContextImpl","api","exporterSecret","_data","_aad","exporterContext","RecipientExporterContextImpl","SenderExporterContextImpl","EncryptionContextImpl","baseNonce","seq","_aead","aead","_nK","keySize","_nN","nonceSize","_nT","tagSize","_ctx","computeNonce","seqBytes","buf","xor","incrementSeq","Number","MAX_SAFE_INTEGER","_Mutex_locked","Mutex","resolve","lock","releaseLock","nextLock","previousLock","receiver","state","kind","f","TypeError","call","__classPrivateFieldGet","__classPrivateFieldSet","WeakMap","_RecipientContextImpl_mutex","RecipientContextImpl","release","pt","_SenderContextImpl_mutex","SenderContextImpl","ct","LABEL_BASE_NONCE","LABEL_EXP","LABEL_INFO_HASH","LABEL_KEY","LABEL_PSK_ID_HASH","LABEL_SECRET","SUITE_ID_HEADER_HPKE","CipherSuiteNative","_kem","createSenderContext","_validateInputLength","mode","psk","_keyScheduleS","createRecipientContext","_keyScheduleR","ctx","_keySchedule","pskId","pskIdHash","infoHash","keyScheduleContext","exporterSecretInfo","keyInfo","baseNonceInfo","res","DhkemP256HkdfSha256Native","CipherSuite","DhkemP256HkdfSha256","HkdfSha256","exports","ALPHABET","ALPHABET_MAP","z","charAt","polymodStep","pre","prefixChk","prefix","chk","convert","inBits","outBits","pad","bits","maxV","result","push","toWords","fromWordsUnsafe","words","Array","isArray","fromWords","getLibraryFromEncoding","encoding","ENCODING_CONST","__decode","str","LIMIT","lowered","toLowerCase","uppered","toUpperCase","split","lastIndexOf","wordChars","decodeUnsafe","decode","encode"],"sourceRoot":""}