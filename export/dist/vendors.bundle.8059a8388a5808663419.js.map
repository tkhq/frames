{"version":3,"file":"vendors.bundle.8059a8388a5808663419.js","mappings":"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","sources":["webpack://export-tests/./node_modules/@hpke/common/esm/src/errors.js","webpack://export-tests/./node_modules/@hpke/common/esm/_dnt.shims.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/algorithm.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/identifiers.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/consts.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/interfaces/kemInterface.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/utils/misc.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/kems/dhkem.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/interfaces/dhkemPrimitives.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/utils/bignum.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/kems/dhkemPrimitives/ec.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/kdfs/hkdf.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/interfaces/aeadEncryptionContext.js","webpack://export-tests/./node_modules/@hpke/common/esm/src/curve/montgomery.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/aeads/aesGcm.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/utils/emitNotSupported.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/exporterContext.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/encryptionContext.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/mutex.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/recipientContext.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/senderContext.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/cipherSuiteNative.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/kems/dhkemNative.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/native.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/x25519.js","webpack://export-tests/./node_modules/@hpke/core/esm/src/kems/dhkemPrimitives/x448.js","webpack://export-tests/./node_modules/bech32/dist/index.js","webpack://export-tests/./node_modules/@noble/hashes/index.js","webpack://export-tests/./node_modules/@noble/ed25519/index.js"],"sourcesContent":["/**\n * The base error class of hpke-js.\n * @group Errors\n */\nexport class HpkeError extends Error {\n    constructor(e) {\n        let message;\n        if (e instanceof Error) {\n            message = e.message;\n        }\n        else if (typeof e === \"string\") {\n            message = e;\n        }\n        else {\n            message = \"\";\n        }\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\n/**\n * Invalid parameter.\n * @group Errors\n */\nexport class InvalidParamError extends HpkeError {\n}\n/**\n * KEM input or output validation failure.\n * @group Errors\n */\nexport class ValidationError extends HpkeError {\n}\n/**\n * Public or private key serialization failure.\n * @group Errors\n */\nexport class SerializeError extends HpkeError {\n}\n/**\n * Public or private key deserialization failure.\n * @group Errors\n */\nexport class DeserializeError extends HpkeError {\n}\n/**\n * encap() failure.\n * @group Errors\n */\nexport class EncapError extends HpkeError {\n}\n/**\n * decap() failure.\n * @group Errors\n */\nexport class DecapError extends HpkeError {\n}\n/**\n * Secret export failure.\n * @group Errors\n */\nexport class ExportError extends HpkeError {\n}\n/**\n * seal() failure.\n * @group Errors\n */\nexport class SealError extends HpkeError {\n}\n/**\n * open() failure.\n * @group Errors\n */\nexport class OpenError extends HpkeError {\n}\n/**\n * Sequence number overflow on the encryption context.\n * @group Errors\n */\nexport class MessageLimitReachedError extends HpkeError {\n}\n/**\n * Key pair derivation failure.\n * @group Errors\n */\nexport class DeriveKeyPairError extends HpkeError {\n}\n/**\n * Not supported failure.\n * @group Errors\n */\nexport class NotSupportedError extends HpkeError {\n}\n","const dntGlobals = {};\nexport const dntGlobalThis = createMergeProxy(globalThis, dntGlobals);\nfunction createMergeProxy(baseObj, extObj) {\n    return new Proxy(baseObj, {\n        get(_target, prop, _receiver) {\n            if (prop in extObj) {\n                return extObj[prop];\n            }\n            else {\n                return baseObj[prop];\n            }\n        },\n        set(_target, prop, value) {\n            if (prop in extObj) {\n                delete extObj[prop];\n            }\n            baseObj[prop] = value;\n            return true;\n        },\n        deleteProperty(_target, prop) {\n            let success = false;\n            if (prop in extObj) {\n                delete extObj[prop];\n                success = true;\n            }\n            if (prop in baseObj) {\n                delete baseObj[prop];\n                success = true;\n            }\n            return success;\n        },\n        ownKeys(_target) {\n            const baseKeys = Reflect.ownKeys(baseObj);\n            const extKeys = Reflect.ownKeys(extObj);\n            const extKeysSet = new Set(extKeys);\n            return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];\n        },\n        defineProperty(_target, prop, desc) {\n            if (prop in extObj) {\n                delete extObj[prop];\n            }\n            Reflect.defineProperty(baseObj, prop, desc);\n            return true;\n        },\n        getOwnPropertyDescriptor(_target, prop) {\n            if (prop in extObj) {\n                return Reflect.getOwnPropertyDescriptor(extObj, prop);\n            }\n            else {\n                return Reflect.getOwnPropertyDescriptor(baseObj, prop);\n            }\n        },\n        has(_target, prop) {\n            return prop in extObj || prop in baseObj;\n        },\n    });\n}\n","import * as dntShim from \"../_dnt.shims.js\";\nimport { NotSupportedError } from \"./errors.js\";\nasync function loadSubtleCrypto() {\n    if (dntShim.dntGlobalThis !== undefined && globalThis.crypto !== undefined) {\n        // Browsers, Node.js >= v19, Cloudflare Workers, Bun, etc.\n        return globalThis.crypto.subtle;\n    }\n    // Node.js <= v18\n    try {\n        // @ts-ignore: to ignore \"crypto\"\n        const { webcrypto } = await import(\"crypto\"); // node:crypto\n        return webcrypto.subtle;\n    }\n    catch (e) {\n        throw new NotSupportedError(e);\n    }\n}\nexport class NativeAlgorithm {\n    constructor() {\n        Object.defineProperty(this, \"_api\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    async _setup() {\n        if (this._api !== undefined) {\n            return;\n        }\n        this._api = await loadSubtleCrypto();\n    }\n}\n","/**\n * The supported HPKE modes.\n */\nexport const Mode = {\n    Base: 0x00,\n    Psk: 0x01,\n    Auth: 0x02,\n    AuthPsk: 0x03,\n};\n/**\n * The supported Key Encapsulation Mechanism (KEM) identifiers.\n */\nexport const KemId = {\n    NotAssigned: 0x0000,\n    DhkemP256HkdfSha256: 0x0010,\n    DhkemP384HkdfSha384: 0x0011,\n    DhkemP521HkdfSha512: 0x0012,\n    DhkemSecp256k1HkdfSha256: 0x0013,\n    DhkemX25519HkdfSha256: 0x0020,\n    DhkemX448HkdfSha512: 0x0021,\n    HybridkemX25519Kyber768: 0x0030,\n    MlKem512: 0x0040,\n    MlKem768: 0x0041,\n    MlKem1024: 0x0042,\n    XWing: 0x647a,\n};\n/**\n * The supported Key Derivation Function (KDF) identifiers.\n */\nexport const KdfId = {\n    HkdfSha256: 0x0001,\n    HkdfSha384: 0x0002,\n    HkdfSha512: 0x0003,\n};\n/**\n * The supported Authenticated Encryption with Associated Data (AEAD) identifiers.\n */\nexport const AeadId = {\n    Aes128Gcm: 0x0001,\n    Aes256Gcm: 0x0002,\n    Chacha20Poly1305: 0x0003,\n    ExportOnly: 0xFFFF,\n};\n","// The input length limit (psk, psk_id, info, exporter_context, ikm).\nexport const INPUT_LENGTH_LIMIT = 8192;\nexport const INFO_LENGTH_LIMIT = 65536;\n// The minimum length of a PSK.\nexport const MINIMUM_PSK_LENGTH = 32;\n// b\"\"\nexport const EMPTY = new Uint8Array(0);\n","// b\"KEM\"\nexport const SUITE_ID_HEADER_KEM = new Uint8Array([\n    75,\n    69,\n    77,\n    0,\n    0,\n]);\n","import * as dntShim from \"../../_dnt.shims.js\";\nimport { KemId } from \"../identifiers.js\";\nexport const isDenoV1 = () => \n// deno-lint-ignore no-explicit-any\ndntShim.dntGlobalThis.process === undefined;\n/**\n * Checks whether the runtime is Deno or not (Node.js).\n * @returns boolean - true if the runtime is Deno, false Node.js.\n */\nexport function isDeno() {\n    // deno-lint-ignore no-explicit-any\n    if (dntShim.dntGlobalThis.process === undefined) {\n        return true;\n    }\n    // deno-lint-ignore no-explicit-any\n    return dntShim.dntGlobalThis.process?.versions?.deno !== undefined;\n}\n/**\n * Checks whetehr the type of input is CryptoKeyPair or not.\n */\nexport const isCryptoKeyPair = (x) => typeof x === \"object\" &&\n    x !== null &&\n    typeof x.privateKey === \"object\" &&\n    typeof x.publicKey === \"object\";\n/**\n * Converts integer to octet string. I2OSP implementation.\n */\nexport function i2Osp(n, w) {\n    if (w <= 0) {\n        throw new Error(\"i2Osp: too small size\");\n    }\n    if (n >= 256 ** w) {\n        throw new Error(\"i2Osp: too large integer\");\n    }\n    const ret = new Uint8Array(w);\n    for (let i = 0; i < w && n; i++) {\n        ret[w - (i + 1)] = n % 256;\n        n = n >> 8;\n    }\n    return ret;\n}\n/**\n * Concatenates two Uint8Arrays.\n * @param a Uint8Array\n * @param b Uint8Array\n * @returns Concatenated Uint8Array\n */\nexport function concat(a, b) {\n    const ret = new Uint8Array(a.length + b.length);\n    ret.set(a, 0);\n    ret.set(b, a.length);\n    return ret;\n}\n/**\n * Decodes Base64Url-encoded data.\n * @param v Base64Url-encoded string\n * @returns Uint8Array\n */\nexport function base64UrlToBytes(v) {\n    const base64 = v.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const byteString = atob(base64);\n    const ret = new Uint8Array(byteString.length);\n    for (let i = 0; i < byteString.length; i++) {\n        ret[i] = byteString.charCodeAt(i);\n    }\n    return ret;\n}\n/**\n * Encodes Uint8Array to Base64Url.\n * @param v Uint8Array\n * @returns Base64Url-encoded string\n */\nexport function bytesToBase64Url(v) {\n    return btoa(String.fromCharCode(...v))\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=*$/g, \"\");\n}\n/**\n * Decodes hex string to Uint8Array.\n * @param v Hex string\n * @returns Uint8Array\n * @throws Error if the input is not a hex string.\n */\nexport function hexToBytes(v) {\n    if (v.length === 0) {\n        return new Uint8Array([]);\n    }\n    const res = v.match(/[\\da-f]{2}/gi);\n    if (res == null) {\n        throw new Error(\"Not hex string.\");\n    }\n    return new Uint8Array(res.map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n/**\n * Encodes Uint8Array to hex string.\n * @param v Uint8Array\n * @returns Hex string\n */\nexport function bytesToHex(v) {\n    return [...v].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n}\n/**\n * Converts KemId to KeyAlgorithm.\n * @param kem KemId\n * @returns KeyAlgorithm\n */\nexport function kemToKeyGenAlgorithm(kem) {\n    switch (kem) {\n        case KemId.DhkemP256HkdfSha256:\n            return {\n                name: \"ECDH\",\n                namedCurve: \"P-256\",\n            };\n        case KemId.DhkemP384HkdfSha384:\n            return {\n                name: \"ECDH\",\n                namedCurve: \"P-384\",\n            };\n        case KemId.DhkemP521HkdfSha512:\n            return {\n                name: \"ECDH\",\n                namedCurve: \"P-521\",\n            };\n        default:\n            // case KemId.DhkemX25519HkdfSha256\n            return {\n                name: \"X25519\",\n            };\n    }\n}\nexport async function loadSubtleCrypto() {\n    if (dntShim.dntGlobalThis !== undefined && globalThis.crypto !== undefined) {\n        // Browsers, Node.js >= v19, Cloudflare Workers, Bun, etc.\n        return globalThis.crypto.subtle;\n    }\n    // Node.js <= v18\n    try {\n        // @ts-ignore: to ignore \"crypto\"\n        const { webcrypto } = await import(\"crypto\"); // node:crypto\n        return webcrypto.subtle;\n    }\n    catch (_e) {\n        throw new Error(\"Failed to load SubtleCrypto\");\n    }\n}\nexport async function loadCrypto() {\n    if (dntShim.dntGlobalThis !== undefined && globalThis.crypto !== undefined) {\n        // Browsers, Node.js >= v19, Cloudflare Workers, Bun, etc.\n        return globalThis.crypto;\n    }\n    // Node.js <= v18\n    try {\n        // @ts-ignore: to ignore \"crypto\"\n        const { webcrypto } = await import(\"crypto\"); // node:crypto\n        return webcrypto;\n    }\n    catch (_e) {\n        throw new Error(\"Web Cryptograph API not supported\");\n    }\n}\n/**\n * XOR for Uint8Array.\n */\nexport function xor(a, b) {\n    if (a.byteLength !== b.byteLength) {\n        throw new Error(\"xor: different length inputs\");\n    }\n    const buf = new Uint8Array(a.byteLength);\n    for (let i = 0; i < a.byteLength; i++) {\n        buf[i] = a[i] ^ b[i];\n    }\n    return buf;\n}\n","import { EMPTY, INPUT_LENGTH_LIMIT } from \"../consts.js\";\nimport { DecapError, EncapError, InvalidParamError } from \"../errors.js\";\nimport { SUITE_ID_HEADER_KEM } from \"../interfaces/kemInterface.js\";\nimport { concat, i2Osp, isCryptoKeyPair } from \"../utils/misc.js\";\n// b\"eae_prk\"\nconst LABEL_EAE_PRK = new Uint8Array([101, 97, 101, 95, 112, 114, 107]);\n// b\"shared_secret\"\n// deno-fmt-ignore\nconst LABEL_SHARED_SECRET = new Uint8Array([\n    115, 104, 97, 114, 101, 100, 95, 115, 101, 99,\n    114, 101, 116,\n]);\nfunction concat3(a, b, c) {\n    const ret = new Uint8Array(a.length + b.length + c.length);\n    ret.set(a, 0);\n    ret.set(b, a.length);\n    ret.set(c, a.length + b.length);\n    return ret;\n}\nexport class Dhkem {\n    constructor(id, prim, kdf) {\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_prim\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_kdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.id = id;\n        this._prim = prim;\n        this._kdf = kdf;\n        const suiteId = new Uint8Array(SUITE_ID_HEADER_KEM);\n        suiteId.set(i2Osp(this.id, 2), 3);\n        this._kdf.init(suiteId);\n    }\n    async serializePublicKey(key) {\n        return await this._prim.serializePublicKey(key);\n    }\n    async deserializePublicKey(key) {\n        return await this._prim.deserializePublicKey(key);\n    }\n    async serializePrivateKey(key) {\n        return await this._prim.serializePrivateKey(key);\n    }\n    async deserializePrivateKey(key) {\n        return await this._prim.deserializePrivateKey(key);\n    }\n    async importKey(format, key, isPublic = true) {\n        return await this._prim.importKey(format, key, isPublic);\n    }\n    async generateKeyPair() {\n        return await this._prim.generateKeyPair();\n    }\n    async deriveKeyPair(ikm) {\n        if (ikm.byteLength > INPUT_LENGTH_LIMIT) {\n            throw new InvalidParamError(\"Too long ikm\");\n        }\n        return await this._prim.deriveKeyPair(ikm);\n    }\n    async encap(params) {\n        let ke;\n        if (params.ekm === undefined) {\n            ke = await this.generateKeyPair();\n        }\n        else if (isCryptoKeyPair(params.ekm)) {\n            // params.ekm is only used for testing.\n            ke = params.ekm;\n        }\n        else {\n            // params.ekm is only used for testing.\n            ke = await this.deriveKeyPair(params.ekm);\n        }\n        const enc = await this._prim.serializePublicKey(ke.publicKey);\n        const pkrm = await this._prim.serializePublicKey(params.recipientPublicKey);\n        try {\n            let dh;\n            if (params.senderKey === undefined) {\n                dh = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));\n            }\n            else {\n                const sks = isCryptoKeyPair(params.senderKey)\n                    ? params.senderKey.privateKey\n                    : params.senderKey;\n                const dh1 = new Uint8Array(await this._prim.dh(ke.privateKey, params.recipientPublicKey));\n                const dh2 = new Uint8Array(await this._prim.dh(sks, params.recipientPublicKey));\n                dh = concat(dh1, dh2);\n            }\n            let kemContext;\n            if (params.senderKey === undefined) {\n                kemContext = concat(new Uint8Array(enc), new Uint8Array(pkrm));\n            }\n            else {\n                const pks = isCryptoKeyPair(params.senderKey)\n                    ? params.senderKey.publicKey\n                    : await this._prim.derivePublicKey(params.senderKey);\n                const pksm = await this._prim.serializePublicKey(pks);\n                kemContext = concat3(new Uint8Array(enc), new Uint8Array(pkrm), new Uint8Array(pksm));\n            }\n            const sharedSecret = await this._generateSharedSecret(dh, kemContext);\n            return {\n                enc: enc,\n                sharedSecret: sharedSecret,\n            };\n        }\n        catch (e) {\n            throw new EncapError(e);\n        }\n    }\n    async decap(params) {\n        const pke = await this._prim.deserializePublicKey(params.enc);\n        const skr = isCryptoKeyPair(params.recipientKey)\n            ? params.recipientKey.privateKey\n            : params.recipientKey;\n        const pkr = isCryptoKeyPair(params.recipientKey)\n            ? params.recipientKey.publicKey\n            : await this._prim.derivePublicKey(params.recipientKey);\n        const pkrm = await this._prim.serializePublicKey(pkr);\n        try {\n            let dh;\n            if (params.senderPublicKey === undefined) {\n                dh = new Uint8Array(await this._prim.dh(skr, pke));\n            }\n            else {\n                const dh1 = new Uint8Array(await this._prim.dh(skr, pke));\n                const dh2 = new Uint8Array(await this._prim.dh(skr, params.senderPublicKey));\n                dh = concat(dh1, dh2);\n            }\n            let kemContext;\n            if (params.senderPublicKey === undefined) {\n                kemContext = concat(new Uint8Array(params.enc), new Uint8Array(pkrm));\n            }\n            else {\n                const pksm = await this._prim.serializePublicKey(params.senderPublicKey);\n                kemContext = new Uint8Array(params.enc.byteLength + pkrm.byteLength + pksm.byteLength);\n                kemContext.set(new Uint8Array(params.enc), 0);\n                kemContext.set(new Uint8Array(pkrm), params.enc.byteLength);\n                kemContext.set(new Uint8Array(pksm), params.enc.byteLength + pkrm.byteLength);\n            }\n            return await this._generateSharedSecret(dh, kemContext);\n        }\n        catch (e) {\n            throw new DecapError(e);\n        }\n    }\n    async _generateSharedSecret(dh, kemContext) {\n        const labeledIkm = this._kdf.buildLabeledIkm(LABEL_EAE_PRK, dh);\n        const labeledInfo = this._kdf.buildLabeledInfo(LABEL_SHARED_SECRET, kemContext, this.secretSize);\n        return await this._kdf.extractAndExpand(EMPTY.buffer, labeledIkm.buffer, labeledInfo.buffer, this.secretSize);\n    }\n}\n","// The key usages for KEM.\nexport const KEM_USAGES = [\"deriveBits\"];\n// b\"dkp_prk\"\nexport const LABEL_DKP_PRK = new Uint8Array([\n    100,\n    107,\n    112,\n    95,\n    112,\n    114,\n    107,\n]);\n// b\"sk\"\nexport const LABEL_SK = new Uint8Array([115, 107]);\n","/**\n * The minimum inplementation of bignum to derive an EC key pair.\n */\nexport class Bignum {\n    constructor(size) {\n        Object.defineProperty(this, \"_num\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._num = new Uint8Array(size);\n    }\n    val() {\n        return this._num;\n    }\n    reset() {\n        this._num.fill(0);\n    }\n    set(src) {\n        if (src.length !== this._num.length) {\n            throw new Error(\"Bignum.set: invalid argument\");\n        }\n        this._num.set(src);\n    }\n    isZero() {\n        for (let i = 0; i < this._num.length; i++) {\n            if (this._num[i] !== 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    lessThan(v) {\n        if (v.length !== this._num.length) {\n            throw new Error(\"Bignum.lessThan: invalid argument\");\n        }\n        for (let i = 0; i < this._num.length; i++) {\n            if (this._num[i] < v[i]) {\n                return true;\n            }\n            if (this._num[i] > v[i]) {\n                return false;\n            }\n        }\n        return false;\n    }\n}\n","import { NativeAlgorithm } from \"../../algorithm.js\";\nimport { EMPTY } from \"../../consts.js\";\nimport { DeriveKeyPairError, DeserializeError, NotSupportedError, SerializeError, } from \"../../errors.js\";\nimport { KemId } from \"../../identifiers.js\";\nimport { KEM_USAGES, LABEL_DKP_PRK } from \"../../interfaces/dhkemPrimitives.js\";\nimport { Bignum } from \"../../utils/bignum.js\";\nimport { base64UrlToBytes, i2Osp } from \"../../utils/misc.js\";\n// b\"candidate\"\n// deno-fmt-ignore\nconst LABEL_CANDIDATE = new Uint8Array([\n    99, 97, 110, 100, 105, 100, 97, 116, 101,\n]);\n// the order of the curve being used.\n// deno-fmt-ignore\nconst ORDER_P_256 = new Uint8Array([\n    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84,\n    0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51,\n]);\n// deno-fmt-ignore\nconst ORDER_P_384 = new Uint8Array([\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,\n    0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a,\n    0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73,\n]);\n// deno-fmt-ignore\nconst ORDER_P_521 = new Uint8Array([\n    0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0xff, 0xfa, 0x51, 0x86, 0x87, 0x83, 0xbf, 0x2f,\n    0x96, 0x6b, 0x7f, 0xcc, 0x01, 0x48, 0xf7, 0x09,\n    0xa5, 0xd0, 0x3b, 0xb5, 0xc9, 0xb8, 0x89, 0x9c,\n    0x47, 0xae, 0xbb, 0x6f, 0xb7, 0x1e, 0x91, 0x38,\n    0x64, 0x09,\n]);\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_P_256 = new Uint8Array([\n    48, 65, 2, 1, 0, 48, 19, 6, 7, 42,\n    134, 72, 206, 61, 2, 1, 6, 8, 42, 134,\n    72, 206, 61, 3, 1, 7, 4, 39, 48, 37,\n    2, 1, 1, 4, 32,\n]);\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_P_384 = new Uint8Array([\n    48, 78, 2, 1, 0, 48, 16, 6, 7, 42,\n    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,\n    4, 0, 34, 4, 55, 48, 53, 2, 1, 1,\n    4, 48,\n]);\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_P_521 = new Uint8Array([\n    48, 96, 2, 1, 0, 48, 16, 6, 7, 42,\n    134, 72, 206, 61, 2, 1, 6, 5, 43, 129,\n    4, 0, 35, 4, 73, 48, 71, 2, 1, 1,\n    4, 66,\n]);\nexport class Ec extends NativeAlgorithm {\n    constructor(kem, hkdf) {\n        super();\n        Object.defineProperty(this, \"_hkdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_alg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nPk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nSk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nDh\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // EC specific arguments for deriving key pair.\n        Object.defineProperty(this, \"_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_bitmask\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pkcs8AlgId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._hkdf = hkdf;\n        switch (kem) {\n            case KemId.DhkemP256HkdfSha256:\n                this._alg = { name: \"ECDH\", namedCurve: \"P-256\" };\n                this._nPk = 65;\n                this._nSk = 32;\n                this._nDh = 32;\n                this._order = ORDER_P_256;\n                this._bitmask = 0xFF;\n                this._pkcs8AlgId = PKCS8_ALG_ID_P_256;\n                break;\n            case KemId.DhkemP384HkdfSha384:\n                this._alg = { name: \"ECDH\", namedCurve: \"P-384\" };\n                this._nPk = 97;\n                this._nSk = 48;\n                this._nDh = 48;\n                this._order = ORDER_P_384;\n                this._bitmask = 0xFF;\n                this._pkcs8AlgId = PKCS8_ALG_ID_P_384;\n                break;\n            default:\n                // case KemId.DhkemP521HkdfSha512:\n                this._alg = { name: \"ECDH\", namedCurve: \"P-521\" };\n                this._nPk = 133;\n                this._nSk = 66;\n                this._nDh = 66;\n                this._order = ORDER_P_521;\n                this._bitmask = 0x01;\n                this._pkcs8AlgId = PKCS8_ALG_ID_P_521;\n                break;\n        }\n    }\n    async serializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._api.exportKey(\"raw\", key);\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, true);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async serializePrivateKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            if (!(\"d\" in jwk)) {\n                throw new Error(\"Not private key\");\n            }\n            return base64UrlToBytes(jwk[\"d\"]).buffer;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePrivateKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, false);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async importKey(format, key, isPublic) {\n        await this._setup();\n        try {\n            if (format === \"raw\") {\n                return await this._importRawKey(key, isPublic);\n            }\n            // jwk\n            if (key instanceof ArrayBuffer) {\n                throw new Error(\"Invalid jwk key format\");\n            }\n            return await this._importJWK(key, isPublic);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async generateKeyPair() {\n        await this._setup();\n        try {\n            return await this._api.generateKey(this._alg, true, KEM_USAGES);\n        }\n        catch (e) {\n            throw new NotSupportedError(e);\n        }\n    }\n    async deriveKeyPair(ikm) {\n        await this._setup();\n        try {\n            const dkpPrk = await this._hkdf.labeledExtract(EMPTY.buffer, LABEL_DKP_PRK, new Uint8Array(ikm));\n            const bn = new Bignum(this._nSk);\n            for (let counter = 0; bn.isZero() || !bn.lessThan(this._order); counter++) {\n                if (counter > 255) {\n                    throw new Error(\"Faild to derive a key pair\");\n                }\n                const bytes = new Uint8Array(await this._hkdf.labeledExpand(dkpPrk, LABEL_CANDIDATE, i2Osp(counter, 1), this._nSk));\n                bytes[0] = bytes[0] & this._bitmask;\n                bn.set(bytes);\n            }\n            const sk = await this._deserializePkcs8Key(bn.val());\n            bn.reset();\n            return {\n                privateKey: sk,\n                publicKey: await this.derivePublicKey(sk),\n            };\n        }\n        catch (e) {\n            throw new DeriveKeyPairError(e);\n        }\n    }\n    async derivePublicKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            delete jwk[\"d\"];\n            delete jwk[\"key_ops\"];\n            return await this._api.importKey(\"jwk\", jwk, this._alg, true, []);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async dh(sk, pk) {\n        try {\n            await this._setup();\n            const bits = await this._api.deriveBits({\n                name: \"ECDH\",\n                public: pk,\n            }, sk, this._nDh * 8);\n            return bits;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async _importRawKey(key, isPublic) {\n        if (isPublic && key.byteLength !== this._nPk) {\n            throw new Error(\"Invalid public key for the ciphersuite\");\n        }\n        if (!isPublic && key.byteLength !== this._nSk) {\n            throw new Error(\"Invalid private key for the ciphersuite\");\n        }\n        if (isPublic) {\n            return await this._api.importKey(\"raw\", key, this._alg, true, []);\n        }\n        return await this._deserializePkcs8Key(new Uint8Array(key));\n    }\n    async _importJWK(key, isPublic) {\n        if (typeof key.crv === \"undefined\" || key.crv !== this._alg.namedCurve) {\n            throw new Error(`Invalid crv: ${key.crv}`);\n        }\n        if (isPublic) {\n            if (typeof key.d !== \"undefined\") {\n                throw new Error(\"Invalid key: `d` should not be set\");\n            }\n            return await this._api.importKey(\"jwk\", key, this._alg, true, []);\n        }\n        if (typeof key.d === \"undefined\") {\n            throw new Error(\"Invalid key: `d` not found\");\n        }\n        return await this._api.importKey(\"jwk\", key, this._alg, true, KEM_USAGES);\n    }\n    async _deserializePkcs8Key(k) {\n        const pkcs8Key = new Uint8Array(this._pkcs8AlgId.length + k.length);\n        pkcs8Key.set(this._pkcs8AlgId, 0);\n        pkcs8Key.set(k, this._pkcs8AlgId.length);\n        return await this._api.importKey(\"pkcs8\", pkcs8Key, this._alg, true, KEM_USAGES);\n    }\n}\n","import { EMPTY } from \"../consts.js\";\nimport { InvalidParamError } from \"../errors.js\";\nimport { KdfId } from \"../identifiers.js\";\nimport { NativeAlgorithm } from \"../algorithm.js\";\n// b\"HPKE-v1\"\nconst HPKE_VERSION = new Uint8Array([72, 80, 75, 69, 45, 118, 49]);\nexport class HkdfNative extends NativeAlgorithm {\n    constructor() {\n        super();\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha256\n        });\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_suiteId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: EMPTY\n        });\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-256\",\n                length: 256,\n            }\n        });\n    }\n    init(suiteId) {\n        this._suiteId = suiteId;\n    }\n    buildLabeledIkm(label, ikm) {\n        this._checkInit();\n        const ret = new Uint8Array(7 + this._suiteId.byteLength + label.byteLength + ikm.byteLength);\n        ret.set(HPKE_VERSION, 0);\n        ret.set(this._suiteId, 7);\n        ret.set(label, 7 + this._suiteId.byteLength);\n        ret.set(ikm, 7 + this._suiteId.byteLength + label.byteLength);\n        return ret;\n    }\n    buildLabeledInfo(label, info, len) {\n        this._checkInit();\n        const ret = new Uint8Array(9 + this._suiteId.byteLength + label.byteLength + info.byteLength);\n        ret.set(new Uint8Array([0, len]), 0);\n        ret.set(HPKE_VERSION, 2);\n        ret.set(this._suiteId, 9);\n        ret.set(label, 9 + this._suiteId.byteLength);\n        ret.set(info, 9 + this._suiteId.byteLength + label.byteLength);\n        return ret;\n    }\n    async extract(salt, ikm) {\n        await this._setup();\n        if (salt.byteLength === 0) {\n            salt = new ArrayBuffer(this.hashSize);\n        }\n        if (salt.byteLength !== this.hashSize) {\n            throw new InvalidParamError(\"The salt length must be the same as the hashSize\");\n        }\n        const key = await this._api.importKey(\"raw\", salt, this.algHash, false, [\n            \"sign\",\n        ]);\n        return await this._api.sign(\"HMAC\", key, ikm);\n    }\n    async expand(prk, info, len) {\n        await this._setup();\n        const key = await this._api.importKey(\"raw\", prk, this.algHash, false, [\n            \"sign\",\n        ]);\n        const okm = new ArrayBuffer(len);\n        const p = new Uint8Array(okm);\n        let prev = EMPTY;\n        const mid = new Uint8Array(info);\n        const tail = new Uint8Array(1);\n        if (len > 255 * this.hashSize) {\n            throw new Error(\"Entropy limit reached\");\n        }\n        const tmp = new Uint8Array(this.hashSize + mid.length + 1);\n        for (let i = 1, cur = 0; cur < p.length; i++) {\n            tail[0] = i;\n            tmp.set(prev, 0);\n            tmp.set(mid, prev.length);\n            tmp.set(tail, prev.length + mid.length);\n            prev = new Uint8Array(await this._api.sign(\"HMAC\", key, tmp.slice(0, prev.length + mid.length + 1)));\n            if (p.length - cur >= prev.length) {\n                p.set(prev, cur);\n                cur += prev.length;\n            }\n            else {\n                p.set(prev.slice(0, p.length - cur), cur);\n                cur += p.length - cur;\n            }\n        }\n        return okm;\n    }\n    async extractAndExpand(salt, ikm, info, len) {\n        await this._setup();\n        const baseKey = await this._api.importKey(\"raw\", ikm, \"HKDF\", false, [\"deriveBits\"]);\n        return await this._api.deriveBits({\n            name: \"HKDF\",\n            hash: this.algHash.hash,\n            salt: salt,\n            info: info,\n        }, baseKey, len * 8);\n    }\n    async labeledExtract(salt, label, ikm) {\n        return await this.extract(salt, this.buildLabeledIkm(label, ikm).buffer);\n    }\n    async labeledExpand(prk, label, info, len) {\n        return await this.expand(prk, this.buildLabeledInfo(label, info, len).buffer, len);\n    }\n    _checkInit() {\n        if (this._suiteId === EMPTY) {\n            throw new Error(\"Not initialized. Call init()\");\n        }\n    }\n}\nexport class HkdfSha256Native extends HkdfNative {\n    constructor() {\n        super(...arguments);\n        /** KdfId.HkdfSha256 (0x0001) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha256\n        });\n        /** 32 */\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n        /** The parameters for Web Cryptography API */\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-256\",\n                length: 256,\n            }\n        });\n    }\n}\nexport class HkdfSha384Native extends HkdfNative {\n    constructor() {\n        super(...arguments);\n        /** KdfId.HkdfSha384 (0x0002) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha384\n        });\n        /** 48 */\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 48\n        });\n        /** The parameters for Web Cryptography API */\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-384\",\n                length: 384,\n            }\n        });\n    }\n}\nexport class HkdfSha512Native extends HkdfNative {\n    constructor() {\n        super(...arguments);\n        /** KdfId.HkdfSha512 (0x0003) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KdfId.HkdfSha512\n        });\n        /** 64 */\n        Object.defineProperty(this, \"hashSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 64\n        });\n        /** The parameters for Web Cryptography API */\n        Object.defineProperty(this, \"algHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {\n                name: \"HMAC\",\n                hash: \"SHA-512\",\n                length: 512,\n            }\n        });\n    }\n}\n","// The key usages for AEAD.\nexport const AEAD_USAGES = [\"encrypt\", \"decrypt\"];\n","/**\n * This file is based on noble-curves (https://github.com/paulmillr/noble-curves).\n *\n * noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com)\n *\n * The original file is located at:\n * https://github.com/paulmillr/noble-curves/blob/b9d49d2b41d550571a0c5be443ecb62109fa3373/src/abstract/montgomery.ts\n */\n/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { abytes, aInRange, bytesToNumberLE, copyBytes, numberToBytesLE, randomBytesAsync, validateObject, } from \"../utils/noble.js\";\nimport { createKeygen } from \"./curve.js\";\nimport { mod } from \"./modular.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n    validateObject(curve, {\n        adjustScalarBytes: \"function\",\n        powPminus2: \"function\",\n    });\n    return Object.freeze({ ...curve });\n}\nexport function montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n    const is25519 = type === \"x25519\";\n    if (!is25519 && type !== \"x448\")\n        throw new Error(\"invalid type\");\n    const randomBytes_ = rand || randomBytesAsync;\n    const montgomeryBits = is25519 ? 255 : 448;\n    const fieldLen = is25519 ? 32 : 56;\n    const Gu = is25519 ? BigInt(9) : BigInt(5);\n    // RFC 7748 #5:\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n    // (156326 - 2) / 4 = 39081 for curve448/X448\n    // const a = is25519 ? 156326n : 486662n;\n    const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n    // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n    // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n    // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n    const maxAdded = is25519\n        ? BigInt(8) * _2n ** BigInt(251) - _1n\n        : BigInt(4) * _2n ** BigInt(445) - _1n;\n    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n    const modP = (n) => mod(n, P);\n    const GuBytes = encodeU(Gu);\n    function encodeU(u) {\n        return numberToBytesLE(modP(u), fieldLen);\n    }\n    function decodeU(u) {\n        const _u = copyBytes(abytes(u, fieldLen, \"uCoordinate\"));\n        // RFC: When receiving such an array, implementations of X25519\n        // (but not X448) MUST mask the most significant bit in the final byte.\n        if (is25519)\n            _u[31] &= 127; // 0b0111_1111\n        // RFC: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.  The non-canonical\n        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n        // - 1 through 2^448 - 1 for X448.\n        return modP(bytesToNumberLE(_u));\n    }\n    function decodeScalar(scalar) {\n        return bytesToNumberLE(adjustScalarBytes(copyBytes(abytes(scalar, fieldLen, \"scalar\"))));\n    }\n    function scalarMult(scalar, u) {\n        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n        // Some public keys are useless, of low-order. Curve author doesn't think\n        // it needs to be validated, but we do it nonetheless.\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error(\"invalid private or public key received\");\n        return encodeU(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    const getPublicKey = scalarMultBase;\n    const getSharedSecret = scalarMult;\n    // cswap from RFC7748 \"example code\"\n    function cswap(swap, x_2, x_3) {\n        // dummy = mask(swap) AND (x_2 XOR x_3)\n        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n        // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n        return { x_2, x_3 };\n    }\n    /**\n     * Montgomery x-only multiplication ladder.\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(u, scalar) {\n        aInRange(\"u\", u, _0n, P);\n        aInRange(\"scalar\", scalar, minScalar, maxScalar);\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n    }\n    const lengths = {\n        secretKey: fieldLen,\n        publicKey: fieldLen,\n        seed: fieldLen,\n    };\n    const randomSecretKey = async (seed) => {\n        if (seed === undefined) {\n            seed = await randomBytes_(fieldLen);\n        }\n        abytes(seed, lengths.seed, \"seed\");\n        return seed;\n    };\n    const utils = { randomSecretKey };\n    return Object.freeze({\n        keygen: createKeygen(randomSecretKey, getPublicKey),\n        getSharedSecret,\n        getPublicKey,\n        scalarMult,\n        scalarMultBase,\n        utils,\n        GuBytes: GuBytes.slice(),\n        lengths,\n    });\n}\n","import { AEAD_USAGES, AeadId, NativeAlgorithm } from \"@hpke/common\";\nexport class AesGcmContext extends NativeAlgorithm {\n    constructor(key) {\n        super();\n        Object.defineProperty(this, \"_rawKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_key\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        this._rawKey = key;\n    }\n    async seal(iv, data, aad) {\n        await this._setupKey();\n        const alg = {\n            name: \"AES-GCM\",\n            iv: iv,\n            additionalData: aad,\n        };\n        const ct = await this._api.encrypt(alg, this._key, data);\n        return ct;\n    }\n    async open(iv, data, aad) {\n        await this._setupKey();\n        const alg = {\n            name: \"AES-GCM\",\n            iv: iv,\n            additionalData: aad,\n        };\n        const pt = await this._api.decrypt(alg, this._key, data);\n        return pt;\n    }\n    async _setupKey() {\n        if (this._key !== undefined) {\n            return;\n        }\n        await this._setup();\n        const key = await this._importKey(this._rawKey);\n        (new Uint8Array(this._rawKey)).fill(0);\n        this._key = key;\n        return;\n    }\n    async _importKey(key) {\n        return await this._api.importKey(\"raw\", key, { name: \"AES-GCM\" }, true, AEAD_USAGES);\n    }\n}\n/**\n * The AES-128-GCM for HPKE AEAD implementing {@link AeadInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes128Gcm`.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class Aes128Gcm {\n    constructor() {\n        /** AeadId.Aes128Gcm (0x0001) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: AeadId.Aes128Gcm\n        });\n        /** 16 */\n        Object.defineProperty(this, \"keySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 16\n        });\n        /** 12 */\n        Object.defineProperty(this, \"nonceSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 12\n        });\n        /** 16 */\n        Object.defineProperty(this, \"tagSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 16\n        });\n    }\n    createEncryptionContext(key) {\n        return new AesGcmContext(key);\n    }\n}\n/**\n * The AES-256-GCM for HPKE AEAD implementing {@link AeadInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `aead` parameter of {@link CipherSuiteParams} instead of `AeadId.Aes256Gcm`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes256Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes256Gcm(),\n * });\n * ```\n */\nexport class Aes256Gcm extends Aes128Gcm {\n    constructor() {\n        super(...arguments);\n        /** AeadId.Aes256Gcm (0x0002) */\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: AeadId.Aes256Gcm\n        });\n        /** 32 */\n        Object.defineProperty(this, \"keySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n        /** 12 */\n        Object.defineProperty(this, \"nonceSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 12\n        });\n        /** 16 */\n        Object.defineProperty(this, \"tagSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 16\n        });\n    }\n}\n","import { NotSupportedError } from \"@hpke/common\";\nexport function emitNotSupported() {\n    return new Promise((_resolve, reject) => {\n        reject(new NotSupportedError(\"Not supported\"));\n    });\n}\n","import { ExportError, INPUT_LENGTH_LIMIT, InvalidParamError, } from \"@hpke/common\";\nimport { emitNotSupported } from \"./utils/emitNotSupported.js\";\n// b\"sec\"\nconst LABEL_SEC = new Uint8Array([115, 101, 99]);\nexport class ExporterContextImpl {\n    constructor(api, kdf, exporterSecret) {\n        Object.defineProperty(this, \"_api\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"exporterSecret\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_kdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._api = api;\n        this._kdf = kdf;\n        this.exporterSecret = exporterSecret;\n    }\n    async seal(_data, _aad) {\n        return await emitNotSupported();\n    }\n    async open(_data, _aad) {\n        return await emitNotSupported();\n    }\n    async export(exporterContext, len) {\n        if (exporterContext.byteLength > INPUT_LENGTH_LIMIT) {\n            throw new InvalidParamError(\"Too long exporter context\");\n        }\n        try {\n            return await this._kdf.labeledExpand(this.exporterSecret, LABEL_SEC, new Uint8Array(exporterContext), len);\n        }\n        catch (e) {\n            throw new ExportError(e);\n        }\n    }\n}\nexport class RecipientExporterContextImpl extends ExporterContextImpl {\n}\nexport class SenderExporterContextImpl extends ExporterContextImpl {\n    constructor(api, kdf, exporterSecret, enc) {\n        super(api, kdf, exporterSecret);\n        Object.defineProperty(this, \"enc\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.enc = enc;\n        return;\n    }\n}\n","import { i2Osp, MessageLimitReachedError, xor } from \"@hpke/common\";\nimport { ExporterContextImpl } from \"./exporterContext.js\";\nexport class EncryptionContextImpl extends ExporterContextImpl {\n    constructor(api, kdf, params) {\n        super(api, kdf, params.exporterSecret);\n        // AEAD id.\n        Object.defineProperty(this, \"_aead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The length in bytes of a key for the algorithm.\n        Object.defineProperty(this, \"_nK\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The length in bytes of a nonce for the algorithm.\n        Object.defineProperty(this, \"_nN\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The length in bytes of an authentication tag for the algorithm.\n        Object.defineProperty(this, \"_nT\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // The end-to-end encryption key information.\n        Object.defineProperty(this, \"_ctx\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (params.key === undefined || params.baseNonce === undefined ||\n            params.seq === undefined) {\n            throw new Error(\"Required parameters are missing\");\n        }\n        this._aead = params.aead;\n        this._nK = this._aead.keySize;\n        this._nN = this._aead.nonceSize;\n        this._nT = this._aead.tagSize;\n        const key = this._aead.createEncryptionContext(params.key);\n        this._ctx = {\n            key: key,\n            baseNonce: params.baseNonce,\n            seq: params.seq,\n        };\n    }\n    computeNonce(k) {\n        const seqBytes = i2Osp(k.seq, k.baseNonce.byteLength);\n        return xor(k.baseNonce, seqBytes).buffer;\n    }\n    incrementSeq(k) {\n        // if (this.seq >= (1 << (8 * this.baseNonce.byteLength)) - 1) {\n        if (k.seq > Number.MAX_SAFE_INTEGER) {\n            throw new MessageLimitReachedError(\"Message limit reached\");\n        }\n        k.seq += 1;\n        return;\n    }\n}\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _Mutex_locked;\nexport class Mutex {\n    constructor() {\n        _Mutex_locked.set(this, Promise.resolve());\n    }\n    async lock() {\n        let releaseLock;\n        const nextLock = new Promise((resolve) => {\n            releaseLock = resolve;\n        });\n        const previousLock = __classPrivateFieldGet(this, _Mutex_locked, \"f\");\n        __classPrivateFieldSet(this, _Mutex_locked, nextLock, \"f\");\n        await previousLock;\n        return releaseLock;\n    }\n}\n_Mutex_locked = new WeakMap();\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _RecipientContextImpl_mutex;\nimport { EMPTY, OpenError } from \"@hpke/common\";\nimport { EncryptionContextImpl } from \"./encryptionContext.js\";\nimport { Mutex } from \"./mutex.js\";\nexport class RecipientContextImpl extends EncryptionContextImpl {\n    constructor() {\n        super(...arguments);\n        _RecipientContextImpl_mutex.set(this, void 0);\n    }\n    async open(data, aad = EMPTY.buffer) {\n        __classPrivateFieldSet(this, _RecipientContextImpl_mutex, __classPrivateFieldGet(this, _RecipientContextImpl_mutex, \"f\") ?? new Mutex(), \"f\");\n        const release = await __classPrivateFieldGet(this, _RecipientContextImpl_mutex, \"f\").lock();\n        let pt;\n        try {\n            pt = await this._ctx.key.open(this.computeNonce(this._ctx), data, aad);\n        }\n        catch (e) {\n            throw new OpenError(e);\n        }\n        finally {\n            release();\n        }\n        this.incrementSeq(this._ctx);\n        return pt;\n    }\n}\n_RecipientContextImpl_mutex = new WeakMap();\n","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _SenderContextImpl_mutex;\nimport { EMPTY, SealError } from \"@hpke/common\";\nimport { EncryptionContextImpl } from \"./encryptionContext.js\";\nimport { Mutex } from \"./mutex.js\";\nexport class SenderContextImpl extends EncryptionContextImpl {\n    constructor(api, kdf, params, enc) {\n        super(api, kdf, params);\n        Object.defineProperty(this, \"enc\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        _SenderContextImpl_mutex.set(this, void 0);\n        this.enc = enc;\n    }\n    async seal(data, aad = EMPTY.buffer) {\n        __classPrivateFieldSet(this, _SenderContextImpl_mutex, __classPrivateFieldGet(this, _SenderContextImpl_mutex, \"f\") ?? new Mutex(), \"f\");\n        const release = await __classPrivateFieldGet(this, _SenderContextImpl_mutex, \"f\").lock();\n        let ct;\n        try {\n            ct = await this._ctx.key.seal(this.computeNonce(this._ctx), data, aad);\n        }\n        catch (e) {\n            throw new SealError(e);\n        }\n        finally {\n            release();\n        }\n        this.incrementSeq(this._ctx);\n        return ct;\n    }\n}\n_SenderContextImpl_mutex = new WeakMap();\n","import { AeadId, EMPTY, i2Osp, INFO_LENGTH_LIMIT, INPUT_LENGTH_LIMIT, InvalidParamError, MINIMUM_PSK_LENGTH, Mode, NativeAlgorithm, } from \"@hpke/common\";\nimport { RecipientExporterContextImpl, SenderExporterContextImpl, } from \"./exporterContext.js\";\nimport { RecipientContextImpl } from \"./recipientContext.js\";\nimport { SenderContextImpl } from \"./senderContext.js\";\n// b\"base_nonce\"\n// deno-fmt-ignore\nconst LABEL_BASE_NONCE = new Uint8Array([\n    98, 97, 115, 101, 95, 110, 111, 110, 99, 101,\n]);\n// b\"exp\"\nconst LABEL_EXP = new Uint8Array([101, 120, 112]);\n// b\"info_hash\"\n// deno-fmt-ignore\nconst LABEL_INFO_HASH = new Uint8Array([\n    105, 110, 102, 111, 95, 104, 97, 115, 104,\n]);\n// b\"key\"\nconst LABEL_KEY = new Uint8Array([107, 101, 121]);\n// b\"psk_id_hash\"\n// deno-fmt-ignore\nconst LABEL_PSK_ID_HASH = new Uint8Array([\n    112, 115, 107, 95, 105, 100, 95, 104, 97, 115, 104,\n]);\n// b\"secret\"\nconst LABEL_SECRET = new Uint8Array([115, 101, 99, 114, 101, 116]);\n// b\"HPKE\"\n// deno-fmt-ignore\nconst SUITE_ID_HEADER_HPKE = new Uint8Array([\n    72, 80, 75, 69, 0, 0, 0, 0, 0, 0,\n]);\n/**\n * The Hybrid Public Key Encryption (HPKE) ciphersuite,\n * which is implemented using only\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n *\n * This is the super class of {@link CipherSuite} and the same as\n * {@link https://jsr.io/@hpke/core/doc/~/CipherSuite | @hpke/core#CipherSuite} as follows:\n * which supports only the ciphersuites that can be implemented on the native\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n * Therefore, the following cryptographic algorithms are not supported for now:\n *   - DHKEM(X25519, HKDF-SHA256)\n *   - DHKEM(X448, HKDF-SHA512)\n *   - ChaCha20Poly1305\n *\n * In addtion, the HKDF functions contained in this class can only derive\n * keys of the same length as the `hashSize`.\n *\n * If you want to use the unsupported cryptographic algorithms\n * above or derive keys longer than the `hashSize`,\n * please use {@link CipherSuite}.\n *\n * This class provides following functions:\n *\n * - Creates encryption contexts both for senders and recipients.\n *   - {@link createSenderContext}\n *   - {@link createRecipientContext}\n * - Provides single-shot encryption API.\n *   - {@link seal}\n *   - {@link open}\n *\n * The calling of the constructor of this class is the starting\n * point for HPKE operations for both senders and recipients.\n *\n * @example Use only ciphersuites supported by Web Cryptography API.\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n *   CipherSuite,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n *\n * @example Use a ciphersuite which is currently not supported by Web Cryptography API.\n *\n * ```ts\n * import { Aes128Gcm, HkdfSha256, CipherSuite } from \"@hpke/core\";\n * // Use an extension module.\n * import { DhkemX25519HkdfSha256 } from \"@hpke/dhkem-x25519\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemX25519HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class CipherSuiteNative extends NativeAlgorithm {\n    /**\n     * @param params A set of parameters for building a cipher suite.\n     *\n     * If the error occurred, throws {@link InvalidParamError}.\n     *\n     * @throws {@link InvalidParamError}\n     */\n    constructor(params) {\n        super();\n        Object.defineProperty(this, \"_kem\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_kdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_aead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_suiteId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // KEM\n        if (typeof params.kem === \"number\") {\n            throw new InvalidParamError(\"KemId cannot be used\");\n        }\n        this._kem = params.kem;\n        // KDF\n        if (typeof params.kdf === \"number\") {\n            throw new InvalidParamError(\"KdfId cannot be used\");\n        }\n        this._kdf = params.kdf;\n        // AEAD\n        if (typeof params.aead === \"number\") {\n            throw new InvalidParamError(\"AeadId cannot be used\");\n        }\n        this._aead = params.aead;\n        this._suiteId = new Uint8Array(SUITE_ID_HEADER_HPKE);\n        this._suiteId.set(i2Osp(this._kem.id, 2), 4);\n        this._suiteId.set(i2Osp(this._kdf.id, 2), 6);\n        this._suiteId.set(i2Osp(this._aead.id, 2), 8);\n        this._kdf.init(this._suiteId);\n    }\n    /**\n     * Gets the KEM context of the ciphersuite.\n     */\n    get kem() {\n        return this._kem;\n    }\n    /**\n     * Gets the KDF context of the ciphersuite.\n     */\n    get kdf() {\n        return this._kdf;\n    }\n    /**\n     * Gets the AEAD context of the ciphersuite.\n     */\n    get aead() {\n        return this._aead;\n    }\n    /**\n     * Creates an encryption context for a sender.\n     *\n     * If the error occurred, throws {@link DecapError} | {@link ValidationError}.\n     *\n     * @param params A set of parameters for the sender encryption context.\n     * @returns A sender encryption context.\n     * @throws {@link EncapError}, {@link ValidationError}\n     */\n    async createSenderContext(params) {\n        this._validateInputLength(params);\n        await this._setup();\n        const dh = await this._kem.encap(params);\n        let mode;\n        if (params.psk !== undefined) {\n            mode = params.senderKey !== undefined ? Mode.AuthPsk : Mode.Psk;\n        }\n        else {\n            mode = params.senderKey !== undefined ? Mode.Auth : Mode.Base;\n        }\n        return await this._keyScheduleS(mode, dh.sharedSecret, dh.enc, params);\n    }\n    /**\n     * Creates an encryption context for a recipient.\n     *\n     * If the error occurred, throws {@link DecapError}\n     * | {@link DeserializeError} | {@link ValidationError}.\n     *\n     * @param params A set of parameters for the recipient encryption context.\n     * @returns A recipient encryption context.\n     * @throws {@link DecapError}, {@link DeserializeError}, {@link ValidationError}\n     */\n    async createRecipientContext(params) {\n        this._validateInputLength(params);\n        await this._setup();\n        const sharedSecret = await this._kem.decap(params);\n        let mode;\n        if (params.psk !== undefined) {\n            mode = params.senderPublicKey !== undefined ? Mode.AuthPsk : Mode.Psk;\n        }\n        else {\n            mode = params.senderPublicKey !== undefined ? Mode.Auth : Mode.Base;\n        }\n        return await this._keyScheduleR(mode, sharedSecret, params);\n    }\n    /**\n     * Encrypts a message to a recipient.\n     *\n     * If the error occurred, throws `EncapError` | `MessageLimitReachedError` | `SealError` | `ValidationError`.\n     *\n     * @param params A set of parameters for building a sender encryption context.\n     * @param pt A plain text as bytes to be encrypted.\n     * @param aad Additional authenticated data as bytes fed by an application.\n     * @returns A cipher text and an encapsulated key as bytes.\n     * @throws {@link EncapError}, {@link MessageLimitReachedError}, {@link SealError}, {@link ValidationError}\n     */\n    async seal(params, pt, aad = EMPTY.buffer) {\n        const ctx = await this.createSenderContext(params);\n        return {\n            ct: await ctx.seal(pt, aad),\n            enc: ctx.enc,\n        };\n    }\n    /**\n     * Decrypts a message from a sender.\n     *\n     * If the error occurred, throws `DecapError` | `DeserializeError` | `OpenError` | `ValidationError`.\n     *\n     * @param params A set of parameters for building a recipient encryption context.\n     * @param ct An encrypted text as bytes to be decrypted.\n     * @param aad Additional authenticated data as bytes fed by an application.\n     * @returns A decrypted plain text as bytes.\n     * @throws {@link DecapError}, {@link DeserializeError}, {@link OpenError}, {@link ValidationError}\n     */\n    async open(params, ct, aad = EMPTY.buffer) {\n        const ctx = await this.createRecipientContext(params);\n        return await ctx.open(ct, aad);\n    }\n    // private verifyPskInputs(mode: Mode, params: KeyScheduleParams) {\n    //   const gotPsk = (params.psk !== undefined);\n    //   const gotPskId = (params.psk !== undefined && params.psk.id.byteLength > 0);\n    //   if (gotPsk !== gotPskId) {\n    //     throw new Error('Inconsistent PSK inputs');\n    //   }\n    //   if (gotPsk && (mode === Mode.Base || mode === Mode.Auth)) {\n    //     throw new Error('PSK input provided when not needed');\n    //   }\n    //   if (!gotPsk && (mode === Mode.Psk || mode === Mode.AuthPsk)) {\n    //     throw new Error('Missing required PSK input');\n    //   }\n    //   return;\n    // }\n    async _keySchedule(mode, sharedSecret, params) {\n        // Currently, there is no point in executing this function\n        // because this hpke library does not allow users to explicitly specify the mode.\n        //\n        // this.verifyPskInputs(mode, params);\n        const pskId = params.psk === undefined\n            ? EMPTY\n            : new Uint8Array(params.psk.id);\n        const pskIdHash = await this._kdf.labeledExtract(EMPTY.buffer, LABEL_PSK_ID_HASH, pskId);\n        const info = params.info === undefined\n            ? EMPTY\n            : new Uint8Array(params.info);\n        const infoHash = await this._kdf.labeledExtract(EMPTY.buffer, LABEL_INFO_HASH, info);\n        const keyScheduleContext = new Uint8Array(1 + pskIdHash.byteLength + infoHash.byteLength);\n        keyScheduleContext.set(new Uint8Array([mode]), 0);\n        keyScheduleContext.set(new Uint8Array(pskIdHash), 1);\n        keyScheduleContext.set(new Uint8Array(infoHash), 1 + pskIdHash.byteLength);\n        const psk = params.psk === undefined\n            ? EMPTY\n            : new Uint8Array(params.psk.key);\n        const ikm = this._kdf.buildLabeledIkm(LABEL_SECRET, psk)\n            .buffer;\n        const exporterSecretInfo = this._kdf.buildLabeledInfo(LABEL_EXP, keyScheduleContext, this._kdf.hashSize).buffer;\n        const exporterSecret = await this._kdf.extractAndExpand(sharedSecret, ikm, exporterSecretInfo, this._kdf.hashSize);\n        if (this._aead.id === AeadId.ExportOnly) {\n            return { aead: this._aead, exporterSecret: exporterSecret };\n        }\n        const keyInfo = this._kdf.buildLabeledInfo(LABEL_KEY, keyScheduleContext, this._aead.keySize).buffer;\n        const key = await this._kdf.extractAndExpand(sharedSecret, ikm, keyInfo, this._aead.keySize);\n        const baseNonceInfo = this._kdf.buildLabeledInfo(LABEL_BASE_NONCE, keyScheduleContext, this._aead.nonceSize).buffer;\n        const baseNonce = await this._kdf.extractAndExpand(sharedSecret, ikm, baseNonceInfo, this._aead.nonceSize);\n        return {\n            aead: this._aead,\n            exporterSecret: exporterSecret,\n            key: key,\n            baseNonce: new Uint8Array(baseNonce),\n            seq: 0,\n        };\n    }\n    async _keyScheduleS(mode, sharedSecret, enc, params) {\n        const res = await this._keySchedule(mode, sharedSecret, params);\n        if (res.key === undefined) {\n            return new SenderExporterContextImpl(this._api, this._kdf, res.exporterSecret, enc);\n        }\n        return new SenderContextImpl(this._api, this._kdf, res, enc);\n    }\n    async _keyScheduleR(mode, sharedSecret, params) {\n        const res = await this._keySchedule(mode, sharedSecret, params);\n        if (res.key === undefined) {\n            return new RecipientExporterContextImpl(this._api, this._kdf, res.exporterSecret);\n        }\n        return new RecipientContextImpl(this._api, this._kdf, res);\n    }\n    _validateInputLength(params) {\n        if (params.info !== undefined &&\n            params.info.byteLength > INFO_LENGTH_LIMIT) {\n            throw new InvalidParamError(\"Too long info\");\n        }\n        if (params.psk !== undefined) {\n            if (params.psk.key.byteLength < MINIMUM_PSK_LENGTH) {\n                throw new InvalidParamError(`PSK must have at least ${MINIMUM_PSK_LENGTH} bytes`);\n            }\n            if (params.psk.key.byteLength > INPUT_LENGTH_LIMIT) {\n                throw new InvalidParamError(\"Too long psk.key\");\n            }\n            if (params.psk.id.byteLength > INPUT_LENGTH_LIMIT) {\n                throw new InvalidParamError(\"Too long psk.id\");\n            }\n        }\n        return;\n    }\n}\n","import { Dhkem, Ec, HkdfSha256Native, HkdfSha384Native, HkdfSha512Native, KemId, } from \"@hpke/common\";\nexport class DhkemP256HkdfSha256Native extends Dhkem {\n    constructor() {\n        const kdf = new HkdfSha256Native();\n        const prim = new Ec(KemId.DhkemP256HkdfSha256, kdf);\n        super(KemId.DhkemP256HkdfSha256, prim, kdf);\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KemId.DhkemP256HkdfSha256\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 65\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 65\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 32\n        });\n    }\n}\nexport class DhkemP384HkdfSha384Native extends Dhkem {\n    constructor() {\n        const kdf = new HkdfSha384Native();\n        const prim = new Ec(KemId.DhkemP384HkdfSha384, kdf);\n        super(KemId.DhkemP384HkdfSha384, prim, kdf);\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KemId.DhkemP384HkdfSha384\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 48\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 97\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 97\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 48\n        });\n    }\n}\nexport class DhkemP521HkdfSha512Native extends Dhkem {\n    constructor() {\n        const kdf = new HkdfSha512Native();\n        const prim = new Ec(KemId.DhkemP521HkdfSha512, kdf);\n        super(KemId.DhkemP521HkdfSha512, prim, kdf);\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: KemId.DhkemP521HkdfSha512\n        });\n        Object.defineProperty(this, \"secretSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 64\n        });\n        Object.defineProperty(this, \"encSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 133\n        });\n        Object.defineProperty(this, \"publicKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 133\n        });\n        Object.defineProperty(this, \"privateKeySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 64\n        });\n    }\n}\n","import { HkdfSha256Native, HkdfSha384Native, HkdfSha512Native, } from \"@hpke/common\";\nimport { CipherSuiteNative } from \"./cipherSuiteNative.js\";\nimport { DhkemP256HkdfSha256Native, DhkemP384HkdfSha384Native, DhkemP521HkdfSha512Native, } from \"./kems/dhkemNative.js\";\n/**\n * The Hybrid Public Key Encryption (HPKE) ciphersuite,\n * which is implemented using only\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n *\n * This class is the same as\n * {@link https://jsr.io/@hpke/core/doc/~/CipherSuiteNative | @hpke/core#CipherSuiteNative} as follows:\n * which supports only the ciphersuites that can be implemented on the native\n * {@link https://www.w3.org/TR/WebCryptoAPI/ | Web Cryptography API}.\n * Therefore, the following cryptographic algorithms are not supported for now:\n * - `DHKEM(X25519, HKDF-SHA256)`\n * - `DHKEM(X448, HKDF-SHA512)`\n * - `ChaCha20Poly1305`\n *\n * In addtion, the HKDF functions contained in this `CipherSuiteNative`\n * class can only derive keys of the same length as the `hashSize`.\n *\n * If you want to use the unsupported cryptographic algorithms\n * above or derive keys longer than the `hashSize`,\n * please use {@link https://jsr.io/@hpke/hpke-js/doc/~/CipherSuite | hpke-js#CipherSuite}.\n *\n * This class provides following functions:\n *\n * - Creates encryption contexts both for senders and recipients.\n *     - {@link createSenderContext}\n *     - {@link createRecipientContext}\n * - Provides single-shot encryption API.\n *     - {@link seal}\n *     - {@link open}\n *\n * The calling of the constructor of this class is the starting\n * point for HPKE operations for both senders and recipients.\n *\n * @example Use only ciphersuites supported by Web Cryptography API.\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n *   CipherSuite,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n *\n * @example Use a ciphersuite which is currently not supported by Web Cryptography API.\n *\n * ```ts\n * import { Aes128Gcm, HkdfSha256, CipherSuite } from \"@hpke/core\";\n * import { DhkemX25519HkdfSha256 } from \"@hpke/dhkem-x25519\";\n * const suite = new CipherSuite({\n *   kem: new DhkemX25519HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class CipherSuite extends CipherSuiteNative {\n}\n/**\n * The DHKEM(P-256, HKDF-SHA256) for HPKE KEM implementing {@link KemInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP256HkdfSha256`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class DhkemP256HkdfSha256 extends DhkemP256HkdfSha256Native {\n}\n/**\n * The DHKEM(P-384, HKDF-SHA384) for HPKE KEM implementing {@link KemInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP384HkdfSha384`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP384HkdfSha384,\n *   HkdfSha384,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP384HkdfSha384(),\n *   kdf: new HkdfSha384(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class DhkemP384HkdfSha384 extends DhkemP384HkdfSha384Native {\n}\n/**\n * The DHKEM(P-521, HKDF-SHA512) for HPKE KEM implementing {@link KemInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KemId.DhkemP521HkdfSha512`\n * as follows:\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes256Gcm,\n *   CipherSuite,\n *   DhkemP521HkdfSha512,\n *   HkdfSha512,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP521HkdfSha512(),\n *   kdf: new HkdfSha512(),\n *   aead: new Aes256Gcm(),\n * });\n * ```\n */\nexport class DhkemP521HkdfSha512 extends DhkemP521HkdfSha512Native {\n}\n/**\n * The HKDF-SHA256 for HPKE KDF implementing {@link KdfInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha256`.\n *\n * The KDF class can only derive keys of the same length as the `hashSize`.\n * If you want to derive keys longer than the `hashSize`,\n * please use {@link https://jsr.io/@hpke/hpke-js/doc/~/CipherSuite | hpke-js#CipherSuite}.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP256HkdfSha256,\n *   HkdfSha256,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP256HkdfSha256(),\n *   kdf: new HkdfSha256(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class HkdfSha256 extends HkdfSha256Native {\n}\n/**\n * The HKDF-SHA384 for HPKE KDF implementing {@link KdfInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha384`.\n *\n * The KDF class can only derive keys of the same length as the `hashSize`.\n * If you want to derive keys longer than the `hashSize`,\n * please use {@link https://jsr.io/@hpke/hpke-js/doc/~/CipherSuite | hpke-js#CipherSuite}.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes128Gcm,\n *   CipherSuite,\n *   DhkemP384HkdfSha384,\n *   HkdfSha384,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP384HkdfSha384(),\n *   kdf: new HkdfSha384(),\n *   aead: new Aes128Gcm(),\n * });\n * ```\n */\nexport class HkdfSha384 extends HkdfSha384Native {\n}\n/**\n * The HKDF-SHA512 for HPKE KDF implementing {@link KdfInterface}.\n *\n * When using `@hpke/core`, the instance of this class must be specified\n * to the `kem` parameter of {@link CipherSuiteParams} instead of `KdfId.HkdfSha512`.\n *\n * The KDF class can only derive keys of the same length as the `hashSize`.\n * If you want to derive keys longer than the `hashSize`,\n * please use {@link https://jsr.io/@hpke/hpke-js/doc/~/CipherSuite | hpke-js#CipherSuite}.\n *\n * @example\n *\n * ```ts\n * import {\n *   Aes256Gcm,\n *   CipherSuite,\n *   DhkemP521HkdfSha512,\n *   HkdfSha512,\n * } from \"@hpke/core\";\n *\n * const suite = new CipherSuite({\n *   kem: new DhkemP521HkdfSha512(),\n *   kdf: new HkdfSha512(),\n *   aead: new Aes256Gcm(),\n * });\n * ```\n */\nexport class HkdfSha512 extends HkdfSha512Native {\n}\n","import { base64UrlToBytes, DeriveKeyPairError, DeserializeError, EMPTY, KEM_USAGES, LABEL_DKP_PRK, LABEL_SK, NativeAlgorithm, NotSupportedError, SerializeError, } from \"@hpke/common\";\nconst ALG_NAME = \"X25519\";\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_X25519 = new Uint8Array([\n    0x30, 0x2e, 0x02, 0x01, 0x00, 0x30, 0x05, 0x06,\n    0x03, 0x2b, 0x65, 0x6e, 0x04, 0x22, 0x04, 0x20,\n]);\nexport class X25519 extends NativeAlgorithm {\n    constructor(hkdf) {\n        super();\n        Object.defineProperty(this, \"_hkdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_alg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nPk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nSk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nDh\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pkcs8AlgId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._alg = { name: ALG_NAME };\n        this._hkdf = hkdf;\n        this._nPk = 32;\n        this._nSk = 32;\n        this._nDh = 32;\n        this._pkcs8AlgId = PKCS8_ALG_ID_X25519;\n    }\n    async serializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._api.exportKey(\"raw\", key);\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, true);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async serializePrivateKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            if (!(\"d\" in jwk)) {\n                throw new Error(\"Not private key\");\n            }\n            return base64UrlToBytes(jwk[\"d\"]).buffer;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePrivateKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, false);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async importKey(format, key, isPublic) {\n        await this._setup();\n        try {\n            if (format === \"raw\") {\n                return await this._importRawKey(key, isPublic);\n            }\n            // jwk\n            if (key instanceof ArrayBuffer) {\n                throw new Error(\"Invalid jwk key format\");\n            }\n            return await this._importJWK(key, isPublic);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async generateKeyPair() {\n        await this._setup();\n        try {\n            return await this._api.generateKey(ALG_NAME, true, KEM_USAGES);\n        }\n        catch (e) {\n            throw new NotSupportedError(e);\n        }\n    }\n    async deriveKeyPair(ikm) {\n        await this._setup();\n        try {\n            const dkpPrk = await this._hkdf.labeledExtract(EMPTY.buffer, LABEL_DKP_PRK, new Uint8Array(ikm));\n            const rawSk = await this._hkdf.labeledExpand(dkpPrk, LABEL_SK, EMPTY, this._nSk);\n            const rawSkBytes = new Uint8Array(rawSk);\n            const sk = await this._deserializePkcs8Key(rawSkBytes);\n            rawSkBytes.fill(0);\n            return {\n                privateKey: sk,\n                publicKey: await this.derivePublicKey(sk),\n            };\n        }\n        catch (e) {\n            throw new DeriveKeyPairError(e);\n        }\n    }\n    async derivePublicKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            delete jwk[\"d\"];\n            delete jwk[\"key_ops\"];\n            return await this._api.importKey(\"jwk\", jwk, this._alg, true, []);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async dh(sk, pk) {\n        await this._setup();\n        try {\n            const bits = await this._api.deriveBits({\n                name: ALG_NAME,\n                public: pk,\n            }, sk, this._nDh * 8);\n            return bits;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async _importRawKey(key, isPublic) {\n        if (isPublic && key.byteLength !== this._nPk) {\n            throw new Error(\"Invalid public key for the ciphersuite\");\n        }\n        if (!isPublic && key.byteLength !== this._nSk) {\n            throw new Error(\"Invalid private key for the ciphersuite\");\n        }\n        if (isPublic) {\n            return await this._api.importKey(\"raw\", key, this._alg, true, []);\n        }\n        return await this._deserializePkcs8Key(new Uint8Array(key));\n    }\n    async _importJWK(key, isPublic) {\n        if (typeof key.kty === \"undefined\" || key.kty !== \"OKP\") {\n            throw new Error(`Invalid kty: ${key.crv}`);\n        }\n        if (typeof key.crv === \"undefined\" || key.crv !== ALG_NAME) {\n            throw new Error(`Invalid crv: ${key.crv}`);\n        }\n        if (isPublic) {\n            if (typeof key.d !== \"undefined\") {\n                throw new Error(\"Invalid key: `d` should not be set\");\n            }\n            return await this._api.importKey(\"jwk\", key, this._alg, true, []);\n        }\n        if (typeof key.d === \"undefined\") {\n            throw new Error(\"Invalid key: `d` not found\");\n        }\n        return await this._api.importKey(\"jwk\", key, this._alg, true, KEM_USAGES);\n    }\n    async _deserializePkcs8Key(k) {\n        const pkcs8Key = new Uint8Array(this._pkcs8AlgId.length + k.length);\n        pkcs8Key.set(this._pkcs8AlgId, 0);\n        pkcs8Key.set(k, this._pkcs8AlgId.length);\n        return await this._api.importKey(\"pkcs8\", pkcs8Key, this._alg, true, KEM_USAGES);\n    }\n}\n","import { base64UrlToBytes, DeriveKeyPairError, DeserializeError, EMPTY, KEM_USAGES, LABEL_DKP_PRK, LABEL_SK, NativeAlgorithm, NotSupportedError, SerializeError, } from \"@hpke/common\";\nconst ALG_NAME = \"X448\";\n// deno-fmt-ignore\nconst PKCS8_ALG_ID_X448 = new Uint8Array([\n    0x30, 0x46, 0x02, 0x01, 0x00, 0x30, 0x05, 0x06,\n    0x03, 0x2b, 0x65, 0x6f, 0x04, 0x3a, 0x04, 0x38,\n]);\nexport class X448 extends NativeAlgorithm {\n    constructor(hkdf) {\n        super();\n        Object.defineProperty(this, \"_hkdf\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_alg\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nPk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nSk\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nDh\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pkcs8AlgId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._alg = { name: ALG_NAME };\n        this._hkdf = hkdf;\n        this._nPk = 56;\n        this._nSk = 56;\n        this._nDh = 56;\n        this._pkcs8AlgId = PKCS8_ALG_ID_X448;\n    }\n    async serializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._api.exportKey(\"raw\", key);\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePublicKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, true);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async serializePrivateKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            if (!(\"d\" in jwk)) {\n                throw new Error(\"Not private key\");\n            }\n            return base64UrlToBytes(jwk[\"d\"]).buffer;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async deserializePrivateKey(key) {\n        await this._setup();\n        try {\n            return await this._importRawKey(key, false);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async importKey(format, key, isPublic) {\n        await this._setup();\n        try {\n            if (format === \"raw\") {\n                return await this._importRawKey(key, isPublic);\n            }\n            // jwk\n            if (key instanceof ArrayBuffer) {\n                throw new Error(\"Invalid jwk key format\");\n            }\n            return await this._importJWK(key, isPublic);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async generateKeyPair() {\n        await this._setup();\n        try {\n            return await this._api.generateKey(ALG_NAME, true, KEM_USAGES);\n        }\n        catch (e) {\n            throw new NotSupportedError(e);\n        }\n    }\n    async deriveKeyPair(ikm) {\n        await this._setup();\n        try {\n            const dkpPrk = await this._hkdf.labeledExtract(EMPTY.buffer, LABEL_DKP_PRK, new Uint8Array(ikm));\n            const rawSk = await this._hkdf.labeledExpand(dkpPrk, LABEL_SK, EMPTY, this._nSk);\n            const rawSkBytes = new Uint8Array(rawSk);\n            const sk = await this._deserializePkcs8Key(rawSkBytes);\n            rawSkBytes.fill(0);\n            return {\n                privateKey: sk,\n                publicKey: await this.derivePublicKey(sk),\n            };\n        }\n        catch (e) {\n            throw new DeriveKeyPairError(e);\n        }\n    }\n    async derivePublicKey(key) {\n        await this._setup();\n        try {\n            const jwk = await this._api.exportKey(\"jwk\", key);\n            delete jwk[\"d\"];\n            delete jwk[\"key_ops\"];\n            return await this._api.importKey(\"jwk\", jwk, this._alg, true, []);\n        }\n        catch (e) {\n            throw new DeserializeError(e);\n        }\n    }\n    async dh(sk, pk) {\n        await this._setup();\n        try {\n            const bits = await this._api.deriveBits({\n                name: ALG_NAME,\n                public: pk,\n            }, sk, this._nDh * 8);\n            return bits;\n        }\n        catch (e) {\n            throw new SerializeError(e);\n        }\n    }\n    async _importRawKey(key, isPublic) {\n        if (isPublic && key.byteLength !== this._nPk) {\n            throw new Error(\"Invalid public key for the ciphersuite\");\n        }\n        if (!isPublic && key.byteLength !== this._nSk) {\n            throw new Error(\"Invalid private key for the ciphersuite\");\n        }\n        if (isPublic) {\n            return await this._api.importKey(\"raw\", key, this._alg, true, []);\n        }\n        return await this._deserializePkcs8Key(new Uint8Array(key));\n    }\n    async _importJWK(key, isPublic) {\n        if (typeof key.kty === \"undefined\" || key.kty !== \"OKP\") {\n            throw new Error(`Invalid kty: ${key.crv}`);\n        }\n        if (typeof key.crv === \"undefined\" || key.crv !== ALG_NAME) {\n            throw new Error(`Invalid crv: ${key.crv}`);\n        }\n        if (isPublic) {\n            if (typeof key.d !== \"undefined\") {\n                throw new Error(\"Invalid key: `d` should not be set\");\n            }\n            return await this._api.importKey(\"jwk\", key, this._alg, true, []);\n        }\n        if (typeof key.d === \"undefined\") {\n            throw new Error(\"Invalid key: `d` not found\");\n        }\n        return await this._api.importKey(\"jwk\", key, this._alg, true, KEM_USAGES);\n    }\n    async _deserializePkcs8Key(k) {\n        const pkcs8Key = new Uint8Array(this._pkcs8AlgId.length + k.length);\n        pkcs8Key.set(this._pkcs8AlgId, 0);\n        pkcs8Key.set(k, this._pkcs8AlgId.length);\n        return await this._api.importKey(\"pkcs8\", pkcs8Key, this._alg, true, KEM_USAGES);\n    }\n}\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n    const x = ALPHABET.charAt(z);\n    ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            return 'Invalid prefix (' + prefix + ')';\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            return 'Excess padding';\n        if ((value << (outBits - bits)) & maxV)\n            return 'Non-zero padding';\n    }\n    return result;\n}\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n}\nfunction fromWords(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n    throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n    let ENCODING_CONST;\n    if (encoding === 'bech32') {\n        ENCODING_CONST = 1;\n    }\n    else {\n        ENCODING_CONST = 0x2bc830a3;\n    }\n    function encode(prefix, words, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (prefix.length + 7 + words.length > LIMIT)\n            throw new TypeError('Exceeds length limit');\n        prefix = prefix.toLowerCase();\n        // determine chk mod\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            throw new Error(chk);\n        let result = prefix + '1';\n        for (let i = 0; i < words.length; ++i) {\n            const x = words[i];\n            if (x >> 5 !== 0)\n                throw new Error('Non 5-bit word');\n            chk = polymodStep(chk) ^ x;\n            result += ALPHABET.charAt(x);\n        }\n        for (let i = 0; i < 6; ++i) {\n            chk = polymodStep(chk);\n        }\n        chk ^= ENCODING_CONST;\n        for (let i = 0; i < 6; ++i) {\n            const v = (chk >> ((5 - i) * 5)) & 0x1f;\n            result += ALPHABET.charAt(v);\n        }\n        return result;\n    }\n    function __decode(str, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (str.length < 8)\n            return str + ' too short';\n        if (str.length > LIMIT)\n            return 'Exceeds length limit';\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        const uppered = str.toUpperCase();\n        if (str !== lowered && str !== uppered)\n            return 'Mixed-case string ' + str;\n        str = lowered;\n        const split = str.lastIndexOf('1');\n        if (split === -1)\n            return 'No separator character for ' + str;\n        if (split === 0)\n            return 'Missing prefix for ' + str;\n        const prefix = str.slice(0, split);\n        const wordChars = str.slice(split + 1);\n        if (wordChars.length < 6)\n            return 'Data too short';\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            return chk;\n        const words = [];\n        for (let i = 0; i < wordChars.length; ++i) {\n            const c = wordChars.charAt(i);\n            const v = ALPHABET_MAP[c];\n            if (v === undefined)\n                return 'Unknown character ' + c;\n            chk = polymodStep(chk) ^ v;\n            // not in the checksum?\n            if (i + 6 >= wordChars.length)\n                continue;\n            words.push(v);\n        }\n        if (chk !== ENCODING_CONST)\n            return 'Invalid checksum for ' + str;\n        return { prefix, words };\n    }\n    function decodeUnsafe(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n    }\n    function decode(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n        throw new Error(res);\n    }\n    return {\n        decodeUnsafe,\n        decode,\n        encode,\n        toWords,\n        fromWordsUnsafe,\n        fromWords,\n    };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');\n","/**\n * Audited & minimal JS implementation of hash functions, MACs and KDFs. Check out individual modules.\n * @module\n * @example\n```js\nimport {\n  sha256, sha384, sha512, sha224, sha512_224, sha512_256\n} from '@noble/hashes/sha2.js';\nimport {\n  sha3_224, sha3_256, sha3_384, sha3_512,\n  keccak_224, keccak_256, keccak_384, keccak_512,\n  shake128, shake256\n} from '@noble/hashes/sha3.js';\nimport {\n  cshake128, cshake256,\n  turboshake128, turboshake256,\n  kt128, kt256,\n  kmac128, kmac256,\n  tuplehash256, parallelhash256,\n  keccakprg\n} from '@noble/hashes/sha3-addons.js';\nimport { blake3 } from '@noble/hashes/blake3.js';\nimport { blake2b, blake2s } from '@noble/hashes/blake2.js';\nimport { hmac } from '@noble/hashes/hmac.js';\nimport { hkdf } from '@noble/hashes/hkdf.js';\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2.js';\nimport { scrypt, scryptAsync } from '@noble/hashes/scrypt.js';\nimport { md5, ripemd160, sha1 } from '@noble/hashes/legacy.js';\nimport * as utils from '@noble/hashes/utils.js';\n```\n */\nthrow new Error('root module cannot be imported: import submodules instead. Check out README');\nexport {};\n//# sourceMappingURL=index.js.map","/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 5KB JS implementation of ed25519 EdDSA signatures.\n * Compliant with RFC8032, FIPS 186-5 & ZIP215.\n * @module\n * @example\n * ```js\nimport * as ed from '@noble/ed25519';\n(async () => {\n  const secretKey = ed.utils.randomSecretKey();\n  const message = Uint8Array.from([0xab, 0xbc, 0xcd, 0xde]);\n  const pubKey = await ed.getPublicKeyAsync(secretKey); // Sync methods are also present\n  const signature = await ed.signAsync(message, secretKey);\n  const isValid = await ed.verifyAsync(signature, message, pubKey);\n})();\n```\n */\n/**\n * Curve params. ed25519 is twisted edwards curve. Equation is x + y = -a + dxy.\n * * P = `2n**255n - 19n` // field over which calculations are done\n * * N = `2n**252n + 27742317777372353535851937790883648493n` // group order, amount of curve points\n * * h = 8 // cofactor\n * * a = `Fp.create(BigInt(-1))` // equation param\n * * d = -121665/121666 a.k.a. `Fp.neg(121665 * Fp.inv(121666))` // equation param\n * * Gx, Gy are coordinates of Generator / base point\n */\nconst ed25519_CURVE = {\n    p: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,\n    n: 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,\n    h: 8n,\n    a: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,\n    d: 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,\n    Gx: 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,\n    Gy: 0x6666666666666666666666666666666666666666666666666666666666666658n,\n};\nconst { p: P, n: N, Gx, Gy, a: _a, d: _d, h } = ed25519_CURVE;\nconst L = 32; // field / group byte length\nconst L2 = 64;\n// Helpers and Precomputes sections are reused between libraries\n// ## Helpers\n// ----------\nconst captureTrace = (...args) => {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n};\nconst err = (message = '') => {\n    const e = new Error(message);\n    captureTrace(e, err);\n    throw e;\n};\nconst isBig = (n) => typeof n === 'bigint'; // is big integer\nconst isStr = (s) => typeof s === 'string'; // is string\nconst isBytes = (a) => a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n/** Asserts something is Uint8Array. */\nconst abytes = (value, length, title = '') => {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        err(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n};\n/** create Uint8Array */\nconst u8n = (len) => new Uint8Array(len);\nconst u8fr = (buf) => Uint8Array.from(buf);\nconst padh = (n, pad) => n.toString(16).padStart(pad, '0');\nconst bytesToHex = (b) => Array.from(abytes(b))\n    .map((e) => padh(e, 2))\n    .join('');\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst hexToBytes = (hex) => {\n    const e = 'hex invalid';\n    if (!isStr(hex))\n        return err(e);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\nconst cr = () => globalThis?.crypto; // WebCrypto is available in all modern environments\nconst subtle = () => cr()?.subtle ?? err('crypto.subtle must be defined, consider polyfill');\n// prettier-ignore\nconst concatBytes = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + abytes(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\n/** WebCrypto OS-level CSPRNG (random number generator). Will throw when not available. */\nconst randomBytes = (len = L) => {\n    const c = cr();\n    return c.getRandomValues(u8n(len));\n};\nconst big = BigInt;\nconst assertRange = (n, min, max, msg = 'bad number: out of range') => (isBig(n) && min <= n && n < max ? n : err(msg));\n/** modular division */\nconst M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n};\nconst modN = (a) => M(a, N);\n/** Modular inversion using euclidean GCD (non-CT). No negative exponent for now. */\n// prettier-ignore\nconst invert = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md);\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) {\n        const q = b / a, r = b % a;\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst callHash = (name) => {\n    // @ts-ignore\n    const fn = hashes[name];\n    if (typeof fn !== 'function')\n        err('hashes.' + name + ' not set');\n    return fn;\n};\nconst hash = (msg) => callHash('sha512')(msg);\nconst apoint = (p) => (p instanceof Point ? p : err('Point expected'));\n// ## End of Helpers\n// -----------------\nconst B256 = 2n ** 256n;\n/** Point in XYZT extended coordinates. */\nclass Point {\n    static BASE;\n    static ZERO;\n    X;\n    Y;\n    Z;\n    T;\n    constructor(X, Y, Z, T) {\n        const max = B256;\n        this.X = assertRange(X, 0n, max);\n        this.Y = assertRange(Y, 0n, max);\n        this.Z = assertRange(Z, 1n, max);\n        this.T = assertRange(T, 0n, max);\n        Object.freeze(this);\n    }\n    static CURVE() {\n        return ed25519_CURVE;\n    }\n    static fromAffine(p) {\n        return new Point(p.x, p.y, 1n, M(p.x * p.y));\n    }\n    /** RFC8032 5.1.3: Uint8Array to Point. */\n    static fromBytes(hex, zip215 = false) {\n        const d = _d;\n        // Copy array to not mess it up.\n        const normed = u8fr(abytes(hex, L));\n        // adjust first LE byte = last BE byte\n        const lastByte = hex[31];\n        normed[31] = lastByte & ~0x80;\n        const y = bytesToNumLE(normed);\n        // zip215=true:           0 <= y < 2^256\n        // zip215=false, RFC8032: 0 <= y < 2^255-19\n        const max = zip215 ? B256 : P;\n        assertRange(y, 0n, max);\n        const y2 = M(y * y); // y\n        const u = M(y2 - 1n); // u=y-1\n        const v = M(d * y2 + 1n); // v=dy+1\n        let { isValid, value: x } = uvRatio(u, v); // (uv)(uv)^(p-5)/8; square root\n        if (!isValid)\n            err('bad point: y not sqrt'); // not square root: bad point\n        const isXOdd = (x & 1n) === 1n; // adjust sign of x coordinate\n        const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n        if (!zip215 && x === 0n && isLastByteOdd)\n            err('bad point: x==0, isLastByteOdd'); // x=0, x_0=1\n        if (isLastByteOdd !== isXOdd)\n            x = M(-x);\n        return new Point(x, y, 1n, M(x * y)); // Z=1, T=xy\n    }\n    static fromHex(hex, zip215) {\n        return Point.fromBytes(hexToBytes(hex), zip215);\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n        const a = _a;\n        const d = _d;\n        const p = this;\n        if (p.is0())\n            return err('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax + y = 1 + dxy\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n        const { X, Y, Z, T } = p;\n        const X2 = M(X * X); // X\n        const Y2 = M(Y * Y); // Y\n        const Z2 = M(Z * Z); // Z\n        const Z4 = M(Z2 * Z2); // Z\n        const aX2 = M(X2 * a); // aX\n        const left = M(Z2 * M(aX2 + Y2)); // (aX + Y)Z\n        const right = M(Z4 + M(d * M(X2 * Y2))); // Z + dXY\n        if (left !== right)\n            return err('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = M(X * Y);\n        const ZT = M(Z * T);\n        if (XY !== ZT)\n            return err('bad point: equation left != right (2)');\n        return this;\n    }\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n        const { X: X1, Y: Y1, Z: Z1 } = this;\n        const { X: X2, Y: Y2, Z: Z2 } = apoint(other); // checks class equality\n        const X1Z2 = M(X1 * Z2);\n        const X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2);\n        const Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n        return this.equals(I);\n    }\n    /** Flip point over y coordinate. */\n    negate() {\n        return new Point(M(-this.X), this.Y, this.Z, M(-this.T));\n    }\n    /** Point doubling. Complete formula. Cost: `4M + 4S + 1*a + 6add + 1*2`. */\n    double() {\n        const { X: X1, Y: Y1, Z: Z1 } = this;\n        const a = _a;\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        const A = M(X1 * X1);\n        const B = M(Y1 * Y1);\n        const C = M(2n * M(Z1 * Z1));\n        const D = M(a * A);\n        const x1y1 = X1 + Y1;\n        const E = M(M(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    /** Point addition. Complete formula. Cost: `8M + 1*k + 8add + 1*2`. */\n    add(other) {\n        const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n        const { X: X2, Y: Y2, Z: Z2, T: T2 } = apoint(other); // doesn't check if other on-curve\n        const a = _a;\n        const d = _d;\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n        const A = M(X1 * X2);\n        const B = M(Y1 * Y2);\n        const C = M(T1 * d * T2);\n        const D = M(Z1 * Z2);\n        const E = M((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = M(D - C);\n        const G = M(D + C);\n        const H = M(B - a * A);\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new Point(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(apoint(other).negate());\n    }\n    /**\n     * Point-by-scalar multiplication. Scalar must be in range 1 <= n < CURVE.n.\n     * Uses {@link wNAF} for base point.\n     * Uses fake point to mitigate side-channel leakage.\n     * @param n scalar by which point is multiplied\n     * @param safe safe mode guards against timing attacks; unsafe mode is faster\n     */\n    multiply(n, safe = true) {\n        if (!safe && (n === 0n || this.is0()))\n            return I;\n        assertRange(n, 1n, N);\n        if (n === 1n)\n            return this;\n        if (this.equals(G))\n            return wNAF(n).p;\n        // init result point & fake point\n        let p = I;\n        let f = G;\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) {\n            // if bit is present, add to point\n            // if not present, add to fake, for timing safety\n            if (n & 1n)\n                p = p.add(d);\n            else if (safe)\n                f = f.add(d);\n        }\n        return p;\n    }\n    multiplyUnsafe(scalar) {\n        return this.multiply(scalar, false);\n    }\n    /** Convert point to 2d xy affine point. (X, Y, Z)  (x=X/Z, y=Y/Z) */\n    toAffine() {\n        const { X, Y, Z } = this;\n        // fast-paths for ZERO point OR Z=1\n        if (this.equals(I))\n            return { x: 0n, y: 1n };\n        const iz = invert(Z, P);\n        // (Z * Z^-1) must be 1, otherwise bad math\n        if (M(Z * iz) !== 1n)\n            err('invalid inverse');\n        // x = X*Z^-1; y = Y*Z^-1\n        const x = M(X * iz);\n        const y = M(Y * iz);\n        return { x, y };\n    }\n    toBytes() {\n        const { x, y } = this.assertValidity().toAffine();\n        const b = numTo32bLE(y);\n        // store sign in first LE byte\n        b[31] |= x & 1n ? 0x80 : 0;\n        return b;\n    }\n    toHex() {\n        return bytesToHex(this.toBytes());\n    }\n    clearCofactor() {\n        return this.multiply(big(h), false);\n    }\n    isSmallOrder() {\n        return this.clearCofactor().is0();\n    }\n    isTorsionFree() {\n        // Multiply by big number N. We can't `mul(N)` because of checks. Instead, we `mul(N/2)*2+1`\n        let p = this.multiply(N / 2n, false).double();\n        if (N % 2n)\n            p = p.add(this);\n        return p.is0();\n    }\n}\n/** Generator / base point */\nconst G = new Point(Gx, Gy, 1n, M(Gx * Gy));\n/** Identity / zero point */\nconst I = new Point(0n, 1n, 1n, 0n);\n// Static aliases\nPoint.BASE = G;\nPoint.ZERO = I;\nconst numTo32bLE = (num) => hexToBytes(padh(assertRange(num, 0n, B256), L2)).reverse();\nconst bytesToNumLE = (b) => big('0x' + bytesToHex(u8fr(abytes(b)).reverse()));\nconst pow2 = (x, power) => {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n};\n// prettier-ignore\nconst pow_2_252_3 = (x) => {\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n};\nconst RM1 = 0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n; // -1\n// for sqrt comp\n// prettier-ignore\nconst uvRatio = (u, v) => {\n    const v3 = M(v * v * v); // v\n    const v7 = M(v3 * v3 * v); // v\n    const pow = pow_2_252_3(u * v7).pow_p_5_8; // (uv)^(p-5)/8\n    let x = M(u * v3 * pow); // (uv)(uv)^(p-5)/8\n    const vx2 = M(v * x * x); // vx\n    const root1 = x; // First root candidate\n    const root2 = M(x * RM1); // Second root candidate; RM1 is -1\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === M(-u); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === M(-u * RM1); // There is no valid root, vx = -u-1\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((M(x) & 1n) === 1n)\n        x = M(-x); // edIsNegative\n    return { isValid: useRoot1 || useRoot2, value: x };\n};\n// N == L, just weird naming\nconst modL_LE = (hash) => modN(bytesToNumLE(hash)); // modulo L; but little-endian\n/** hashes.sha512 should conform to the interface. */\n// TODO: rename\nconst sha512a = (...m) => hashes.sha512Async(concatBytes(...m)); // Async SHA512\nconst sha512s = (...m) => callHash('sha512')(concatBytes(...m));\n// RFC8032 5.1.5\nconst hash2extK = (hashed) => {\n    // slice creates a copy, unlike subarray\n    const head = hashed.slice(0, L);\n    head[0] &= 248; // Clamp bits: 0b1111_1000\n    head[31] &= 127; // 0b0111_1111\n    head[31] |= 64; // 0b0100_0000\n    const prefix = hashed.slice(L, L2); // secret key \"prefix\"\n    const scalar = modL_LE(head); // modular division over curve order\n    const point = G.multiply(scalar); // public key point\n    const pointBytes = point.toBytes(); // point serialized to Uint8Array\n    return { head, prefix, scalar, point, pointBytes };\n};\n// RFC8032 5.1.5; getPublicKey async, sync. Hash priv key and extract point.\nconst getExtendedPublicKeyAsync = (secretKey) => sha512a(abytes(secretKey, L)).then(hash2extK);\nconst getExtendedPublicKey = (secretKey) => hash2extK(sha512s(abytes(secretKey, L)));\n/** Creates 32-byte ed25519 public key from 32-byte secret key. Async. */\nconst getPublicKeyAsync = (secretKey) => getExtendedPublicKeyAsync(secretKey).then((p) => p.pointBytes);\n/** Creates 32-byte ed25519 public key from 32-byte secret key. To use, set `hashes.sha512` first. */\nconst getPublicKey = (priv) => getExtendedPublicKey(priv).pointBytes;\nconst hashFinishA = (res) => sha512a(res.hashable).then(res.finish);\nconst hashFinishS = (res) => res.finish(sha512s(res.hashable));\n// Code, shared between sync & async sign\nconst _sign = (e, rBytes, msg) => {\n    const { pointBytes: P, scalar: s } = e;\n    const r = modL_LE(rBytes); // r was created outside, reduce it modulo L\n    const R = G.multiply(r).toBytes(); // R = [r]B\n    const hashable = concatBytes(R, P, msg); // dom2(F, C) || R || A || PH(M)\n    const finish = (hashed) => {\n        // k = SHA512(dom2(F, C) || R || A || PH(M))\n        const S = modN(r + modL_LE(hashed) * s); // S = (r + k * s) mod L; 0 <= s < l\n        return abytes(concatBytes(R, numTo32bLE(S)), L2); // 64-byte sig: 32b R.x + 32b LE(S)\n    };\n    return { hashable, finish };\n};\n/**\n * Signs message using secret key. Async.\n * Follows RFC8032 5.1.6.\n */\nconst signAsync = async (message, secretKey) => {\n    const m = abytes(message);\n    const e = await getExtendedPublicKeyAsync(secretKey);\n    const rBytes = await sha512a(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinishA(_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\n/**\n * Signs message using secret key. To use, set `hashes.sha512` first.\n * Follows RFC8032 5.1.6.\n */\nconst sign = (message, secretKey) => {\n    const m = abytes(message);\n    const e = getExtendedPublicKey(secretKey);\n    const rBytes = sha512s(e.prefix, m); // r = SHA512(dom2(F, C) || prefix || PH(M))\n    return hashFinishS(_sign(e, rBytes, m)); // gen R, k, S, then 64-byte signature\n};\nconst defaultVerifyOpts = { zip215: true };\nconst _verify = (sig, msg, pub, opts = defaultVerifyOpts) => {\n    sig = abytes(sig, L2); // Signature hex str/Bytes, must be 64 bytes\n    msg = abytes(msg); // Message hex str/Bytes\n    pub = abytes(pub, L);\n    const { zip215 } = opts; // switch between zip215 and rfc8032 verif\n    let A;\n    let R;\n    let s;\n    let SB;\n    let hashable = Uint8Array.of();\n    try {\n        A = Point.fromBytes(pub, zip215); // public key A decoded\n        R = Point.fromBytes(sig.slice(0, L), zip215); // 0 <= R < 2^256: ZIP215 R can be >= P\n        s = bytesToNumLE(sig.slice(L, L2)); // Decode second half as an integer S\n        SB = G.multiply(s, false); // in the range 0 <= s < L\n        hashable = concatBytes(R.toBytes(), A.toBytes(), msg); // dom2(F, C) || R || A || PH(M)\n    }\n    catch (error) { }\n    const finish = (hashed) => {\n        // k = SHA512(dom2(F, C) || R || A || PH(M))\n        if (SB == null)\n            return false; // false if try-catch catched an error\n        if (!zip215 && A.isSmallOrder())\n            return false; // false for SBS: Strongly Binding Signature\n        const k = modL_LE(hashed); // decode in little-endian, modulo L\n        const RkA = R.add(A.multiply(k, false)); // [8]R + [8][k]A'\n        return RkA.add(SB.negate()).clearCofactor().is0(); // [8][S]B = [8]R + [8][k]A'\n    };\n    return { hashable, finish };\n};\n/** Verifies signature on message and public key. Async. Follows RFC8032 5.1.7. */\nconst verifyAsync = async (signature, message, publicKey, opts = defaultVerifyOpts) => hashFinishA(_verify(signature, message, publicKey, opts));\n/** Verifies signature on message and public key. To use, set `hashes.sha512` first. Follows RFC8032 5.1.7. */\nconst verify = (signature, message, publicKey, opts = defaultVerifyOpts) => hashFinishS(_verify(signature, message, publicKey, opts));\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    bytesToHex: bytesToHex,\n    hexToBytes: hexToBytes,\n    concatBytes: concatBytes,\n    mod: M,\n    invert: invert,\n    randomBytes: randomBytes,\n};\nconst hashes = {\n    sha512Async: async (message) => {\n        const s = subtle();\n        const m = concatBytes(message);\n        return u8n(await s.digest('SHA-512', m.buffer));\n    },\n    sha512: undefined,\n};\n// FIPS 186 B.4.1 compliant key generation produces private keys\n// with modulo bias being neglible. takes >N+16 bytes, returns (hash mod n-1)+1\nconst randomSecretKey = (seed = randomBytes(L)) => seed;\nconst keygen = (seed) => {\n    const secretKey = randomSecretKey(seed);\n    const publicKey = getPublicKey(secretKey);\n    return { secretKey, publicKey };\n};\nconst keygenAsync = async (seed) => {\n    const secretKey = randomSecretKey(seed);\n    const publicKey = await getPublicKeyAsync(secretKey);\n    return { secretKey, publicKey };\n};\n/** ed25519-specific key utilities. */\nconst utils = {\n    getExtendedPublicKeyAsync: getExtendedPublicKeyAsync,\n    getExtendedPublicKey: getExtendedPublicKey,\n    randomSecretKey: randomSecretKey,\n};\n// ## Precomputes\n// --------------\nconst W = 8; // W is window size\nconst scalarBits = 256;\nconst pwindows = Math.ceil(scalarBits / W) + 1; // 33 for W=8, NOT 32 - see wNAF loop\nconst pwindowSize = 2 ** (W - 1); // 128 for W=8\nconst precompute = () => {\n    const points = [];\n    let p = G;\n    let b = p;\n    for (let w = 0; w < pwindows; w++) {\n        b = p;\n        points.push(b);\n        for (let i = 1; i < pwindowSize; i++) {\n            b = b.add(p);\n            points.push(b);\n        } // i=1, bc we skip 0\n        p = b.double();\n    }\n    return points;\n};\nlet Gpows = undefined; // precomputes for base point G\n// const-time negate\nconst ctneg = (cnd, p) => {\n    const n = p.negate();\n    return cnd ? n : p;\n};\n/**\n * Precomputes give 12x faster getPublicKey(), 10x sign(), 2x verify() by\n * caching multiples of G (base point). Cache is stored in 32MB of RAM.\n * Any time `G.multiply` is done, precomputes are used.\n * Not used for getSharedSecret, which instead multiplies random pubkey `P.multiply`.\n *\n * w-ary non-adjacent form (wNAF) precomputation method is 10% slower than windowed method,\n * but takes 2x less RAM. RAM reduction is possible by utilizing `.subtract`.\n *\n * !! Precomputes can be disabled by commenting-out call of the wNAF() inside Point#multiply().\n */\nconst wNAF = (n) => {\n    const comp = Gpows || (Gpows = precompute());\n    let p = I;\n    let f = G; // f must be G, or could become I in the end\n    const pow_2_w = 2 ** W; // 256 for W=8\n    const maxNum = pow_2_w; // 256 for W=8\n    const mask = big(pow_2_w - 1); // 255 for W=8 == mask 0b11111111\n    const shiftBy = big(W); // 8 for W=8\n    for (let w = 0; w < pwindows; w++) {\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        // We use negative indexes to reduce size of precomputed table by 2x.\n        // Instead of needing precomputes 0..256, we only calculate them for 0..128.\n        // If an index > 128 is found, we do (256-index) - where 256 is next window.\n        // Naive: index +127 => 127, +224 => 224\n        // Optimized: index +127 => 127, +224 => 256-32\n        if (wbits > pwindowSize) {\n            wbits -= maxNum;\n            n += 1n;\n        }\n        const off = w * pwindowSize;\n        const offF = off; // offsets, evaluate both\n        const offP = off + Math.abs(wbits) - 1;\n        const isEven = w % 2 !== 0; // conditions, evaluate both\n        const isNeg = wbits < 0;\n        if (wbits === 0) {\n            // off == I: can't add it. Adding random offF instead.\n            f = f.add(ctneg(isEven, comp[offF])); // bits are 0: add garbage to fake point\n        }\n        else {\n            p = p.add(ctneg(isNeg, comp[offP])); // bits are 1: add to result point\n        }\n    }\n    if (n !== 0n)\n        err('invalid wnaf');\n    return { p, f }; // return both real and fake points for JIT\n};\n// !! Remove the export to easily use in REPL / browser console\nexport { etc, getPublicKey, getPublicKeyAsync, hash, hashes, keygen, keygenAsync, Point, sign, signAsync, utils, verify, verifyAsync, };\n"],"names":["HpkeError","Error","constructor","e","message","super","this","name","EncapError","DecapError","ExportError","SealError","OpenError","MessageLimitReachedError","DeriveKeyPairError","dntGlobalThis","baseObj","globalThis","extObj","Proxy","get","_target","prop","_receiver","set","value","deleteProperty","success","ownKeys","baseKeys","Reflect","extKeys","extKeysSet","Set","filter","k","has","defineProperty","desc","getOwnPropertyDescriptor","NativeAlgorithm","Object","enumerable","configurable","writable","undefined","_setup","_api","async","crypto","subtle","webcrypto","loadSubtleCrypto","INPUT_LENGTH_LIMIT","Uint8Array","x","privateKey","publicKey","n","w","ret","i","a","b","length","LABEL_EAE_PRK","LABEL_SHARED_SECRET","Dhkem","id","prim","kdf","_prim","_kdf","suiteId","init","serializePublicKey","key","deserializePublicKey","serializePrivateKey","deserializePrivateKey","importKey","format","isPublic","generateKeyPair","deriveKeyPair","ikm","byteLength","encap","params","ke","ekm","enc","pkrm","recipientPublicKey","dh","kemContext","senderKey","sks","pks","derivePublicKey","pksm","c","concat3","sharedSecret","_generateSharedSecret","decap","pke","skr","recipientKey","pkr","senderPublicKey","labeledIkm","buildLabeledIkm","labeledInfo","buildLabeledInfo","secretSize","extractAndExpand","buffer","KEM_USAGES","Bignum","size","_num","val","reset","fill","src","isZero","lessThan","v","LABEL_CANDIDATE","ORDER_P_256","ORDER_P_384","ORDER_P_521","PKCS8_ALG_ID_P_256","PKCS8_ALG_ID_P_384","PKCS8_ALG_ID_P_521","Ec","kem","hkdf","_hkdf","_alg","namedCurve","_nPk","_nSk","_nDh","_order","_bitmask","_pkcs8AlgId","exportKey","_importRawKey","jwk","base64","replace","byteString","atob","charCodeAt","base64UrlToBytes","ArrayBuffer","_importJWK","generateKey","dkpPrk","labeledExtract","bn","counter","bytes","labeledExpand","sk","_deserializePkcs8Key","pk","deriveBits","public","crv","d","pkcs8Key","HPKE_VERSION","HkdfNative","hash","_suiteId","label","_checkInit","info","len","extract","salt","hashSize","algHash","sign","expand","prk","okm","p","prev","mid","tail","tmp","cur","slice","baseKey","HkdfSha256Native","arguments","AEAD_USAGES","BigInt","AesGcmContext","_rawKey","seal","iv","data","aad","_setupKey","alg","additionalData","encrypt","_key","open","decrypt","_importKey","Aes128Gcm","createEncryptionContext","Aes256Gcm","emitNotSupported","Promise","_resolve","reject","LABEL_SEC","ExporterContextImpl","api","exporterSecret","_data","_aad","exporterContext","RecipientExporterContextImpl","SenderExporterContextImpl","EncryptionContextImpl","baseNonce","seq","_aead","aead","_nK","keySize","_nN","nonceSize","_nT","tagSize","_ctx","computeNonce","seqBytes","buf","xor","incrementSeq","Number","MAX_SAFE_INTEGER","_Mutex_locked","Mutex","resolve","lock","releaseLock","nextLock","previousLock","receiver","state","kind","f","TypeError","call","__classPrivateFieldGet","__classPrivateFieldSet","WeakMap","_RecipientContextImpl_mutex","RecipientContextImpl","release","pt","_SenderContextImpl_mutex","SenderContextImpl","ct","LABEL_BASE_NONCE","LABEL_EXP","LABEL_INFO_HASH","LABEL_KEY","LABEL_PSK_ID_HASH","LABEL_SECRET","SUITE_ID_HEADER_HPKE","CipherSuiteNative","_kem","createSenderContext","_validateInputLength","mode","psk","_keyScheduleS","createRecipientContext","_keyScheduleR","ctx","_keySchedule","pskId","pskIdHash","infoHash","keyScheduleContext","exporterSecretInfo","keyInfo","baseNonceInfo","res","DhkemP256HkdfSha256Native","CipherSuite","DhkemP256HkdfSha256","HkdfSha256","ALPHABET","ALPHABET_MAP","z","charAt","polymodStep","pre","prefixChk","prefix","chk","convert","inBits","outBits","pad","bits","maxV","result","push","toWords","fromWordsUnsafe","words","Array","isArray","fromWords","getLibraryFromEncoding","encoding","ENCODING_CONST","__decode","str","LIMIT","lowered","toLowerCase","uppered","toUpperCase","split","lastIndexOf","wordChars","decodeUnsafe","decode","encode","ed25519_CURVE","h","Gx","Gy","P","N","_a","_d","err","args","captureStackTrace","captureTrace","abytes","title","isView","needsLen","u8n","u8fr","from","padh","toString","padStart","bytesToHex","map","join","_ch","ch","hexToBytes","hex","hl","al","array","ai","hi","n1","n2","cr","concatBytes","arrs","r","reduce","sum","forEach","big","assertRange","min","max","msg","isBig","M","invert","num","md","y","u","q","m","apoint","Point","B256","static","X","Y","Z","T","freeze","CURVE","fromAffine","fromBytes","zip215","normed","lastByte","bytesToNumLE","y2","isValid","uvRatio","isXOdd","isLastByteOdd","fromHex","toAffine","assertValidity","is0","X2","Y2","Z2","Z4","aX2","equals","other","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","I","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","multiply","safe","wNAF","multiplyUnsafe","scalar","iz","toBytes","numTo32bLE","toHex","clearCofactor","isSmallOrder","isTorsionFree","BASE","ZERO","reverse","pow2","power","RM1","v3","pow","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","pow_2_252_3","vx2","root1","root2","useRoot1","useRoot2","noRoot","modL_LE","modN","sha512s","fn","hashes","callHash","getExtendedPublicKey","secretKey","hashed","head","point","pointBytes","hash2extK","getPublicKey","priv","etc","mod","randomBytes","getRandomValues","sha512Async","s","digest","sha512","pwindows","Math","ceil","scalarBits","Gpows","ctneg","cnd","comp","points","precompute","mask","pow_2_w","shiftBy","wbits","off","offF","offP","abs","isEven","isNeg"],"sourceRoot":""}