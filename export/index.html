<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title>Turnkey Export</title>
  <link rel="icon" type="image/svg+xml" href="../favicon.svg" />
  <link rel="stylesheet" href="../styles.css">
  <script type="module" src="../tkhq.js"></script>
  <script type="module" src="../hpkeDecrypt.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
  <h2>Export Key Material</h2>
  <p><em>This public key will be sent along with a private key ID or wallet ID inside of a new <code>EXPORT_PRIVATE_KEY</code> or <code>EXPORT_WALLET</code> activity</em></p>
  <form>
    <label>Embedded key</label>
    <input type="text" name="embedded-key" id="embedded-key" disabled/>
    <button id="reset">Reset Key</button>
  </form>
  <br>
  <br>
  <br>
  <h2>Inject Export Bundle</h2>
  <p><em>The export bundle comes from the parent page and is composed of a public key and an encrypted payload. The payload is encrypted to this document's embedded key (stored in local storage and displayed above). The scheme relies on <a target="_blank" href="https://datatracker.ietf.org/doc/rfc9180/">HPKE (RFC 9180)</a></em>.</p>
  <form>
    <label>Key Bundle</label>
    <input type="text" name="key-export-bundle" id="key-export-bundle"/>
    <button id="inject-key">Inject Bundle</button>
  </form>
  <br>
  <form>
    <label>Wallet Bundle</label>
    <input type="text" name="wallet-export-bundle" id="wallet-export-bundle"/>
    <button id="inject-wallet">Inject Bundle</button>
  </form>
  <br>
  <br>
  <h2>Message log</h2>
  <p><em>Below we display a log of the messages sent / received. The forms above send messages, and the code communicates results by sending events via the <code>postMessage</code> API.</em></p>
  <div id="message-log"></div>
  <!--
    Script using HPKE lib
    Because this is loaded as a module JSDOM can't load it properly
    Code in here isn't tested, so let's keep this to a minimum!
  -->
  <script type="module">
    import { HpkeDecrypt } from "../hpkeDecrypt.js";

    document.addEventListener("DOMContentLoaded", async () => {
      await TKHQ.initEmbeddedKey();
      const embeddedKeyJwk = await TKHQ.getEmbeddedKey();
      const targetPubBuf = await TKHQ.p256JWKPrivateToPublic(embeddedKeyJwk);
      const targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
      document.getElementById("embedded-key").value = targetPubHex;
      TKHQ.sendMessageUp("PUBLIC_KEY_READY", targetPubHex)

      // TODO: find a way to filter messages and ensure they're coming from the parent window?
      // We do not want to arbitrarily receive messages from all origins.
      window.addEventListener("message", event => {
        if (event.data && event.data["type"] == "INJECT_KEY_EXPORT_BUNDLE") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}: ${event.data["value"]}`);
          onInjectKeyBundle(event.data["value"])
        }
        if (event.data && event.data["type"] == "INJECT_WALLET_EXPORT_BUNDLE") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}: ${event.data["value"]}`);
          onInjectWalletBundle(event.data["value"])
        }
        if (event.data && event.data["type"] == "RESET_EMBEDDED_KEY") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}`);
          TKHQ.onResetEmbeddedKey().then(newTargetKey => {
            return TKHQ.p256JWKPrivateToPublic(newTargetKey);
          }).then(targetPubBuf => {
            const targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
            document.getElementById("embedded-key").value = targetPubHex;
          });
        }
      }, false);

      /**
       * Event handlers to power the export flow in standalone mode
       * Instead of receiving events from the parent page, forms trigger them.
       * This is useful for debugging as well.
       */
      document.getElementById("inject-key").addEventListener("click", async e => {
        e.preventDefault();
        window.postMessage({
          "type": "INJECT_KEY_EXPORT_BUNDLE",
          "value": document.getElementById("key-export-bundle").value,
        })
      }, false);
      document.getElementById("inject-wallet").addEventListener("click", async e => {
        e.preventDefault();
        window.postMessage({
          "type": "INJECT_WALLET_EXPORT_BUNDLE",
          "value": document.getElementById("wallet-export-bundle").value,
        })
      }, false);
      document.getElementById("reset").addEventListener("click", async e => {
        e.preventDefault();
        window.postMessage({ "type": "RESET_EMBEDDED_KEY" })
      }, false);
    }, false);

    /**
     * Hide every HTML element in <body> except any <script> elements.
     * Then append an element containing the hex-encoded raw private key.
     * @param {string} key
     */ 
    const displayKey = key => {
      Array.from(document.body.children).forEach(child => {
          if (child.tagName !== "SCRIPT") {
            child.style.display = 'none';
          }
        });

        const style = {
          padding: "10px",
          borderRadius: "8px",
          borderWidth: "1px",
          borderStyle: "solid",
          borderColor: "rgba(216, 219, 227, 1)",
          color: "#555b64",
          fontWeight: "400",
          fontSize: ".875rem",
          lineHeight: "1.25rem",
          fontFamily: "\"iA Writer Mono\", SFMono-Regular, Menlo, Consolas, monospace;",
        };

        // Create a new div with the key material and append the new div to the body
        const keyDiv = document.createElement("div");
        keyDiv.id = "key-div";
        keyDiv.innerText = key;
        for (let styleKey in style) {
            keyDiv.style[styleKey] = style[styleKey];
        }
        document.body.appendChild(keyDiv);
    }

    /**
     * Hide every HTML element in <body> except any <script> elements.
     * Then append an element containing the wallet's mnemonic in a
     * 3-column table where each row contains 3 words and their
     * corresponding index.
     * @param wallet
     * 
     * TODO: Append element for passphrase after import is released
     */ 
    const displayWallet = wallet => {
      Array.from(document.body.children).forEach(child => {
          if (child.tagName !== "SCRIPT") {
            child.style.display = 'none';
          }
        });

        const words = wallet.mnemonic.split(" ");

        const numberCellStyle = {
          backgroundColor: "#f9fbff",
          border: "1px solid #ebedf2",
          padding: "10px",
          width: "20px",
          color: "#6c727e",
          height: "20px",
        };

        const wordCellStyle = {
          border: "1px solid #ebedf2",
          padding: "10px",
          height: "20px",
        }

        const table = document.createElement("table");
        const tbody = document.createElement("tbody");
        tbody.id = "mnemonic-tbody";
        table.id = "mnemonic-table";
        table.appendChild(tbody);
        table.style.borderCollapse = "collapse";
        table.style.marginLeft = "auto";
        table.style.marginRight = "auto";

        for (let i = 0; i < words.length; i += 3) {
          let row = document.createElement("tr");
          for (let j = 0; j < 3; j++) {
            if (i + j < words.length) {
              let cellIndex = document.createElement("td");
              cellIndex.innerText = i + j + 1;
              for (let styleKey in numberCellStyle) {
                cellIndex.style[styleKey] = numberCellStyle[styleKey];
              }
              row.appendChild(cellIndex);

              let cellWord = document.createElement("td");
              cellWord.innerText = words[i + j];
              for (let styleKey in wordCellStyle) {
                cellWord.style[styleKey] = wordCellStyle[styleKey];
              }
              row.appendChild(cellWord);
            }
          }

          tbody.appendChild(row);
        }

        document.body.appendChild(table);
    }

    /**
     * Parse and decrypt the export bundle.
     * The `bundle` param is a JSON string of the encapsulated public
     * key, encapsulated public key signature, and the ciphertext.
     * Example: {"encappedPublic":"04912cb4200c40f04ae4a162f4c870c78cb4498a8efda0b94f4a9cb848d611bd40e9acccab2bf73cee1e269d8350a02f4df71864921097838f05c288d944fa2f8b","encappedPublicSignature":"304502200cd19a3c5892f1eeab88fe0cdd7cca63736a7d15fc364186fb3c913e1e01568b022100dea49557c176f6ca052b27ad164f077cf64d2aa55fbdc4757a14767f8b8c6b48","ciphertext":"0e5d5503f43721135818051e4c5b77b3365b66ec4020b0051d59ea9fc773c67bd4b61ed34a97b07a3074a85546721ae4"}
     * @param {string} bundle
     */ 
    const decryptBundle = async bundle => {
      const bundleObj = JSON.parse(bundle);
      const encappedKeyBuf = TKHQ.uint8arrayFromHexString(bundleObj.encappedPublic);
      const ciphertextBuf = TKHQ.uint8arrayFromHexString(bundleObj.ciphertext);
      const embeddedKeyJwk = await TKHQ.getEmbeddedKey();
      return await HpkeDecrypt(
        {
          ciphertextBuf,
          encappedKeyBuf,
          receiverPrivJwk: embeddedKeyJwk,
        });
    }

    /**
     * Function triggered when INJECT_KEY_EXPORT_BUNDLE event is received.
     * @param {string} bundle
     */
     const onInjectKeyBundle = async bundle => {
        // Decrypt the export bundle
        const keyBytes = await decryptBundle(bundle);

        // Parse the decrypted key bytes
        const key = TKHQ.parseKey(new Uint8Array(keyBytes));

        // Display only the key
        displayKey(key);

        // Send up BUNDLE_INJECTED message
        TKHQ.sendMessageUp("BUNDLE_INJECTED", true)
    }

    /**
     * Function triggered when INJECT_KEY_EXPORT_BUNDLE event is received.
     * @param {string} bundle
     */
     const onInjectWalletBundle = async bundle => {
        // Decrypt the export bundle
        const walletBytes = await decryptBundle(bundle);

        // Parse the decrypted wallet bytes
        const wallet = TKHQ.parseWallet(new Uint8Array(walletBytes));

        // Display only the wallet's mnemonic
        displayWallet(wallet);

        // Send up BUNDLE_INJECTED message
        TKHQ.sendMessageUp("BUNDLE_INJECTED", true)
    }
  </script>
</body>
</html>