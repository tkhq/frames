<!DOCTYPE html>
<html class="no-js" lang="">
  <head>
    <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
    <meta charset="utf-8" />
    <title>Turnkey Export</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <style>
      body {
        text-align: center;
        font-family: "Lucida Sans", "Lucida Sans Regular", "Lucida Grande",
          "Lucida Sans Unicode", Geneva, Verdana, sans-serif;
        max-width: 1024px;
        margin: auto;
      }
      label {
        display: inline-block;
        width: 8em;
      }
      form {
        text-align: left;
      }
      input[type="text"],
      select {
        width: 40em;
        margin: 0.5em;
        font-family: "Courier New", Courier, monospace;
        font-size: 1em;
        height: 1.8em;
        color: rgb(18, 87, 18);
        border: 1px rgb(217, 240, 221) solid;
        border-radius: 4px;
      }
      input:disabled {
        background-color: rgb(239, 243, 240);
      }
      #reset {
        color: white;
        width: 7em;
        font-size: 1em;
        padding: 0.38em;
        border-radius: 4px;
        background-color: rgb(187, 100, 100);
        border: 1px rgb(112, 42, 42) solid;
        cursor: pointer;
        display: inline;
      }
      #inject-key,
      #inject-wallet {
        color: white;
        width: 7em;
        font-size: 1em;
        padding: 0.38em;
        border-radius: 4px;
        background-color: rgb(50, 44, 44);
        border: 1px rgb(33, 33, 33) solid;
        cursor: pointer;
        display: inline;
      }
      #message-log {
        border: 1px #2a2828 solid;
        padding: 0 0.7em;
        border-radius: 4px;
        margin-top: 2em;
        max-width: 800px;
        margin: auto;
        display: block;
      }
      #message-log p {
        font-size: 0.9em;
        text-align: left;
        word-break: break-all;
      }
      .hidden {
        display: none;
      }
      #passphrase-form-div {
        text-align: center;
        max-width: 500px;
        margin: 2em auto;
        padding: 1.5em;
        border: 1px solid #ddd;
        border-radius: 8px;
        background-color: #fafafa;
      }
      #passphrase-form-div h2 {
        margin-top: 0;
        color: #333;
      }
      #passphrase-form-div p {
        color: #555;
        font-size: 0.9em;
        margin-bottom: 1.5em;
      }
      #passphrase-form-div label {
        display: block;
        text-align: left;
        margin: 0.5em 0 0.25em 0;
        font-weight: bold;
        color: #444;
      }
      #passphrase-form-div input[type="password"] {
        width: 100%;
        padding: 0.6em;
        font-size: 1em;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
        margin-bottom: 0.5em;
      }
      #passphrase-form-div input[type="password"]:focus {
        outline: none;
        border-color: #666;
      }
      #encrypt-and-export {
        color: white;
        width: 100%;
        font-size: 1em;
        padding: 0.75em;
        margin-top: 1em;
        border-radius: 4px;
        background-color: rgb(50, 44, 44);
        border: 1px rgb(33, 33, 33) solid;
        cursor: pointer;
      }
      #encrypt-and-export:hover {
        background-color: rgb(70, 64, 64);
      }
      #passphrase-error {
        color: #c0392b;
        font-size: 0.9em;
        margin: 0.5em 0;
        text-align: left;
      }
      #passphrase-strength {
        margin-top: 0.5em;
        text-align: left;
      }
      #passphrase-strength-bar {
        height: 6px;
        border-radius: 3px;
        background-color: #e0e0e0;
        overflow: hidden;
        margin-bottom: 0.3em;
      }
      #passphrase-strength-fill {
        height: 100%;
        width: 0%;
        transition: width 0.3s ease, background-color 0.3s ease;
      }
      #passphrase-strength-text {
        font-size: 0.8em;
        color: #666;
      }
      .strength-weak { background-color: #e74c3c; }
      .strength-fair { background-color: #f39c12; }
      .strength-good { background-color: #3498db; }
      .strength-strong { background-color: #27ae60; }
    </style>
  </head>

  <body>
    <h2>Export Key Material</h2>
    <p>
      <em
        >This public key will be sent along with a private key ID or wallet ID
        inside of a new <code>EXPORT_PRIVATE_KEY</code> or
        <code>EXPORT_WALLET</code> activity</em
      >
    </p>
    <form>
      <label>Embedded key</label>
      <input type="text" name="embedded-key" id="embedded-key" disabled />
      <button id="reset">Reset Key</button>
    </form>
    <br />
    <br />
    <br />
    <h2>Inject Key Export Bundle</h2>
    <p>
      <em
        >The export bundle comes from the parent page and is composed of a
        public key and an encrypted payload. The payload is encrypted to this
        document's embedded key (stored in local storage and displayed above).
        The scheme relies on
        <a target="_blank" href="https://datatracker.ietf.org/doc/rfc9180/"
          >HPKE (RFC 9180)</a
        ></em
      >.
    </p>
    <form>
      <label>Bundle</label>
      <input type="text" name="key-export-bundle" id="key-export-bundle" />
      <button id="inject-key">Inject Bundle</button>
      <br />
      <label>Key Format</label>
      <select id="key-export-format" name="key-export-format">
        <option value="HEXADECIMAL">Hexadecimal (Default)</option>
        <option value="SOLANA">Solana</option>
      </select>
      <br />
      <label>Organization Id</label>
      <input type="text" name="key-organization-id" id="key-organization-id" />
    </form>
    <br />
    <h2>Inject Wallet Export Bundle</h2>
    <p>
      <em
        >The export bundle comes from the parent page and is composed of a
        public key and an encrypted payload. The payload is encrypted to this
        document's embedded key (stored in local storage and displayed above).
        The scheme relies on
        <a target="_blank" href="https://datatracker.ietf.org/doc/rfc9180/"
          >HPKE (RFC 9180)</a
        ></em
      >.
    </p>
    <form>
      <label>Bundle</label>
      <input
        type="text"
        name="wallet-export-bundle"
        id="wallet-export-bundle"
      />
      <button id="inject-wallet">Inject Bundle</button>
      <br />
      <label>Organization Id</label>
      <input
        type="text"
        name="wallet-organization-id"
        id="wallet-organization-id"
      />
    </form>
    <br />
    <br />
    <h2>Message log</h2>
    <p>
      <em
        >Below we display a log of the messages sent / received. The forms above
        send messages, and the code communicates results by sending events via
        the <code>postMessage</code> API.</em
      >
    </p>
    <div id="message-log"></div>
    <div id="key-div"></div>

    <!-- Script containing ED25519 library -->
    <script src="noble-hashes.js"></script>
    <script src="noble-ed25519.js"></script>
    <!--
    Script defining important helpers.
    These helpers are unit-testable, so most of the logic should be written here.
  -->
    <script>
      window.TKHQ = (function () {
        /** constant for LocalStorage */
        const TURNKEY_EMBEDDED_KEY = "TURNKEY_EMBEDDED_KEY";
        const TURNKEY_SETTINGS = "TURNKEY_SETTINGS";
        /** 48 hours in milliseconds */
        const TURNKEY_EMBEDDED_KEY_TTL_IN_MILLIS = 1000 * 60 * 60 * 48;

        var parentFrameMessageChannelPort = null;

        /**
         * Bech32 character set as defined in BIP173.
         * Reference: https://github.com/bitcoinjs/bech32/blob/5ceb0e3d4625561a459c85643ca6947739b2d83c/src/index.ts#L2
         * The alphabet excludes '1', 'b', 'i', and 'o' to avoid confusion with similar-looking characters.
         */
        const BECH32_CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";

        /**
         * Map each bech32 character to its 5-bit value (0-31).
         * Used for decoding bech32 strings.
         */
        const BECH32_CHAR_MAP = (() => {
          const map = {};
          for (let i = 0; i < BECH32_CHARSET.length; i++) {
            map[BECH32_CHARSET[i]] = i;
          }
          return map;
        })();

        /**
         * Internal function that computes the Bech32 checksum polymod.
         * This implements the BCH code checksum as specified in BIP173.
         * Reference: https://en.bitcoin.it/wiki/Bech32
         *
         * The generator polynomial constants are derived from the BCH code generator.
         * The function processes 5-bit values and XORs them with generator values
         * based on the top 5 bits of the current checksum state.
         *
         * @param {number[]} values - Array of 5-bit values to process
         * @returns {number} - The checksum polymod result
         */
        function bech32Polymod(values) {
          let chk = 1;
          // Generator polynomial constants for BCH code (BIP173) (see https://github.com/bitcoinjs/bech32/blob/5ceb0e3d4625561a459c85643ca6947739b2d83c/src/index.ts#L10)
          const GEN = [
            0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3,
          ];
          for (let p = 0; p < values.length; p++) {
            const v = values[p];
            const top = chk >>> 25; // Extract top 5 bits
            chk = ((chk & 0x1ffffff) << 5) ^ v; // Shift left and XOR with value
            for (let i = 0; i < 5; i++) {
              if (((top >>> i) & 1) !== 0) {
                chk ^= GEN[i]; // XOR with generator if bit is set
              }
            }
          }
          return chk;
        }

        /**
         * Expand the Human-Readable Part (HRP) for Bech32 checksum computation.
         * Reference: https://en.bitcoin.it/wiki/Bech32
         *
         * The HRP is expanded by taking:
         * 1. The upper 3 bits of each character (right-shifted by 5)
         * 2. A separator (0)
         * 3. The lower 5 bits of each character (masked with 31)
         *
         * For example, "bc" becomes [3, 3, 0, 2, 3] where:
         * - 'b' (0x62) → upper: 3, lower: 2
         * - 'c' (0x63) → upper: 3, lower: 3
         *
         * @param {string} hrp - Human-Readable Part (e.g., "bc", "suiprivkey")
         * @returns {number[]} - Expanded array of 5-bit values
         */
        function bech32HrpExpand(hrp) {
          const ret = [];
          // Extract upper 3 bits of each character
          for (let i = 0; i < hrp.length; i++) {
            const c = hrp.charCodeAt(i);
            ret.push(c >> 5);
          }
          ret.push(0); // Separator
          // Extract lower 5 bits of each character
          for (let i = 0; i < hrp.length; i++) {
            const c = hrp.charCodeAt(i);
            ret.push(c & 31);
          }
          return ret;
        }

        /**
         * Create a Bech32 checksum (6 characters).
         * Reference: https://en.bitcoin.it/wiki/Bech32
         *
         * The checksum is computed by:
         * 1. Expanding the HRP and concatenating with the data
         * 2. Appending six zero values
         * 3. Computing the polymod
         * 4. XORing with the bech32 constant (1)
         * 5. Extracting six 5-bit values from the result
         *
         * Note: This uses the bech32 constant (1). For bech32m (BIP350), the constant is 0x2bc830a3.
         *
         * @param {string} hrp - Human-Readable Part
         * @param {number[]} data - Array of 5-bit values representing the payload
         * @returns {number[]} - Array of 6 checksum values (5-bit each)
         */
        function bech32CreateChecksum(hrp, data) {
          const values = bech32HrpExpand(hrp).concat(data);
          const polymod = bech32Polymod(values.concat([0, 0, 0, 0, 0, 0])) ^ 1; // bech32 const = 1
          const checksum = [];
          for (let i = 0; i < 6; i++) {
            checksum.push((polymod >> (5 * (5 - i))) & 31); // Extract 5 bits
          }
          return checksum;
        }

        /**
         * Convert from 8-bit bytes to 5-bit words (groups).
         * Reference: https://en.bitcoin.it/wiki/Bech32
         *
         * This function repacks data from 8-bit bytes to 5-bit groups.
         * Since 8 and 5 don't evenly divide, we use an accumulator to handle the conversion.
         *
         * For example, 2 bytes (16 bits) → 3.2 groups (16/5), so we pad to 4 groups (20 bits).
         * The final group may have zero-padding in the lower bits.
         *
         * @param {Uint8Array} bytes - Input data as 8-bit bytes
         * @returns {number[]} - Array of 5-bit values (0-31)
         */
        function bech32ToWords(bytes) {
          const fromBits = 8;
          const toBits = 5;
          const pad = true;

          let acc = 0;
          let bits = 0;
          const maxv = (1 << toBits) - 1;
          const result = [];

          for (let i = 0; i < bytes.length; i++) {
            const value = bytes[i];
            if (value < 0 || value > 255) {
              throw new Error("invalid byte value for bech32");
            }
            acc = (acc << fromBits) | value;
            bits += fromBits;
            while (bits >= toBits) {
              bits -= toBits;
              result.push((acc >> bits) & maxv);
            }
          }

          if (pad) {
            if (bits > 0) {
              result.push((acc << (toBits - bits)) & maxv);
            }
          } else {
            if (bits >= fromBits) {
              throw new Error("excess padding in bech32 data");
            }
            if ((acc & ((1 << bits) - 1)) !== 0) {
              throw new Error("non-zero padding in bech32 data");
            }
          }

          return result;
        }

        /**
         * Convert from 5-bit words (groups) back to 8-bit bytes.
         * Reference: https://en.bitcoin.it/wiki/Bech32
         *
         * This is the inverse of bech32ToWords. It repacks 5-bit groups back to 8-bit bytes.
         * Unlike encoding, decoding does NOT add padding (pad = false) to ensure the data
         * length is exact and any trailing bits are validated to be zero.
         *
         * The maxAcc limit prevents accumulator overflow during bit manipulation.
         *
         * @param {number[]} words - Array of 5-bit values (0-31)
         * @returns {Uint8Array} - Output data as 8-bit bytes
         */
        function bech32FromWords(words) {
          const fromBits = 5;
          const toBits = 8;
          const pad = false;

          let acc = 0;
          let bits = 0;
          const maxv = (1 << toBits) - 1;
          const maxAcc = (1 << (fromBits + toBits - 1)) - 1;
          const result = [];

          for (let i = 0; i < words.length; i++) {
            const value = words[i];
            if (value < 0 || value >> fromBits !== 0) {
              throw new Error("invalid bech32 word");
            }
            acc = ((acc << fromBits) | value) & maxAcc;
            bits += fromBits;
            while (bits >= toBits) {
              bits -= toBits;
              result.push((acc >> bits) & maxv);
            }
          }

          if (pad) {
            if (bits > 0) {
              result.push((acc << (toBits - bits)) & maxv);
            }
          } else {
            if (bits >= fromBits) {
              throw new Error("excess padding in bech32 data");
            }
            if ((acc & ((1 << bits) - 1)) !== 0) {
              throw new Error("non-zero padding in bech32 data");
            }
          }

          return new Uint8Array(result);
        }

        /**
         * Encode bytes into a Bech32 string.
         * Reference: https://en.bitcoin.it/wiki/Bech32
         *
         * Creates a complete bech32-encoded string in the format: hrp + "1" + data + checksum
         * For example: "suiprivkey1" + encoded_data + 6_checksum_chars
         *
         * The separator "1" is used because it's not part of the bech32 character set.
         *
         * @param {string} hrp - Human-Readable Part (e.g., "suiprivkey")
         * @param {Uint8Array} bytes - Raw bytes to encode
         * @returns {string} - Complete bech32-encoded string
         */
        function encodeBech32(hrp, bytes) {
          const words = bech32ToWords(bytes);
          const checksum = bech32CreateChecksum(hrp, words);
          const combined = words.concat(checksum);

          let out = hrp + "1";
          for (let i = 0; i < combined.length; i++) {
            out += BECH32_CHARSET[combined[i]];
          }
          return out;
        }

        /**
         * Decode a Bech32 or Bech32m string.
         * Reference: https://en.bitcoin.it/wiki/Bech32
         *
         * This function:
         * 1. Splits the string at the last "1" separator into HRP and data
         * 2. Validates the character set
         * 3. Computes and verifies the checksum
         * 4. Returns the HRP, data words (without checksum), and variant
         *
         * Supports both bech32 (const=1) and bech32m (const=0x2bc830a3) variants.
         * The variant is determined by the checksum validation.
         *
         * @param {string} str - Bech32-encoded string
         * @returns {{hrp: string, words: number[], variant: string}} - Decoded components
         */
        function decodeBech32(str) {
          // Enforce lower-case (Sui uses lowercase)
          const s = str.toLowerCase();

          // Split HRP and data at last '1'
          const pos = s.lastIndexOf("1");
          if (pos <= 0 || pos + 7 > s.length) {
            throw new Error("invalid bech32: bad separator or too short");
          }

          const hrp = s.slice(0, pos);
          const dataPart = s.slice(pos + 1);

          if (!hrp || hrp.length < 1) {
            throw new Error("invalid bech32: HRP too short");
          }

          const data = [];
          for (let i = 0; i < dataPart.length; i++) {
            const c = dataPart[i];
            const v = BECH32_CHAR_MAP[c];
            if (v == null) {
              throw new Error(`invalid bech32 character: '${c}'`);
            }
            data.push(v);
          }

          if (data.length < 6) {
            throw new Error(
              "invalid bech32: data too short (no room for checksum)"
            );
          }

          const values = bech32HrpExpand(hrp).concat(data);
          const polymod = bech32Polymod(values);

          // bech32 checksum = 1, bech32m checksum = 0x2bc830a3
          const BECH32_CONST = 1;
          const BECH32M_CONST = 0x2bc830a3;

          if (polymod !== BECH32_CONST && polymod !== BECH32M_CONST) {
            throw new Error("invalid bech32: checksum mismatch");
          }

          // strip checksum (last 6 words)
          const words = data.slice(0, data.length - 6);

          return {
            hrp,
            words,
            variant: polymod === BECH32_CONST ? "bech32" : "bech32m",
          };
        }

        /*
         * Loads the quorum public key as a CryptoKey.
         */
        async function loadQuorumKey(quorumPublic) {
          return await crypto.subtle.importKey(
            "raw",
            quorumPublic,
            {
              name: "ECDSA",
              namedCurve: "P-256",
            },
            true,
            ["verify"]
          );
        }

        /**
         * Creates a new public/private key pair and persists it in localStorage
         */
        async function initEmbeddedKey() {
          const retrievedKey = await getEmbeddedKey();
          if (retrievedKey === null) {
            const targetKey = await generateTargetKey();
            setEmbeddedKey(targetKey);
          }
          // Nothing to do, key is correctly initialized!
        }

        /*
         * Generate a key to encrypt to and export it as a JSON Web Key.
         */
        async function generateTargetKey() {
          const p256key = await crypto.subtle.generateKey(
            {
              name: "ECDH",
              namedCurve: "P-256",
            },
            true,
            ["deriveBits"]
          );

          return await crypto.subtle.exportKey("jwk", p256key.privateKey);
        }

        /**
         * Gets the current embedded private key JWK. Returns `null` if not found.
         */
        function getEmbeddedKey() {
          const jwtKey = TKHQ.getItemWithExpiry(TURNKEY_EMBEDDED_KEY);
          return jwtKey ? JSON.parse(jwtKey) : null;
        }

        /**
         * Sets the embedded private key JWK with the default expiration time.
         * @param {JsonWebKey} targetKey
         */
        function setEmbeddedKey(targetKey) {
          setItemWithExpiry(
            TURNKEY_EMBEDDED_KEY,
            JSON.stringify(targetKey),
            TURNKEY_EMBEDDED_KEY_TTL_IN_MILLIS
          );
        }

        function setParentFrameMessageChannelPort(port) {
          parentFrameMessageChannelPort = port;
        }

        /**
         * Resets the current embedded private key JWK.
         */
        function onResetEmbeddedKey() {
          window.localStorage.removeItem(TURNKEY_EMBEDDED_KEY);
        }

        /**
         * Gets the current settings.
         */
        function getSettings() {
          const settings = window.localStorage.getItem(TURNKEY_SETTINGS);
          return settings ? JSON.parse(settings) : null;
        }

        /**
         * Sets the settings object.
         * @param {Object} settings
         */
        function setSettings(settings) {
          window.localStorage.setItem(
            TURNKEY_SETTINGS,
            JSON.stringify(settings)
          );
        }

        /**
         * Set an item in localStorage with an expiration time
         * @param {string} key
         * @param {string} value
         * @param {number} ttl expiration time in milliseconds
         */
        function setItemWithExpiry(key, value, ttl) {
          const now = new Date();
          const item = {
            value: value,
            expiry: now.getTime() + ttl,
          };
          window.localStorage.setItem(key, JSON.stringify(item));
        }

        /**
         * Get an item from localStorage. Returns `null` and
         * removes the item from localStorage if expired or
         * expiry time is missing.
         * @param {string} key
         */
        function getItemWithExpiry(key) {
          const itemStr = window.localStorage.getItem(key);
          if (!itemStr) {
            return null;
          }
          const item = JSON.parse(itemStr);
          if (!item.hasOwnProperty("expiry") || !item.hasOwnProperty("value")) {
            window.localStorage.removeItem(key);
            return null;
          }
          const now = new Date();
          if (now.getTime() > item.expiry) {
            window.localStorage.removeItem(key);
            return null;
          }
          return item.value;
        }

        /**
         * Takes a hex string (e.g. "e4567ab") and returns an array buffer (Uint8Array)
         * @param {string} hexString
         * @returns {Uint8Array}
         */
        function uint8arrayFromHexString(hexString) {
          var hexRegex = /^[0-9A-Fa-f]+$/;
          if (
            !hexString ||
            hexString.length % 2 != 0 ||
            !hexRegex.test(hexString)
          ) {
            throw new Error("cannot create uint8array from invalid hex string");
          }
          return new Uint8Array(
            hexString.match(/../g).map((h) => parseInt(h, 16))
          );
        }

        /**
         * Takes a Uint8Array and returns a hex string
         * @param {Uint8Array} buffer
         * @return {string}
         */
        function uint8arrayToHexString(buffer) {
          return [...buffer]
            .map((x) => x.toString(16).padStart(2, "0"))
            .join("");
        }

        /**
         * Encodes a Uint8Array into a base58-check-encoded string
         * Throws an error if the input is invalid or the checksum is invalid.
         * @param {Uint8Array} payload The raw payload to encode.
         * @return {Promise<string>} The base58check-encoded string.
         */
        async function base58CheckEncode(payload) {
          const hash1Buf = await crypto.subtle.digest("SHA-256", payload);
          const hash1 = new Uint8Array(hash1Buf);

          const hash2Buf = await crypto.subtle.digest("SHA-256", hash1);
          const hash2 = new Uint8Array(hash2Buf);

          const checksum = hash2.slice(0, 4);

          const full = new Uint8Array(payload.length + 4);
          full.set(payload, 0);
          full.set(checksum, payload.length);

          return base58Encode(full);
        }

        /**
         * Function to normalize padding of byte array with 0's to a target length
         */
        function normalizePadding(byteArray, targetLength) {
          const paddingLength = targetLength - byteArray.length;

          // Add leading 0's to array
          if (paddingLength > 0) {
            const padding = new Uint8Array(paddingLength).fill(0);
            return new Uint8Array([...padding, ...byteArray]);
          }

          // Remove leading 0's from array
          if (paddingLength < 0) {
            const expectedZeroCount = paddingLength * -1;
            let zeroCount = 0;
            for (
              let i = 0;
              i < expectedZeroCount && i < byteArray.length;
              i++
            ) {
              if (byteArray[i] === 0) {
                zeroCount++;
              }
            }
            // Check if the number of zeros found equals the number of zeroes expected
            if (zeroCount !== expectedZeroCount) {
              throw new Error(
                `invalid number of starting zeroes. Expected number of zeroes: ${expectedZeroCount}. Found: ${zeroCount}.`
              );
            }
            return byteArray.slice(
              expectedZeroCount,
              expectedZeroCount + targetLength
            );
          }
          return byteArray;
        }

        /**
         * Additional Associated Data (AAD) in the format dictated by the enclave_encrypt crate.
         */
        function additionalAssociatedData(senderPubBuf, receiverPubBuf) {
          const s = Array.from(new Uint8Array(senderPubBuf));
          const r = Array.from(new Uint8Array(receiverPubBuf));
          return new Uint8Array([...s, ...r]);
        }

        /**
         * Converts an ASN.1 DER-encoded ECDSA signature to the raw format that WebCrypto uses.
         */
        function fromDerSignature(derSignature) {
          const derSignatureBuf = uint8arrayFromHexString(derSignature);

          // Check and skip the sequence tag (0x30)
          let index = 2;

          // Parse 'r' and check for integer tag (0x02)
          if (derSignatureBuf[index] !== 0x02) {
            throw new Error(
              "failed to convert DER-encoded signature: invalid tag for r"
            );
          }
          index++; // Move past the INTEGER tag
          const rLength = derSignatureBuf[index];
          index++; // Move past the length byte
          const r = derSignatureBuf.slice(index, index + rLength);
          index += rLength; // Move to the start of s

          // Parse 's' and check for integer tag (0x02)
          if (derSignatureBuf[index] !== 0x02) {
            throw new Error(
              "failed to convert DER-encoded signature: invalid tag for s"
            );
          }
          index++; // Move past the INTEGER tag
          const sLength = derSignatureBuf[index];
          index++; // Move past the length byte
          const s = derSignatureBuf.slice(index, index + sLength);

          // Normalize 'r' and 's' to 32 bytes each
          const rPadded = normalizePadding(r, 32);
          const sPadded = normalizePadding(s, 32);

          // Concatenate and return the raw signature
          return new Uint8Array([...rPadded, ...sPadded]);
        }

        /**
         * Function to verify enclave signature on import bundle received from the server.
         * @param {string} enclaveQuorumPublic uncompressed public key for the quorum key which produced the signature
         * @param {string} publicSignature signature bytes encoded as a hexadecimal string
         * @param {string} signedData signed bytes encoded as a hexadecimal string. This could be public key bytes directly, or JSON-encoded bytes
         */
        async function verifyEnclaveSignature(
          enclaveQuorumPublic,
          publicSignature,
          signedData
        ) {
          /** Turnkey Signer enclave's public keys */
          const TURNKEY_SIGNERS_ENCLAVES = {
            prod: "04cf288fe433cc4e1aa0ce1632feac4ea26bf2f5a09dcfe5a42c398e06898710330f0572882f4dbdf0f5304b8fc8703acd69adca9a4bbf7f5d00d20a5e364b2569",
            preprod:
              "04f3422b8afbe425d6ece77b8d2469954715a2ff273ab7ac89f1ed70e0a9325eaa1698b4351fd1b23734e65c0b6a86b62dd49d70b37c94606aac402cbd84353212",
          };
          const TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY =
            TURNKEY_SIGNERS_ENCLAVES["${TURNKEY_SIGNER_ENVIRONMENT}"];
          if (TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY === undefined) {
            throw new Error(
              "Configuration error: TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY is undefined"
            );
          }

          // todo(olivia): throw error if enclave quorum public is null once server changes are deployed
          if (enclaveQuorumPublic) {
            if (
              enclaveQuorumPublic !== TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY
            ) {
              throw new Error(
                `enclave quorum public keys from client and bundle do not match. Client: ${TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY}. Bundle: ${enclaveQuorumPublic}.`
              );
            }
          }

          const encryptionQuorumPublicBuf = new Uint8Array(
            uint8arrayFromHexString(TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY)
          );
          const quorumKey = await loadQuorumKey(encryptionQuorumPublicBuf);
          if (!quorumKey) {
            throw new Error("failed to load quorum key");
          }

          // The ECDSA signature is ASN.1 DER encoded but WebCrypto uses raw format
          const publicSignatureBuf = fromDerSignature(publicSignature);
          const signedDataBuf = uint8arrayFromHexString(signedData);
          return await crypto.subtle.verify(
            { name: "ECDSA", hash: "SHA-256" },
            quorumKey,
            publicSignatureBuf,
            signedDataBuf
          );
        }

        /**
         * Function to send a message.
         *
         * If this page is embedded as an iframe we'll send a postMessage
         * in one of two ways depending on the version of @turnkey/iframe-stamper:
         *   1. newer versions (>=v2.1.0) pass a MessageChannel MessagePort from the parent frame for postMessages.
         *   2. older versions (<v2.1.0) still use the contentWindow so we will postMessage to the window.parent for backwards compatibility.
         *
         * Otherwise we'll display it in the DOM.
         * @param type message type. Can be "PUBLIC_KEY_CREATED" or "BUNDLE_INJECTED"
         * @param value message value
         * @param requestId serves as an idempotency key to match incoming requests. Backwards compatible: if not provided, it isn't passed in.
         */
        function sendMessageUp(type, value, requestId) {
          const message = {
            type: type,
            value: value,
          };

          // Only include requestId if it was provided
          if (requestId) {
            message.requestId = requestId;
          }

          if (parentFrameMessageChannelPort) {
            parentFrameMessageChannelPort.postMessage(message);
          } else if (window.parent !== window) {
            window.parent.postMessage(
              {
                type: type,
                value: value,
              },
              "*"
            );
          }
          logMessage(`⬆️ Sent message ${type}: ${value}`);
        }

        /**
         * Function to log a message and persist it in the page's DOM.
         */
        function logMessage(content) {
          const messageLog = document.getElementById("message-log");
          const message = document.createElement("p");
          message.innerText = content;
          messageLog.appendChild(message);
        }

        /**
         * Convert a JSON Web Key private key to a public key and export the public
         * key in raw format.
         * @return {Uint8array}
         */
        async function p256JWKPrivateToPublic(jwkPrivate) {
          // make a copy so we don't modify the underlying object
          const jwkPrivateCopy = { ...jwkPrivate };
          // change jwk so it will be imported as a public key
          delete jwkPrivateCopy.d;
          jwkPrivateCopy.key_ops = ["verify"];

          const publicKey = await window.crypto.subtle.importKey(
            "jwk",
            jwkPrivateCopy,
            { name: "ECDSA", namedCurve: "P-256" },
            true,
            ["verify"]
          );
          const buffer = await crypto.subtle.exportKey("raw", publicKey);
          return new Uint8Array(buffer);
        }

        /**
         * Encodes a buffer into a base58-encoded string.
         * @param {Uint8Array} bytes The buffer to encode.
         * @return {string} The base58-encoded string.
         */
        function base58Encode(bytes) {
          // See https://en.bitcoin.it/wiki/Base58Check_encoding
          const alphabet =
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
          let result = "";
          let digits = [0];
          for (let i = 0; i < bytes.length; i++) {
            let carry = bytes[i];
            for (let j = 0; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % 58;
              carry = (carry / 58) | 0;
            }

            while (carry > 0) {
              digits.push(carry % 58);
              carry = (carry / 58) | 0;
            }
          }
          // Convert digits to a base58 string
          for (let k = 0; k < digits.length; k++) {
            result = alphabet[digits[k]] + result;
          }

          // Add '1' for each leading 0 byte
          for (let i = 0; bytes[i] === 0 && i < bytes.length - 1; i++) {
            result = "1" + result;
          }
          return result;
        }

        /**
         * Decodes a base58-encoded string into a buffer
         * This function throws an error when the string contains invalid characters.
         * @param {string} s The base58-encoded string.
         * @return {Uint8Array} The decoded buffer.
         */
        function base58Decode(s) {
          // See https://en.bitcoin.it/wiki/Base58Check_encoding
          var alphabet =
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
          var decoded = BigInt(0);
          var decodedBytes = [];
          var leadingZeros = [];
          for (var i = 0; i < s.length; i++) {
            if (alphabet.indexOf(s[i]) === -1) {
              throw new Error(
                `cannot base58-decode: ${s[i]} isn't a valid character`
              );
            }
            var carry = alphabet.indexOf(s[i]);

            // If the current base58 digit is 0, append a 0 byte.
            // "i == leadingZeros.length" can only be true if we have not seen non-zero bytes so far.
            // If we had seen a non-zero byte, carry wouldn't be 0, and i would be strictly more than `leadingZeros.length`
            if (carry == 0 && i === leadingZeros.length) {
              leadingZeros.push(0);
            }

            var j = 0;
            while (j < decodedBytes.length || carry > 0) {
              var currentByte = decodedBytes[j];

              // shift the current byte 58 units and add the carry amount
              // (or just add the carry amount if this is a new byte -- undefined case)
              if (currentByte === undefined) {
                currentByte = carry;
              } else {
                currentByte = currentByte * 58 + carry;
              }

              // find the new carry amount (1-byte shift of current byte value)
              carry = currentByte >> 8;
              // reset the current byte to the remainder (the carry amount will pass on the overflow)
              decodedBytes[j] = currentByte % 256;
              j++;
            }
          }

          var result = leadingZeros.concat(decodedBytes.reverse());
          return new Uint8Array(result);
        }

        /**
         * Returns a private key from private key bytes, represented in
         * the encoding and format specified by `keyFormat`. Defaults to
         * hex-encoding if `keyFormat` isn't passed.
         * @param {Uint8Array} privateKeyBytes
         * @param {string} keyFormat Can be "HEXADECIMAL", "SUI_BECH32", "BITCOIN_MAINNET_WIF", "BITCOIN_TESTNET_WIF" or "SOLANA"
         */
        async function encodeKey(privateKeyBytes, keyFormat, publicKeyBytes) {
          switch (keyFormat) {
            case "SOLANA":
              if (!publicKeyBytes) {
                throw new Error(
                  "public key must be specified for SOLANA key format"
                );
              }
              if (privateKeyBytes.length !== 32) {
                throw new Error(
                  `invalid private key length. Expected 32 bytes. Got ${privateKeyBytes.length}.`
                );
              }
              if (publicKeyBytes.length !== 32) {
                throw new Error(
                  `invalid public key length. Expected 32 bytes. Got ${publicKeyBytes.length}.`
                );
              }
              const concatenatedBytes = new Uint8Array(64);
              concatenatedBytes.set(privateKeyBytes, 0);
              concatenatedBytes.set(publicKeyBytes, 32);
              return base58Encode(concatenatedBytes);
            case "HEXADECIMAL":
              return "0x" + uint8arrayToHexString(privateKeyBytes);
            case "BITCOIN_MAINNET_WIF":
            case "BITCOIN_TESTNET_WIF": {
              if (privateKeyBytes.length !== 32) {
                throw new Error(
                  `invalid private key length. Expected 32 bytes. Got ${privateKeyBytes.length}.`
                );
              }

              const version = keyFormat === "BITCOIN_MAINNET_WIF" ? 0x80 : 0xef;
              const wifPayload = new Uint8Array(34);
              wifPayload[0] = version;
              wifPayload.set(privateKeyBytes, 1);
              wifPayload[33] = 0x01; // compressed flag

              return await base58CheckEncode(wifPayload);
            }
            case "SUI_BECH32":
              if (privateKeyBytes.length !== 32) {
                throw new Error(
                  `invalid private key length. Expected 32 bytes. Got ${privateKeyBytes.length}.`
                );
              }

              const schemeFlag = 0x00; // ED25519 | We only support ED25519 keys for Sui currently
              const bech32Payload = new Uint8Array(1 + 32);
              bech32Payload[0] = schemeFlag;
              bech32Payload.set(privateKeyBytes, 1);

              return encodeBech32("suiprivkey", bech32Payload);
            default:
              console.warn(
                `invalid key format: ${keyFormat}. Defaulting to HEXADECIMAL.`
              );
              return "0x" + uint8arrayToHexString(privateKeyBytes);
          }
        }

        /**
         * Returns a UTF-8 encoded wallet mnemonic + newline optional passphrase
         * from wallet bytes.
         * @param {Uint8Array} walletBytes
         */
        function encodeWallet(walletBytes) {
          const decoder = new TextDecoder("utf-8");
          const wallet = decoder.decode(walletBytes);
          let mnemonic;
          let passphrase = null;

          if (wallet.includes("\n")) {
            const parts = wallet.split("\n");
            mnemonic = parts[0];
            passphrase = parts[1];
          } else {
            mnemonic = wallet;
          }

          return {
            mnemonic: mnemonic,
            passphrase: passphrase,
          };
        }

        /**
         * Returns the public key bytes for a hex-encoded Ed25519 private key.
         * @param {string} privateKeyHex
         */
        function getEd25519PublicKey(privateKeyHex) {
          nobleEd25519.etc.sha512Sync = (...m) =>
            nobleHashes.sha512(nobleEd25519.etc.concatBytes(...m));
          return nobleEd25519.getPublicKey(privateKeyHex);
        }

        /**
         * Function to validate and sanitize the styles object using the accepted map of style keys and values (as regular expressions).
         * Any invalid style throws an error. Returns an object of valid styles.
         * @param {Object} styles
         * @return {Object}
         */
        function validateStyles(styles, element) {
          const validStyles = {};

          const cssValidationRegex = {
            padding: "^(\\d+(px|em|%|rem) ?){1,4}$",
            margin: "^(\\d+(px|em|%|rem) ?){1,4}$",
            borderWidth: "^(\\d+(px|em|rem) ?){1,4}$",
            borderStyle:
              "^(none|solid|dashed|dotted|double|groove|ridge|inset|outset)$",
            borderColor:
              "^(transparent|inherit|initial|#[0-9a-f]{3,8}|rgba?\\(\\d{1,3}, \\d{1,3}, \\d{1,3}(, \\d?(\\.\\d{1,2})?)?\\)|hsla?\\(\\d{1,3}, \\d{1,3}%, \\d{1,3}%(, \\d?(\\.\\d{1,2})?)?\\))$",
            borderRadius: "^(\\d+(px|em|%|rem) ?){1,4}$",
            fontSize:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax))$",
            fontWeight: "^(normal|bold|bolder|lighter|\\d{3})$",
            fontFamily: '^[^";<>]*$', // checks for the absence of some characters that could lead to CSS/HTML injection
            color:
              "^(transparent|inherit|initial|#[0-9a-f]{3,8}|rgba?\\(\\d{1,3}, \\d{1,3}, \\d{1,3}(, \\d?(\\.\\d{1,2})?)?\\)|hsla?\\(\\d{1,3}, \\d{1,3}%, \\d{1,3}%(, \\d?(\\.\\d{1,2})?)?\\))$",
            backgroundColor:
              "^(transparent|inherit|initial|#[0-9a-f]{3,8}|rgba?\\(\\d{1,3}, \\d{1,3}, \\d{1,3}(, \\d?(\\.\\d{1,2})?)?\\)|hsla?\\(\\d{1,3}, \\d{1,3}%, \\d{1,3}%(, \\d?(\\.\\d{1,2})?)?\\))$",
            width:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|auto)$",
            height:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|auto)$",
            maxWidth:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|none)$",
            maxHeight:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|none)$",
            lineHeight:
              "^(\\d+(\\.\\d+)?(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|normal)$",
            boxShadow:
              "^(none|(\\d+(px|em|rem) ?){2,4} (#[0-9a-f]{3,8}|rgba?\\(\\d{1,3}, \\d{1,3}, \\d{1,3}(, \\d?(\\.\\d{1,2})?)?\\)) ?(inset)?)$",
            textAlign: "^(left|right|center|justify|initial|inherit)$",
            overflowWrap: "^(normal|break-word|anywhere)$",
            wordWrap: "^(normal|break-word)$",
            resize: "^(none|both|horizontal|vertical|block|inline)$",
          };

          Object.entries(styles).forEach(([property, value]) => {
            const styleProperty = property.trim();
            if (styleProperty.length === 0) {
              throw new Error("css style property cannot be empty");
            }
            const styleRegexStr = cssValidationRegex[styleProperty];
            if (!styleRegexStr) {
              throw new Error(
                `invalid or unsupported css style property: "${styleProperty}"`
              );
            }
            const styleRegex = new RegExp(styleRegexStr);
            const styleValue = value.trim();
            if (styleValue.length == 0) {
              throw new Error(`css style for "${styleProperty}" is empty`);
            }
            const isValidStyle = styleRegex.test(styleValue);
            if (!isValidStyle) {
              throw new Error(
                `invalid css style value for property "${styleProperty}"`
              );
            }
            validStyles[styleProperty] = styleValue;
          });

          return validStyles;
        }

        /**
         * Function to apply settings on this page. For now, the only settings that can be applied
         * are for "styles". Upon successful application, return the valid, sanitized settings JSON string.
         * @param {string} settings
         * @return {string}
         */
        function applySettings(settings) {
          const validSettings = {};
          if (!settings) {
            return JSON.stringify(validSettings);
          }
          const settingsObj = JSON.parse(settings);
          if (settingsObj.styles) {
            // Valid styles will be applied the "key-div" div HTML element.
            const keyDivTextarea = document.getElementById("key-div");
            if (!keyDivTextarea) {
              throw new Error(
                "no key-div HTML element found to apply settings to."
              );
            }

            // Validate, sanitize, and apply the styles to the "key-div" div element.
            const validStyles = TKHQ.validateStyles(settingsObj.styles);
            Object.entries(validStyles).forEach(([key, value]) => {
              keyDivTextarea.style[key] = value;
            });

            if (validStyles.backgroundColor) {
              // Apply background color to document and body as well.
              document.documentElement.style.backgroundColor =
                validStyles.backgroundColor;
              document.body.style.backgroundColor = validStyles.backgroundColor;
            }

            validSettings["styles"] = validStyles;
          }

          return JSON.stringify(validSettings);
        }

        /**
         * Encrypts a Uint8Array using PBKDF2 key derivation and AES-GCM-256 encryption.
         * @param {Uint8Array} buf - The data to encrypt
         * @param {string} passphrase - The passphrase to derive the key from
         * @returns {Promise<Uint8Array>} - Concatenated salt || iv || ciphertext
         */
        async function encryptWithPassphrase(buf, passphrase) {
          // Generate random 16-byte salt and 12-byte IV
          const salt = crypto.getRandomValues(new Uint8Array(16));
          const iv = crypto.getRandomValues(new Uint8Array(12));

          // Import passphrase as PBKDF2 key material
          const keyMaterial = await crypto.subtle.importKey(
            "raw",
            new TextEncoder().encode(passphrase),
            "PBKDF2",
            false,
            ["deriveBits", "deriveKey"]
          );

          // Derive AES-256 key using PBKDF2 (600,000 iterations, SHA-256).
          // NOTE: The iteration count must match during decryption; changing it
          // affects compatibility with data encrypted using a different value.
          const aesKey = await crypto.subtle.deriveKey(
            {
              name: "PBKDF2",
              salt: salt,
              iterations: 600000,
              hash: "SHA-256",
            },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt"]
          );

          // Encrypt using AES-GCM
          const ciphertext = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            aesKey,
            buf
          );

          // Return concatenated salt || iv || ciphertext
          const result = new Uint8Array(
            salt.length + iv.length + ciphertext.byteLength
          );
          result.set(salt, 0);
          result.set(iv, salt.length);
          result.set(new Uint8Array(ciphertext), salt.length + iv.length);
          return result;
        }

        /**
         * Decrypts a buffer encrypted by encryptWithPassphrase.
         * @param {Uint8Array} encryptedBuf - The encrypted data (salt || iv || ciphertext)
         * @param {string} passphrase - The passphrase to derive the key from
         * @returns {Promise<Uint8Array>} - The decrypted data
         */
        async function decryptWithPassphrase(encryptedBuf, passphrase) {
          // Extract salt (bytes 0-16), iv (bytes 16-28), ciphertext (bytes 28+)
          const salt = encryptedBuf.slice(0, 16);
          const iv = encryptedBuf.slice(16, 28);
          const ciphertext = encryptedBuf.slice(28);

          // Import passphrase as PBKDF2 key material
          const keyMaterial = await crypto.subtle.importKey(
            "raw",
            new TextEncoder().encode(passphrase),
            "PBKDF2",
            false,
            ["deriveBits", "deriveKey"]
          );

          // Derive same AES key using PBKDF2
          const aesKey = await crypto.subtle.deriveKey(
            {
              name: "PBKDF2",
              salt: salt,
              iterations: 600000,
              hash: "SHA-256",
            },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            false,
            ["decrypt"]
          );

          // Decrypt using AES-GCM
          const decrypted = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: iv },
            aesKey,
            ciphertext
          );

          return new Uint8Array(decrypted);
        }

        return {
          initEmbeddedKey,
          generateTargetKey,
          setItemWithExpiry,
          getItemWithExpiry,
          getEmbeddedKey,
          setEmbeddedKey,
          onResetEmbeddedKey,
          p256JWKPrivateToPublic,
          base58Encode,
          base58Decode,
          decodeBech32,
          bech32FromWords,
          encodeKey,
          encodeBech32,
          encodeWallet,
          sendMessageUp,
          logMessage,
          uint8arrayFromHexString,
          uint8arrayToHexString,
          setParentFrameMessageChannelPort,
          normalizePadding,
          fromDerSignature,
          additionalAssociatedData,
          verifyEnclaveSignature,
          getEd25519PublicKey,
          applySettings,
          validateStyles,
          getSettings,
          setSettings,
          encryptWithPassphrase,
          decryptWithPassphrase,
        };
      })();
    </script>

    <script type="module">
      // Vendor @hpke/core from https://esm.sh/@hpke/core@1.2.7
      import * as hpke from "./hpke-core.js";

      // persist the MessageChannel object so we can use it to communicate with the parent window
      var iframeMessagePort = null;

      // controllers to remove event listeners
      const messageListenerController = new AbortController();
      const turnkeyInitController = new AbortController();

      /**
       * DOM Event handlers to power the export flow in standalone mode
       * Instead of receiving events from the parent page, forms trigger them.
       * This is useful for debugging as well.
       */
      var addDOMEventListeners = function () {
        document.getElementById("inject-key").addEventListener(
          "click",
          async (e) => {
            e.preventDefault();
            window.postMessage({
              type: "INJECT_KEY_EXPORT_BUNDLE",
              value: document.getElementById("key-export-bundle").value,
              keyFormat: document.getElementById("key-export-format").value,
              organizationId: document.getElementById("key-organization-id")
                .value,
            });
          },
          false
        );
        document.getElementById("inject-wallet").addEventListener(
          "click",
          async (e) => {
            e.preventDefault();
            window.postMessage({
              type: "INJECT_WALLET_EXPORT_BUNDLE",
              value: document.getElementById("wallet-export-bundle").value,
              organizationId: document.getElementById("wallet-organization-id")
                .value,
            });
          },
          false
        );
        document.getElementById("reset").addEventListener(
          "click",
          async (e) => {
            e.preventDefault();
            window.postMessage({ type: "RESET_EMBEDDED_KEY" });
          },
          false
        );
      };

      /**
       * Message Event Handlers to process messages from the parent frame
       */
      var messageEventListener = async function (event) {
        if (event.data && event.data["type"] == "INJECT_KEY_EXPORT_BUNDLE") {
          TKHQ.logMessage(
            `⬇️ Received message ${event.data["type"]}: ${event.data["value"]}, ${event.data["keyFormat"]}, ${event.data["organizationId"]}`
          );
          try {
            await onInjectKeyBundle(
              event.data["value"],
              event.data["keyFormat"],
              event.data["organizationId"],
              event.data["requestId"]
            );
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString(), event.data["requestId"]);
          }
        }
        if (event.data && event.data["type"] == "INJECT_WALLET_EXPORT_BUNDLE") {
          TKHQ.logMessage(
            `⬇️ Received message ${event.data["type"]}: ${event.data["value"]}, ${event.data["organizationId"]}`
          );
          try {
            await onInjectWalletBundle(
              event.data["value"],
              event.data["organizationId"],
              event.data["requestId"]
            );
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString(), event.data["requestId"]);
          }
        }
        if (event.data && event.data["type"] == "INJECT_WALLET_EXPORT_BUNDLE_ENCRYPTED") {
          TKHQ.logMessage(
            `⬇️ Received message ${event.data["type"]}:  ${event.data["value"]}, ${event.data["organizationId"]}`
          );
          try {
            await onInjectWalletBundleEncrypted(
              event.data["value"],
              event.data["organizationId"],
              event.data["requestId"]
            );
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString(), event.data["requestId"]);
          }
        }
        if (event.data && event.data["type"] == "APPLY_SETTINGS") {
          try {
            await onApplySettings(event.data["value"], event.data["requestId"]);
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString(), event.data["requestId"]);
          }
        }
        if (event.data && event.data["type"] == "RESET_EMBEDDED_KEY") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}`);
          try {
            TKHQ.onResetEmbeddedKey();
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString());
          }
        }
      };

      /**
       * Initialize the embedded key and set up the DOM and message event listeners
       */
      document.addEventListener(
        "DOMContentLoaded",
        async function () {
          await TKHQ.initEmbeddedKey();
          const embeddedKeyJwk = await TKHQ.getEmbeddedKey();
          const targetPubBuf = await TKHQ.p256JWKPrivateToPublic(
            embeddedKeyJwk
          );
          const targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
          document.getElementById("embedded-key").value = targetPubHex;

          window.addEventListener("message", messageEventListener, {
            capture: false,
            signal: messageListenerController.signal,
          });

          addDOMEventListeners();

          if (!messageListenerController.signal.aborted) {
            // If styles are saved in local storage, sanitize and apply them.
            const styleSettings = TKHQ.getSettings();
            if (styleSettings) {
              TKHQ.applySettings(styleSettings);
            }
            TKHQ.sendMessageUp("PUBLIC_KEY_READY", targetPubHex);
          }
        },
        false
      );

      window.addEventListener(
        "message",
        async function (event) {
          /**
           * @turnkey/iframe-stamper >= v2.1.0 is using a MessageChannel to communicate with the parent frame.
           * The parent frame sends a TURNKEY_INIT_MESSAGE_CHANNEL event with the MessagePort.
           * If we receive this event, we want to remove the message event listener that was added in the DOMContentLoaded event to avoid processing messages twice.
           * We persist the MessagePort so we can use it to communicate with the parent window in subsequent calls to TKHQ.sendMessageUp
           */
          if (
            event.data &&
            event.data["type"] == "TURNKEY_INIT_MESSAGE_CHANNEL" &&
            event.ports?.[0]
          ) {
            // remove the message event listener that was added in the DOMContentLoaded event
            messageListenerController.abort();

            iframeMessagePort = event.ports[0];
            iframeMessagePort.onmessage = messageEventListener;

            TKHQ.setParentFrameMessageChannelPort(iframeMessagePort);

            await TKHQ.initEmbeddedKey();
            var embeddedKeyJwk = await TKHQ.getEmbeddedKey();
            var targetPubBuf = await TKHQ.p256JWKPrivateToPublic(
              embeddedKeyJwk
            );
            var targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
            document.getElementById("embedded-key").value = targetPubHex;

            TKHQ.sendMessageUp("PUBLIC_KEY_READY", targetPubHex);

            // remove the listener for TURNKEY_INIT_MESSAGE_CHANNEL after it's been processed
            turnkeyInitController.abort();
          }
        },
        { signal: turnkeyInitController.signal }
      );

      /**
       * Hide every HTML element in <body> except any <script> elements.
       * Then append an element containing the hex-encoded raw private key.
       * @param {string} key
       */
      function displayKey(key) {
        Array.from(document.body.children).forEach((child) => {
          if (child.tagName !== "SCRIPT" && child.id !== "key-div") {
            child.style.display = "none";
          }
        });

        const style = {
          border: "none",
          color: "#555b64",
          fontSize: ".875rem",
          lineHeight: "1.25rem",
          overflowWrap: "break-word",
          textAlign: "left",
        };

        // Create a new div with the key material and append the new div to the body
        const keyDiv = document.getElementById("key-div");
        keyDiv.innerText = key;
        for (let styleKey in style) {
          keyDiv.style[styleKey] = style[styleKey];
        }
        document.body.appendChild(keyDiv);
        TKHQ.applySettings(TKHQ.getSettings());
      }

      /**
       * Display a passphrase form to encrypt the mnemonic before exporting.
       * @param {string} mnemonic - The wallet mnemonic to encrypt
       * @param {string} requestId - The request ID for message correlation
       */
      function displayPassphraseForm(mnemonic, requestId) {
        // Hide all existing DOM elements except scripts
        Array.from(document.body.children).forEach((child) => {
          if (child.tagName !== "SCRIPT") {
            child.style.display = "none";
          }
        });

        // Create the passphrase form container
        const formDiv = document.createElement("form");
        formDiv.id = "passphrase-form-div";

        // Create heading
        const heading = document.createElement("h2");
        heading.innerText = "Encrypt Your Wallet Export";
        formDiv.appendChild(heading);

        // Create description
        const description = document.createElement("p");
        description.innerText =
          "Enter a passphrase to encrypt your wallet mnemonic. You will need this passphrase to decrypt your wallet later.";
        formDiv.appendChild(description);

        // Create passphrase input
        const passphraseLabel = document.createElement("label");
        passphraseLabel.setAttribute("for", "export-passphrase");
        passphraseLabel.innerText = "Passphrase";
        formDiv.appendChild(passphraseLabel);

        const passphraseInput = document.createElement("input");
        passphraseInput.type = "password";
        passphraseInput.id = "export-passphrase";
        passphraseInput.placeholder = "Enter passphrase (min 8 characters)";
        passphraseInput.required = true;
        passphraseInput.setAttribute("aria-required", "true");
        passphraseInput.setAttribute("autocomplete", "new-password");
        passphraseInput.minLength = 8;
        formDiv.appendChild(passphraseInput);

        // Create passphrase strength indicator
        const strengthDiv = document.createElement("div");
        strengthDiv.id = "passphrase-strength";

        const strengthBar = document.createElement("div");
        strengthBar.id = "passphrase-strength-bar";

        const strengthFill = document.createElement("div");
        strengthFill.id = "passphrase-strength-fill";
        strengthBar.appendChild(strengthFill);
        strengthDiv.appendChild(strengthBar);

        const strengthText = document.createElement("span");
        strengthText.id = "passphrase-strength-text";
        strengthDiv.appendChild(strengthText);
        formDiv.appendChild(strengthDiv);

        /**
         * Evaluate passphrase strength and return score (0-4) with feedback
         * @param {string} passphrase
         * @returns {{score: number, label: string, feedback: string}}
         */
        function evaluatePassphraseStrength(passphrase) {
          if (!passphrase) {
            return { score: 0, label: "", feedback: "" };
          }

          let score = 0;
          const checks = {
            length8: passphrase.length >= 8,
            length12: passphrase.length >= 12,
            length16: passphrase.length >= 16,
            lowercase: /[a-z]/.test(passphrase),
            uppercase: /[A-Z]/.test(passphrase),
            numbers: /[0-9]/.test(passphrase),
            special: /[^a-zA-Z0-9]/.test(passphrase),
          };

          // Base score from length
          if (checks.length8) score += 1;
          if (checks.length12) score += 1;
          if (checks.length16) score += 1;

          // Character variety
          const varietyCount = [checks.lowercase, checks.uppercase, checks.numbers, checks.special].filter(Boolean).length;
          if (varietyCount >= 2) score += 1;
          if (varietyCount >= 3) score += 1;
          if (varietyCount >= 4) score += 1;

          // Cap at 4
          score = Math.min(score, 4);

          // Determine label and feedback
          let label, feedback;
          if (score <= 1) {
            label = "Weak";
            feedback = "Add more characters and mix letters, numbers, and symbols.";
          } else if (score === 2) {
            label = "Fair";
            feedback = "Consider adding more length or character variety.";
          } else if (score === 3) {
            label = "Good";
            feedback = "Good passphrase strength.";
          } else {
            label = "Strong";
            feedback = "Excellent passphrase strength!";
          }

          return { score, label, feedback };
        }

        // Update strength indicator on input
        passphraseInput.addEventListener("input", () => {
          const { score, label, feedback } = evaluatePassphraseStrength(passphraseInput.value);
          
          // Update fill width and color
          const strengthClasses = ["strength-weak", "strength-fair", "strength-good", "strength-strong"];
          strengthFill.className = "";
          
          if (score === 0) {
            strengthFill.style.width = "0%";
            strengthText.textContent = "";
          } else {
            strengthFill.style.width = `${score * 25}%`;
            strengthFill.classList.add(strengthClasses[Math.min(score - 1, 3)]);
            strengthText.textContent = `${label} — ${feedback}`;
          }
        });

        // Create confirmation input
        const confirmLabel = document.createElement("label");
        confirmLabel.setAttribute("for", "export-passphrase-confirm");
        confirmLabel.innerText = "Confirm Passphrase";
        formDiv.appendChild(confirmLabel);

        const confirmInput = document.createElement("input");
        confirmInput.type = "password";
        confirmInput.id = "export-passphrase-confirm";
        confirmInput.placeholder = "Confirm passphrase";
        confirmInput.required = true;
        confirmInput.setAttribute("aria-required", "true");
        confirmInput.setAttribute("autocomplete", "new-password");
        formDiv.appendChild(confirmInput);

        // Create error message paragraph
        const errorMsg = document.createElement("p");
        errorMsg.id = "passphrase-error";
        errorMsg.style.display = "none";
        formDiv.appendChild(errorMsg);

        // Create submit button
        const submitButton = document.createElement("button");
        submitButton.type = "submit";
        submitButton.id = "encrypt-and-export";
        submitButton.innerText = "Encrypt & Export";
        formDiv.appendChild(submitButton);

        // Append the form to the body
        document.body.appendChild(formDiv);

        // Add submit event listener to the form
        formDiv.addEventListener("submit", async (event) => {
          event.preventDefault();
          const passphrase = passphraseInput.value;
          const confirmPassphrase = confirmInput.value;

          // Validate minimum passphrase length (8 characters)
          if (passphrase.length < 8) {
            errorMsg.innerText =
              "Passphrase must be at least 8 characters long.";
            errorMsg.style.display = "block";
            return;
          }

          // Validate passphrases match
          if (passphrase !== confirmPassphrase) {
            errorMsg.innerText = "Passphrases do not match.";
            errorMsg.style.display = "block";
            return;
          }

          // Hide error message and disable button to prevent duplicate submissions
          errorMsg.style.display = "none";
          submitButton.disabled = true;

          try {
            // Encode mnemonic to Uint8Array
            const encoder = new TextEncoder();
            const mnemonicBytes = encoder.encode(mnemonic);

            // Encrypt with passphrase
            const encryptedBytes = await TKHQ.encryptWithPassphrase(
              mnemonicBytes,
              passphrase
            );

            // Convert to base64
            const encryptedBase64 = btoa(
              String.fromCharCode.apply(null, encryptedBytes)
            );

            // Clear passphrase fields for security before sending message
            passphraseInput.value = "";
            confirmInput.value = "";
            // Reset strength indicator
            strengthFill.style.width = "0%";
            strengthFill.className = "";
            strengthText.textContent = "";

            // Send message up
            TKHQ.sendMessageUp(
              "ENCRYPTED_WALLET_EXPORT",
              encryptedBase64,
              requestId
            );

            // Keep button disabled after success (operation complete)
          } catch (e) {
            // Clear passphrase fields for security
            passphraseInput.value = "";
            confirmInput.value = "";
            // Reset strength indicator
            strengthFill.style.width = "0%";
            strengthFill.className = "";
            strengthText.textContent = "";

            errorMsg.innerText = "Encryption failed: " + e.toString();
            errorMsg.style.display = "block";
            submitButton.disabled = false;
          }
        });
      }

      /**
       * Parse and decrypt the export bundle.
       * The `bundle` param is a JSON string of the encapsulated public
       * key, encapsulated public key signature, and the ciphertext.
       * Example: {"encappedPublic":"04912cb4200c40f04ae4a162f4c870c78cb4498a8efda0b94f4a9cb848d611bd40e9acccab2bf73cee1e269d8350a02f4df71864921097838f05c288d944fa2f8b","encappedPublicSignature":"304502200cd19a3c5892f1eeab88fe0cdd7cca63736a7d15fc364186fb3c913e1e01568b022100dea49557c176f6ca052b27ad164f077cf64d2aa55fbdc4757a14767f8b8c6b48","ciphertext":"0e5d5503f43721135818051e4c5b77b3365b66ec4020b0051d59ea9fc773c67bd4b61ed34a97b07a3074a85546721ae4","enclaveQuorumPublic":"04cf288fe433cc4e1aa0ce1632feac4ea26bf2f5a09dcfe5a42c398e06898710330f0572882f4dbdf0f5304b8fc8703acd69adca9a4bbf7f5d00d20a5e364b2569"}
       * @param {string} bundle
       * @param {string} organizationId
       */
      async function decryptBundle(bundle, organizationId) {
        let encappedKeyBuf;
        let ciphertextBuf;
        let verified;

        // Parse the import bundle
        const bundleObj = JSON.parse(bundle);
        switch (bundleObj.version) {
          case "v1.0.0":
            // Validate fields exist
            if (!bundleObj.data) {
              throw new Error('missing "data" in bundle');
            }
            if (!bundleObj.dataSignature) {
              throw new Error('missing "dataSignature" in bundle');
            }
            if (!bundleObj.enclaveQuorumPublic) {
              throw new Error('missing "enclaveQuorumPublic" in bundle');
            }

            // Verify enclave signature
            if (!TKHQ.verifyEnclaveSignature) {
              throw new Error("method not loaded");
            }
            verified = await TKHQ.verifyEnclaveSignature(
              bundleObj.enclaveQuorumPublic,
              bundleObj.dataSignature,
              bundleObj.data
            );
            if (!verified) {
              throw new Error(`failed to verify enclave signature: ${bundle}`);
            }

            // Parse the signed data. The data is produced by JSON encoding followed by hex encoding. We reverse this here.
            const signedData = JSON.parse(
              new TextDecoder().decode(
                TKHQ.uint8arrayFromHexString(bundleObj.data)
              )
            );

            // Validate fields match
            if (!organizationId) {
              // todo: throw error if organization id is undefined once we've fully transitioned to v1.0.0 server messages and v2.0.0 iframe-stamper
              console.warn(
                'we highly recommend a version of @turnkey/iframe-stamper >= v2.0.0 to pass "organizationId" for security purposes.'
              );
            } else if (
              !signedData.organizationId ||
              signedData.organizationId !== organizationId
            ) {
              throw new Error(
                `organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`
              );
            }

            if (!signedData.encappedPublic) {
              throw new Error('missing "encappedPublic" in bundle signed data');
            }
            if (!signedData.ciphertext) {
              throw new Error('missing "ciphertext" in bundle signed data');
            }
            encappedKeyBuf = TKHQ.uint8arrayFromHexString(
              signedData.encappedPublic
            );
            ciphertextBuf = TKHQ.uint8arrayFromHexString(signedData.ciphertext);
            break;
          default:
            throw new Error(`unsupported version: ${bundleObj.version}`);
        }

        // Decrypt the ciphertext
        const embeddedKeyJwk = await TKHQ.getEmbeddedKey();
        return await HpkeDecrypt({
          ciphertextBuf,
          encappedKeyBuf,
          receiverPrivJwk: embeddedKeyJwk,
        });
      }

      /**
       * Function triggered when INJECT_KEY_EXPORT_BUNDLE event is received.
       * @param {string} bundle
       * @param {string} keyFormat
       * @param {string} organizationId
       * @param {string} requestId
       */
      async function onInjectKeyBundle(
        bundle,
        keyFormat,
        organizationId,
        requestId
      ) {
        // Decrypt the export bundle
        const keyBytes = await decryptBundle(bundle, organizationId);

        // Reset embedded key after using for decryption
        TKHQ.onResetEmbeddedKey();

        // Parse the decrypted key bytes
        var key;
        const privateKeyBytes = new Uint8Array(keyBytes);
        if (keyFormat === "SOLANA") {
          const privateKeyHex = TKHQ.uint8arrayToHexString(
            privateKeyBytes.subarray(0, 32)
          );
          const publicKeyBytes = TKHQ.getEd25519PublicKey(privateKeyHex);
          key = await TKHQ.encodeKey(
            privateKeyBytes,
            keyFormat,
            publicKeyBytes
          );
        } else {
          key = await TKHQ.encodeKey(privateKeyBytes, keyFormat);
        }

        // Display only the key
        displayKey(key);

        // Send up BUNDLE_INJECTED message
        TKHQ.sendMessageUp("BUNDLE_INJECTED", true, requestId);
      }

      /**
       * Function triggered when INJECT_WALLET_EXPORT_BUNDLE event is received.
       * @param {string} bundle
       * @param {string} organizationId
       * @param {string} requestId
       */
      async function onInjectWalletBundle(bundle, organizationId, requestId) {
        // Decrypt the export bundle
        const walletBytes = await decryptBundle(bundle, organizationId);

        // Reset embedded key after using for decryption
        TKHQ.onResetEmbeddedKey();

        // Parse the decrypted wallet bytes
        const wallet = TKHQ.encodeWallet(new Uint8Array(walletBytes));

        // Display only the wallet's mnemonic
        displayKey(wallet.mnemonic);

        // Send up BUNDLE_INJECTED message
        TKHQ.sendMessageUp("BUNDLE_INJECTED", true, requestId);
      }

      /**
       * Function triggered when INJECT_WALLET_EXPORT_BUNDLE_ENCRYPTED event is received.
       * @param {string} bundle
       * @param {string} organizationId
       * @param {string} requestId
       */
      async function onInjectWalletBundleEncrypted(
        bundle,
        organizationId,
        requestId
      ) {
        // Decrypt the export bundle
        const walletBytes = await decryptBundle(bundle, organizationId);

        // Reset embedded key after using for decryption
        TKHQ.onResetEmbeddedKey();

        // Parse the decrypted wallet bytes
        const wallet = TKHQ.encodeWallet(new Uint8Array(walletBytes));

        // Display passphrase form instead of showing the key directly
        displayPassphraseForm(wallet.mnemonic, requestId);
      }

      /**
       * Function triggered when APPLY_SETTINGS event is received.
       * For now, the only settings that can be applied are for "styles".
       * Persist them in local storage so they can be applied on every
       * page load.
       * @param {string} settings: JSON-stringified settings
       * @param {string} requestId
       */
      async function onApplySettings(settings, requestId) {
        // Apply settings
        const validSettings = TKHQ.applySettings(settings);

        // Persist in local storage
        TKHQ.setSettings(validSettings);

        // Send up SETTINGS_APPLIED message
        TKHQ.sendMessageUp("SETTINGS_APPLIED", true, requestId);
      }

      /**
       * Decrypt the ciphertext (ArrayBuffer) given an encapsulation key (ArrayBuffer)
       * and the receivers private key (JSON Web Key).
       */
      async function HpkeDecrypt({
        ciphertextBuf,
        encappedKeyBuf,
        receiverPrivJwk,
      }) {
        const kemContext = new hpke.DhkemP256HkdfSha256();
        var receiverPriv = await kemContext.importKey(
          "jwk",
          { ...receiverPrivJwk },
          false
        );

        var suite = new hpke.CipherSuite({
          kem: kemContext,
          kdf: new hpke.HkdfSha256(),
          aead: new hpke.Aes256Gcm(),
        });

        var recipientCtx = await suite.createRecipientContext({
          recipientKey: receiverPriv,
          enc: encappedKeyBuf,
          info: new TextEncoder().encode("turnkey_hpke"),
        });

        var receiverPubBuf = await TKHQ.p256JWKPrivateToPublic(receiverPrivJwk);
        var aad = TKHQ.additionalAssociatedData(encappedKeyBuf, receiverPubBuf);
        var res;
        try {
          res = await recipientCtx.open(ciphertextBuf, aad);
        } catch (e) {
          throw new Error(
            "unable to decrypt bundle using embedded key. the bundle may be incorrect. failed with error: " +
              e.toString()
          );
        }
        return res;
      }
    </script>
  </body>
</html>
