<!DOCTYPE html>
<html class="no-js" lang="">
  <head>
    <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
    <meta charset="utf-8" />
    <title>Turnkey Export</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <style>
      body {
        text-align: center;
        font-family: "Lucida Sans", "Lucida Sans Regular", "Lucida Grande",
          "Lucida Sans Unicode", Geneva, Verdana, sans-serif;
        max-width: 1024px;
        margin: auto;
      }
      label {
        display: inline-block;
        width: 8em;
      }
      form {
        text-align: left;
      }
      input[type="text"],
      select {
        width: 40em;
        margin: 0.5em;
        font-family: "Courier New", Courier, monospace;
        font-size: 1em;
        height: 1.8em;
        color: rgb(18, 87, 18);
        border: 1px rgb(217, 240, 221) solid;
        border-radius: 4px;
      }
      input:disabled {
        background-color: rgb(239, 243, 240);
      }
      #reset {
        color: white;
        width: 7em;
        font-size: 1em;
        padding: 0.38em;
        border-radius: 4px;
        background-color: rgb(187, 100, 100);
        border: 1px rgb(112, 42, 42) solid;
        cursor: pointer;
        display: inline;
      }
      #inject-key,
      #inject-wallet {
        color: white;
        width: 7em;
        font-size: 1em;
        padding: 0.38em;
        border-radius: 4px;
        background-color: rgb(50, 44, 44);
        border: 1px rgb(33, 33, 33) solid;
        cursor: pointer;
        display: inline;
      }
      #message-log {
        border: 1px #2a2828 solid;
        padding: 0 0.7em;
        border-radius: 4px;
        margin-top: 2em;
        max-width: 800px;
        margin: auto;
        display: block;
      }
      #message-log p {
        font-size: 0.9em;
        text-align: left;
        word-break: break-all;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>

  <body>
    <h2>Export Key Material</h2>
    <p>
      <em
        >This public key will be sent along with a private key ID or wallet ID
        inside of a new <code>EXPORT_PRIVATE_KEY</code> or
        <code>EXPORT_WALLET</code> activity</em
      >
    </p>
    <form>
      <label>Embedded key</label>
      <input type="text" name="embedded-key" id="embedded-key" disabled />
      <button id="reset">Reset Key</button>
    </form>
    <br />
    <br />
    <br />
    <h2>Inject Key Export Bundle</h2>
    <p>
      <em
        >The export bundle comes from the parent page and is composed of a
        public key and an encrypted payload. The payload is encrypted to this
        document's embedded key (stored in local storage and displayed above).
        The scheme relies on
        <a target="_blank" href="https://datatracker.ietf.org/doc/rfc9180/"
          >HPKE (RFC 9180)</a
        ></em
      >.
    </p>
    <form>
      <label>Bundle</label>
      <input type="text" name="key-export-bundle" id="key-export-bundle" />
      <button id="inject-key">Inject Bundle</button>
      <br />
      <label>Key Format</label>
      <select id="key-export-format" name="key-export-format">
        <option value="HEXADECIMAL">Hexadecimal (Default)</option>
        <option value="SOLANA">Solana</option>
      </select>
      <br />
      <label>Organization Id</label>
      <input type="text" name="key-organization-id" id="key-organization-id" />
    </form>
    <br />
    <h2>Inject Wallet Export Bundle</h2>
    <p>
      <em
        >The export bundle comes from the parent page and is composed of a
        public key and an encrypted payload. The payload is encrypted to this
        document's embedded key (stored in local storage and displayed above).
        The scheme relies on
        <a target="_blank" href="https://datatracker.ietf.org/doc/rfc9180/"
          >HPKE (RFC 9180)</a
        ></em
      >.
    </p>
    <form>
      <label>Bundle</label>
      <input
        type="text"
        name="wallet-export-bundle"
        id="wallet-export-bundle"
      />
      <button id="inject-wallet">Inject Bundle</button>
      <br />
      <label>Organization Id</label>
      <input
        type="text"
        name="wallet-organization-id"
        id="wallet-organization-id"
      />
    </form>
    <br />
    <br />
    <h2>Message log</h2>
    <p>
      <em
        >Below we display a log of the messages sent / received. The forms above
        send messages, and the code communicates results by sending events via
        the <code>postMessage</code> API.</em
      >
    </p>
    <div id="message-log"></div>
    <div id="key-div"></div>

    <!-- Script containing ED25519 library -->
    <script src="noble-hashes.js"></script>
    <script src="noble-ed25519.js"></script>
    <!--
    Script defining important helpers.
    These helpers are unit-testable, so most of the logic should be written here.
  -->
    <script>
      window.TKHQ = (function () {
        /** constant for LocalStorage */
        const TURNKEY_EMBEDDED_KEY = "TURNKEY_EMBEDDED_KEY";
        const TURNKEY_SETTINGS = "TURNKEY_SETTINGS";
        /** 48 hours in milliseconds */
        const TURNKEY_EMBEDDED_KEY_TTL_IN_MILLIS = 1000 * 60 * 60 * 48;

        var parentFrameMessageChannelPort = null;

        /*
         * Loads the quorum public key as a CryptoKey.
         */
        async function loadQuorumKey(quorumPublic) {
          return await crypto.subtle.importKey(
            "raw",
            quorumPublic,
            {
              name: "ECDSA",
              namedCurve: "P-256",
            },
            true,
            ["verify"]
          );
        }

        /**
         * Creates a new public/private key pair and persists it in localStorage
         */
        async function initEmbeddedKey() {
          const retrievedKey = await getEmbeddedKey();
          if (retrievedKey === null) {
            const targetKey = await generateTargetKey();
            setEmbeddedKey(targetKey);
          }
          // Nothing to do, key is correctly initialized!
        }

        /*
         * Generate a key to encrypt to and export it as a JSON Web Key.
         */
        async function generateTargetKey() {
          const p256key = await crypto.subtle.generateKey(
            {
              name: "ECDH",
              namedCurve: "P-256",
            },
            true,
            ["deriveBits"]
          );

          return await crypto.subtle.exportKey("jwk", p256key.privateKey);
        }

        /**
         * Gets the current embedded private key JWK. Returns `null` if not found.
         */
        function getEmbeddedKey() {
          const jwtKey = TKHQ.getItemWithExpiry(TURNKEY_EMBEDDED_KEY);
          return jwtKey ? JSON.parse(jwtKey) : null;
        }

        /**
         * Sets the embedded private key JWK with the default expiration time.
         * @param {JsonWebKey} targetKey
         */
        function setEmbeddedKey(targetKey) {
          setItemWithExpiry(
            TURNKEY_EMBEDDED_KEY,
            JSON.stringify(targetKey),
            TURNKEY_EMBEDDED_KEY_TTL_IN_MILLIS
          );
        }

        function setParentFrameMessageChannelPort(port) {
          parentFrameMessageChannelPort = port;
        }

        /**
         * Resets the current embedded private key JWK.
         */
        function onResetEmbeddedKey() {
          window.localStorage.removeItem(TURNKEY_EMBEDDED_KEY);
        }

        /**
         * Gets the current settings.
         */
        function getSettings() {
          const settings = window.localStorage.getItem(TURNKEY_SETTINGS);
          return settings ? JSON.parse(settings) : null;
        }

        /**
         * Sets the settings object.
         * @param {Object} settings
         */
        function setSettings(settings) {
          window.localStorage.setItem(
            TURNKEY_SETTINGS,
            JSON.stringify(settings)
          );
        }

        /**
         * Set an item in localStorage with an expiration time
         * @param {string} key
         * @param {string} value
         * @param {number} ttl expiration time in milliseconds
         */
        function setItemWithExpiry(key, value, ttl) {
          const now = new Date();
          const item = {
            value: value,
            expiry: now.getTime() + ttl,
          };
          window.localStorage.setItem(key, JSON.stringify(item));
        }

        /**
         * Get an item from localStorage. Returns `null` and
         * removes the item from localStorage if expired or
         * expiry time is missing.
         * @param {string} key
         */
        function getItemWithExpiry(key) {
          const itemStr = window.localStorage.getItem(key);
          if (!itemStr) {
            return null;
          }
          const item = JSON.parse(itemStr);
          if (!item.hasOwnProperty("expiry") || !item.hasOwnProperty("value")) {
            window.localStorage.removeItem(key);
            return null;
          }
          const now = new Date();
          if (now.getTime() > item.expiry) {
            window.localStorage.removeItem(key);
            return null;
          }
          return item.value;
        }

        /**
         * Takes a hex string (e.g. "e4567ab") and returns an array buffer (Uint8Array)
         * @param {string} hexString
         * @returns {Uint8Array}
         */
        function uint8arrayFromHexString(hexString) {
          var hexRegex = /^[0-9A-Fa-f]+$/;
          if (
            !hexString ||
            hexString.length % 2 != 0 ||
            !hexRegex.test(hexString)
          ) {
            throw new Error("cannot create uint8array from invalid hex string");
          }
          return new Uint8Array(
            hexString.match(/../g).map((h) => parseInt(h, 16))
          );
        }

        /**
         * Takes a Uint8Array and returns a hex string
         * @param {Uint8Array} buffer
         * @return {string}
         */
        function uint8arrayToHexString(buffer) {
          return [...buffer]
            .map((x) => x.toString(16).padStart(2, "0"))
            .join("");
        }

        /**
         * Function to normalize padding of byte array with 0's to a target length
         */
        function normalizePadding(byteArray, targetLength) {
          const paddingLength = targetLength - byteArray.length;

          // Add leading 0's to array
          if (paddingLength > 0) {
            const padding = new Uint8Array(paddingLength).fill(0);
            return new Uint8Array([...padding, ...byteArray]);
          }

          // Remove leading 0's from array
          if (paddingLength < 0) {
            const expectedZeroCount = paddingLength * -1;
            let zeroCount = 0;
            for (
              let i = 0;
              i < expectedZeroCount && i < byteArray.length;
              i++
            ) {
              if (byteArray[i] === 0) {
                zeroCount++;
              }
            }
            // Check if the number of zeros found equals the number of zeroes expected
            if (zeroCount !== expectedZeroCount) {
              throw new Error(
                `invalid number of starting zeroes. Expected number of zeroes: ${expectedZeroCount}. Found: ${zeroCount}.`
              );
            }
            return byteArray.slice(
              expectedZeroCount,
              expectedZeroCount + targetLength
            );
          }
          return byteArray;
        }

        /**
         * Additional Associated Data (AAD) in the format dictated by the enclave_encrypt crate.
         */
        function additionalAssociatedData(senderPubBuf, receiverPubBuf) {
          const s = Array.from(new Uint8Array(senderPubBuf));
          const r = Array.from(new Uint8Array(receiverPubBuf));
          return new Uint8Array([...s, ...r]);
        }

        /**
         * Converts an ASN.1 DER-encoded ECDSA signature to the raw format that WebCrypto uses.
         */
        function fromDerSignature(derSignature) {
          const derSignatureBuf = uint8arrayFromHexString(derSignature);

          // Check and skip the sequence tag (0x30)
          let index = 2;

          // Parse 'r' and check for integer tag (0x02)
          if (derSignatureBuf[index] !== 0x02) {
            throw new Error(
              "failed to convert DER-encoded signature: invalid tag for r"
            );
          }
          index++; // Move past the INTEGER tag
          const rLength = derSignatureBuf[index];
          index++; // Move past the length byte
          const r = derSignatureBuf.slice(index, index + rLength);
          index += rLength; // Move to the start of s

          // Parse 's' and check for integer tag (0x02)
          if (derSignatureBuf[index] !== 0x02) {
            throw new Error(
              "failed to convert DER-encoded signature: invalid tag for s"
            );
          }
          index++; // Move past the INTEGER tag
          const sLength = derSignatureBuf[index];
          index++; // Move past the length byte
          const s = derSignatureBuf.slice(index, index + sLength);

          // Normalize 'r' and 's' to 32 bytes each
          const rPadded = normalizePadding(r, 32);
          const sPadded = normalizePadding(s, 32);

          // Concatenate and return the raw signature
          return new Uint8Array([...rPadded, ...sPadded]);
        }

        /**
         * Function to verify enclave signature on import bundle received from the server.
         * @param {string} enclaveQuorumPublic uncompressed public key for the quorum key which produced the signature
         * @param {string} publicSignature signature bytes encoded as a hexadecimal string
         * @param {string} signedData signed bytes encoded as a hexadecimal string. This could be public key bytes directly, or JSON-encoded bytes
         */
        async function verifyEnclaveSignature(
          enclaveQuorumPublic,
          publicSignature,
          signedData
        ) {
          /** Turnkey Signer enclave's public keys */
          const TURNKEY_SIGNERS_ENCLAVES = {
            prod: "04cf288fe433cc4e1aa0ce1632feac4ea26bf2f5a09dcfe5a42c398e06898710330f0572882f4dbdf0f5304b8fc8703acd69adca9a4bbf7f5d00d20a5e364b2569",
            preprod:
              "04f3422b8afbe425d6ece77b8d2469954715a2ff273ab7ac89f1ed70e0a9325eaa1698b4351fd1b23734e65c0b6a86b62dd49d70b37c94606aac402cbd84353212",
          };
          const TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY =
            TURNKEY_SIGNERS_ENCLAVES["${TURNKEY_SIGNER_ENVIRONMENT}"];
          if (TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY === undefined) {
            throw new Error(
              "Configuration error: TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY is undefined"
            );
          }

          // todo(olivia): throw error if enclave quorum public is null once server changes are deployed
          if (enclaveQuorumPublic) {
            if (
              enclaveQuorumPublic !== TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY
            ) {
              throw new Error(
                `enclave quorum public keys from client and bundle do not match. Client: ${TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY}. Bundle: ${enclaveQuorumPublic}.`
              );
            }
          }

          const encryptionQuorumPublicBuf = new Uint8Array(
            uint8arrayFromHexString(TURNKEY_SIGNER_ENCLAVE_QUORUM_PUBLIC_KEY)
          );
          const quorumKey = await loadQuorumKey(encryptionQuorumPublicBuf);
          if (!quorumKey) {
            throw new Error("failed to load quorum key");
          }

          // The ECDSA signature is ASN.1 DER encoded but WebCrypto uses raw format
          const publicSignatureBuf = fromDerSignature(publicSignature);
          const signedDataBuf = uint8arrayFromHexString(signedData);
          return await crypto.subtle.verify(
            { name: "ECDSA", hash: "SHA-256" },
            quorumKey,
            publicSignatureBuf,
            signedDataBuf
          );
        }

        /**
         * Function to send a message.
         *
         * If this page is embedded as an iframe we'll send a postMessage
         * in one of two ways depending on the version of @turnkey/iframe-stamper:
         *   1. newer versions (>=v2.1.0) pass a MessageChannel MessagePort from the parent frame for postMessages.
         *   2. older versions (<v2.1.0) still use the contentWindow so we will postMessage to the window.parent for backwards compatibility.
         *
         * Otherwise we'll display it in the DOM.
         * @param type message type. Can be "PUBLIC_KEY_CREATED" or "BUNDLE_INJECTED"
         * @param value message value
         * @param requestId serves as an idempotency key to match incoming requests. Backwards compatible: if not provided, it isn't passed in.
         */
        function sendMessageUp(type, value, requestId) {
          const message = {
            type: type,
            value: value,
          };

          // Only include requestId if it was provided
          if (requestId) {
            message.requestId = requestId;
          }

          if (parentFrameMessageChannelPort) {
            parentFrameMessageChannelPort.postMessage(message);
          } else if (window.parent !== window) {
            window.parent.postMessage(
              {
                type: type,
                value: value,
              },
              "*"
            );
          }
          logMessage(`⬆️ Sent message ${type}: ${value}`);
        }

        /**
         * Function to log a message and persist it in the page's DOM.
         */
        function logMessage(content) {
          const messageLog = document.getElementById("message-log");
          const message = document.createElement("p");
          message.innerText = content;
          messageLog.appendChild(message);
        }

        /**
         * Convert a JSON Web Key private key to a public key and export the public
         * key in raw format.
         * @return {Uint8array}
         */
        async function p256JWKPrivateToPublic(jwkPrivate) {
          // make a copy so we don't modify the underlying object
          const jwkPrivateCopy = { ...jwkPrivate };
          // change jwk so it will be imported as a public key
          delete jwkPrivateCopy.d;
          jwkPrivateCopy.key_ops = ["verify"];

          const publicKey = await window.crypto.subtle.importKey(
            "jwk",
            jwkPrivateCopy,
            { name: "ECDSA", namedCurve: "P-256" },
            true,
            ["verify"]
          );
          const buffer = await crypto.subtle.exportKey("raw", publicKey);
          return new Uint8Array(buffer);
        }

        /**
         * Encodes a buffer into a base58-encoded string.
         * @param {Uint8Array} bytes The buffer to encode.
         * @return {string} The base58-encoded string.
         */
        function base58Encode(bytes) {
          // See https://en.bitcoin.it/wiki/Base58Check_encoding
          const alphabet =
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
          let result = "";
          let digits = [0];
          for (let i = 0; i < bytes.length; i++) {
            let carry = bytes[i];
            for (let j = 0; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % 58;
              carry = (carry / 58) | 0;
            }

            while (carry > 0) {
              digits.push(carry % 58);
              carry = (carry / 58) | 0;
            }
          }
          // Convert digits to a base58 string
          for (let k = 0; k < digits.length; k++) {
            result = alphabet[digits[k]] + result;
          }

          // Add '1' for each leading 0 byte
          for (let i = 0; bytes[i] === 0 && i < bytes.length - 1; i++) {
            result = "1" + result;
          }
          return result;
        }

        /**
         * Decodes a base58-encoded string into a buffer
         * This function throws an error when the string contains invalid characters.
         * @param {string} s The base58-encoded string.
         * @return {Uint8Array} The decoded buffer.
         */
        function base58Decode(s) {
          // See https://en.bitcoin.it/wiki/Base58Check_encoding
          var alphabet =
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
          var decoded = BigInt(0);
          var decodedBytes = [];
          var leadingZeros = [];
          for (var i = 0; i < s.length; i++) {
            if (alphabet.indexOf(s[i]) === -1) {
              throw new Error(
                `cannot base58-decode: ${s[i]} isn't a valid character`
              );
            }
            var carry = alphabet.indexOf(s[i]);

            // If the current base58 digit is 0, append a 0 byte.
            // "i == leadingZeros.length" can only be true if we have not seen non-zero bytes so far.
            // If we had seen a non-zero byte, carry wouldn't be 0, and i would be strictly more than `leadingZeros.length`
            if (carry == 0 && i === leadingZeros.length) {
              leadingZeros.push(0);
            }

            var j = 0;
            while (j < decodedBytes.length || carry > 0) {
              var currentByte = decodedBytes[j];

              // shift the current byte 58 units and add the carry amount
              // (or just add the carry amount if this is a new byte -- undefined case)
              if (currentByte === undefined) {
                currentByte = carry;
              } else {
                currentByte = currentByte * 58 + carry;
              }

              // find the new carry amount (1-byte shift of current byte value)
              carry = currentByte >> 8;
              // reset the current byte to the remainder (the carry amount will pass on the overflow)
              decodedBytes[j] = currentByte % 256;
              j++;
            }
          }

          var result = leadingZeros.concat(decodedBytes.reverse());
          return new Uint8Array(result);
        }

        /**
         * Returns a private key from private key bytes, represented in
         * the encoding and format specified by `keyFormat`. Defaults to
         * hex-encoding if `keyFormat` isn't passed.
         * @param {Uint8Array} privateKeyBytes
         * @param {string} keyFormat Can be "HEXADECIMAL" or "SOLANA"
         */
        async function encodeKey(privateKeyBytes, keyFormat, publicKeyBytes) {
          switch (keyFormat) {
            case "SOLANA":
              if (!publicKeyBytes) {
                throw new Error(
                  "public key must be specified for SOLANA key format"
                );
              }
              if (privateKeyBytes.length !== 32) {
                throw new Error(
                  `invalid private key length. Expected 32 bytes. Got ${privateKeyBytes.length}.`
                );
              }
              if (publicKeyBytes.length !== 32) {
                throw new Error(
                  `invalid public key length. Expected 32 bytes. Got ${publicKeyBytes.length}.`
                );
              }
              const concatenatedBytes = new Uint8Array(64);
              concatenatedBytes.set(privateKeyBytes, 0);
              concatenatedBytes.set(publicKeyBytes, 32);
              return base58Encode(concatenatedBytes);
            case "HEXADECIMAL":
              return "0x" + uint8arrayToHexString(privateKeyBytes);
            default:
              console.warn(
                `invalid key format: ${keyFormat}. Defaulting to HEXADECIMAL.`
              );
              return "0x" + uint8arrayToHexString(privateKeyBytes);
          }
        }

        /**
         * Returns a UTF-8 encoded wallet mnemonic + newline optional passphrase
         * from wallet bytes.
         * @param {Uint8Array} walletBytes
         */
        function encodeWallet(walletBytes) {
          const decoder = new TextDecoder("utf-8");
          const wallet = decoder.decode(walletBytes);
          let mnemonic;
          let passphrase = null;

          if (wallet.includes("\n")) {
            const parts = wallet.split("\n");
            mnemonic = parts[0];
            passphrase = parts[1];
          } else {
            mnemonic = wallet;
          }

          return {
            mnemonic: mnemonic,
            passphrase: passphrase,
          };
        }

        /**
         * Returns the public key bytes for a hex-encoded Ed25519 private key.
         * @param {string} privateKeyHex
         */
        function getEd25519PublicKey(privateKeyHex) {
          nobleEd25519.etc.sha512Sync = (...m) =>
            nobleHashes.sha512(nobleEd25519.etc.concatBytes(...m));
          return nobleEd25519.getPublicKey(privateKeyHex);
        }

        /**
         * Function to validate and sanitize the styles object using the accepted map of style keys and values (as regular expressions).
         * Any invalid style throws an error. Returns an object of valid styles.
         * @param {Object} styles
         * @return {Object}
         */
        function validateStyles(styles, element) {
          const validStyles = {};

          const cssValidationRegex = {
            padding: "^(\\d+(px|em|%|rem) ?){1,4}$",
            margin: "^(\\d+(px|em|%|rem) ?){1,4}$",
            borderWidth: "^(\\d+(px|em|rem) ?){1,4}$",
            borderStyle:
              "^(none|solid|dashed|dotted|double|groove|ridge|inset|outset)$",
            borderColor:
              "^(transparent|inherit|initial|#[0-9a-f]{3,8}|rgba?\\(\\d{1,3}, \\d{1,3}, \\d{1,3}(, \\d?(\\.\\d{1,2})?)?\\)|hsla?\\(\\d{1,3}, \\d{1,3}%, \\d{1,3}%(, \\d?(\\.\\d{1,2})?)?\\))$",
            borderRadius: "^(\\d+(px|em|%|rem) ?){1,4}$",
            fontSize:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax))$",
            fontWeight: "^(normal|bold|bolder|lighter|\\d{3})$",
            fontFamily: '^[^";<>]*$', // checks for the absence of some characters that could lead to CSS/HTML injection
            color:
              "^(transparent|inherit|initial|#[0-9a-f]{3,8}|rgba?\\(\\d{1,3}, \\d{1,3}, \\d{1,3}(, \\d?(\\.\\d{1,2})?)?\\)|hsla?\\(\\d{1,3}, \\d{1,3}%, \\d{1,3}%(, \\d?(\\.\\d{1,2})?)?\\))$",
            backgroundColor:
              "^(transparent|inherit|initial|#[0-9a-f]{3,8}|rgba?\\(\\d{1,3}, \\d{1,3}, \\d{1,3}(, \\d?(\\.\\d{1,2})?)?\\)|hsla?\\(\\d{1,3}, \\d{1,3}%, \\d{1,3}%(, \\d?(\\.\\d{1,2})?)?\\))$",
            width:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|auto)$",
            height:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|auto)$",
            maxWidth:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|none)$",
            maxHeight:
              "^(\\d+(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|none)$",
            lineHeight:
              "^(\\d+(\\.\\d+)?(px|em|rem|%|vh|vw|in|cm|mm|pt|pc|ex|ch|vmin|vmax)|normal)$",
            boxShadow:
              "^(none|(\\d+(px|em|rem) ?){2,4} (#[0-9a-f]{3,8}|rgba?\\(\\d{1,3}, \\d{1,3}, \\d{1,3}(, \\d?(\\.\\d{1,2})?)?\\)) ?(inset)?)$",
            textAlign: "^(left|right|center|justify|initial|inherit)$",
            overflowWrap: "^(normal|break-word|anywhere)$",
            wordWrap: "^(normal|break-word)$",
            resize: "^(none|both|horizontal|vertical|block|inline)$",
          };

          Object.entries(styles).forEach(([property, value]) => {
            const styleProperty = property.trim();
            if (styleProperty.length === 0) {
              throw new Error("css style property cannot be empty");
            }
            const styleRegexStr = cssValidationRegex[styleProperty];
            if (!styleRegexStr) {
              throw new Error(
                `invalid or unsupported css style property: "${styleProperty}"`
              );
            }
            const styleRegex = new RegExp(styleRegexStr);
            const styleValue = value.trim();
            if (styleValue.length == 0) {
              throw new Error(`css style for "${styleProperty}" is empty`);
            }
            const isValidStyle = styleRegex.test(styleValue);
            if (!isValidStyle) {
              throw new Error(
                `invalid css style value for property "${styleProperty}"`
              );
            }
            validStyles[styleProperty] = styleValue;
          });

          return validStyles;
        }

        /**
         * Function to apply settings on this page. For now, the only settings that can be applied
         * are for "styles". Upon successful application, return the valid, sanitized settings JSON string.
         * @param {string} settings
         * @return {string}
         */
        function applySettings(settings) {
          const validSettings = {};
          if (!settings) {
            return JSON.stringify(validSettings);
          }
          const settingsObj = JSON.parse(settings);
          if (settingsObj.styles) {
            // Valid styles will be applied the "key-div" div HTML element.
            const keyDivTextarea = document.getElementById("key-div");
            if (!keyDivTextarea) {
              throw new Error(
                "no key-div HTML element found to apply settings to."
              );
            }

            // Validate, sanitize, and apply the styles to the "key-div" div element.
            const validStyles = TKHQ.validateStyles(settingsObj.styles);
            Object.entries(validStyles).forEach(([key, value]) => {
              keyDivTextarea.style[key] = value;
            });

            validSettings["styles"] = validStyles;
          }

          return JSON.stringify(validSettings);
        }

        return {
          initEmbeddedKey,
          generateTargetKey,
          setItemWithExpiry,
          getItemWithExpiry,
          getEmbeddedKey,
          setEmbeddedKey,
          onResetEmbeddedKey,
          p256JWKPrivateToPublic,
          base58Encode,
          base58Decode,
          encodeKey,
          encodeWallet,
          sendMessageUp,
          logMessage,
          uint8arrayFromHexString,
          uint8arrayToHexString,
          setParentFrameMessageChannelPort,
          normalizePadding,
          fromDerSignature,
          additionalAssociatedData,
          verifyEnclaveSignature,
          getEd25519PublicKey,
          applySettings,
          validateStyles,
          getSettings,
          setSettings,
        };
      })();
    </script>

    <script type="module">
      // Vendor @hpke/core from https://esm.sh/@hpke/core@1.2.7
      import * as hpke from "./hpke-core.js";

      // persist the MessageChannel object so we can use it to communicate with the parent window
      var iframeMessagePort = null;

      // controllers to remove event listeners
      const messageListenerController = new AbortController();
      const turnkeyInitController = new AbortController();

      /**
       * DOM Event handlers to power the export flow in standalone mode
       * Instead of receiving events from the parent page, forms trigger them.
       * This is useful for debugging as well.
       */
      var addDOMEventListeners = function () {
        document.getElementById("inject-key").addEventListener(
          "click",
          async (e) => {
            e.preventDefault();
            window.postMessage({
              type: "INJECT_KEY_EXPORT_BUNDLE",
              value: document.getElementById("key-export-bundle").value,
              keyFormat: document.getElementById("key-export-format").value,
              organizationId: document.getElementById("key-organization-id")
                .value,
            });
          },
          false
        );
        document.getElementById("inject-wallet").addEventListener(
          "click",
          async (e) => {
            e.preventDefault();
            window.postMessage({
              type: "INJECT_WALLET_EXPORT_BUNDLE",
              value: document.getElementById("wallet-export-bundle").value,
              organizationId: document.getElementById("wallet-organization-id")
                .value,
            });
          },
          false
        );
        document.getElementById("reset").addEventListener(
          "click",
          async (e) => {
            e.preventDefault();
            window.postMessage({ type: "RESET_EMBEDDED_KEY" });
          },
          false
        );
      };

      /**
       * Message Event Handlers to process messages from the parent frame
       */
      var messageEventListener = async function (event) {
        if (event.data && event.data["type"] == "INJECT_KEY_EXPORT_BUNDLE") {
          TKHQ.logMessage(
            `⬇️ Received message ${event.data["type"]}: ${event.data["value"]}, ${event.data["keyFormat"]}, ${event.data["organizationId"]}`
          );
          try {
            await onInjectKeyBundle(
              event.data["value"],
              event.data["keyFormat"],
              event.data["organizationId"],
              event.data["requestId"]
            );
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString(), event.data["requestId"]);
          }
        }
        if (event.data && event.data["type"] == "INJECT_WALLET_EXPORT_BUNDLE") {
          TKHQ.logMessage(
            `⬇️ Received message ${event.data["type"]}: ${event.data["value"]}, ${event.data["organizationId"]}`
          );
          try {
            await onInjectWalletBundle(
              event.data["value"],
              event.data["organizationId"],
              event.data["requestId"]
            );
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString(), event.data["requestId"]);
          }
        }
        if (event.data && event.data["type"] == "APPLY_SETTINGS") {
          try {
            await onApplySettings(event.data["value"], event.data["requestId"]);
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString(), event.data["requestId"]);
          }
        }
        if (event.data && event.data["type"] == "RESET_EMBEDDED_KEY") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}`);
          try {
            TKHQ.onResetEmbeddedKey();
          } catch (e) {
            TKHQ.sendMessageUp("ERROR", e.toString());
          }
        }
      };

      /**
       * Initialize the embedded key and set up the DOM and message event listeners
       */
      document.addEventListener(
        "DOMContentLoaded",
        async function () {
          await TKHQ.initEmbeddedKey();
          const embeddedKeyJwk = await TKHQ.getEmbeddedKey();
          const targetPubBuf = await TKHQ.p256JWKPrivateToPublic(
            embeddedKeyJwk
          );
          const targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
          document.getElementById("embedded-key").value = targetPubHex;

          window.addEventListener("message", messageEventListener, {
            capture: false,
            signal: messageListenerController.signal,
          });

          addDOMEventListeners();

          if (!messageListenerController.signal.aborted) {
            // If styles are saved in local storage, sanitize and apply them.
            const styleSettings = TKHQ.getSettings();
            if (styleSettings) {
              TKHQ.applySettings(styleSettings);
            }
            TKHQ.sendMessageUp("PUBLIC_KEY_READY", targetPubHex);
          }
        },
        false
      );

      window.addEventListener(
        "message",
        async function (event) {
          /**
           * @turnkey/iframe-stamper >= v2.1.0 is using a MessageChannel to communicate with the parent frame.
           * The parent frame sends a TURNKEY_INIT_MESSAGE_CHANNEL event with the MessagePort.
           * If we receive this event, we want to remove the message event listener that was added in the DOMContentLoaded event to avoid processing messages twice.
           * We persist the MessagePort so we can use it to communicate with the parent window in subsequent calls to TKHQ.sendMessageUp
           */
          if (
            event.data &&
            event.data["type"] == "TURNKEY_INIT_MESSAGE_CHANNEL" &&
            event.ports?.[0]
          ) {
            // remove the message event listener that was added in the DOMContentLoaded event
            messageListenerController.abort();

            iframeMessagePort = event.ports[0];
            iframeMessagePort.onmessage = messageEventListener;

            TKHQ.setParentFrameMessageChannelPort(iframeMessagePort);

            await TKHQ.initEmbeddedKey();
            var embeddedKeyJwk = await TKHQ.getEmbeddedKey();
            var targetPubBuf = await TKHQ.p256JWKPrivateToPublic(
              embeddedKeyJwk
            );
            var targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
            document.getElementById("embedded-key").value = targetPubHex;

            TKHQ.sendMessageUp("PUBLIC_KEY_READY", targetPubHex);

            // remove the listener for TURNKEY_INIT_MESSAGE_CHANNEL after it's been processed
            turnkeyInitController.abort();
          }
        },
        { signal: turnkeyInitController.signal }
      );

      /**
       * Hide every HTML element in <body> except any <script> elements.
       * Then append an element containing the hex-encoded raw private key.
       * @param {string} key
       */
      function displayKey(key) {
        Array.from(document.body.children).forEach((child) => {
          if (child.tagName !== "SCRIPT" && child.id !== "key-div") {
            child.style.display = "none";
          }
        });

        const style = {
          border: "none",
          color: "#555b64",
          fontSize: ".875rem",
          lineHeight: "1.25rem",
          overflowWrap: "break-word",
          textAlign: "left",
        };

        // Create a new div with the key material and append the new div to the body
        const keyDiv = document.getElementById("key-div");
        keyDiv.innerText = key;
        for (let styleKey in style) {
          keyDiv.style[styleKey] = style[styleKey];
        }
        document.body.appendChild(keyDiv);
        TKHQ.applySettings(TKHQ.getSettings());
      }

      /**
       * Parse and decrypt the export bundle.
       * The `bundle` param is a JSON string of the encapsulated public
       * key, encapsulated public key signature, and the ciphertext.
       * Example: {"encappedPublic":"04912cb4200c40f04ae4a162f4c870c78cb4498a8efda0b94f4a9cb848d611bd40e9acccab2bf73cee1e269d8350a02f4df71864921097838f05c288d944fa2f8b","encappedPublicSignature":"304502200cd19a3c5892f1eeab88fe0cdd7cca63736a7d15fc364186fb3c913e1e01568b022100dea49557c176f6ca052b27ad164f077cf64d2aa55fbdc4757a14767f8b8c6b48","ciphertext":"0e5d5503f43721135818051e4c5b77b3365b66ec4020b0051d59ea9fc773c67bd4b61ed34a97b07a3074a85546721ae4","enclaveQuorumPublic":"04cf288fe433cc4e1aa0ce1632feac4ea26bf2f5a09dcfe5a42c398e06898710330f0572882f4dbdf0f5304b8fc8703acd69adca9a4bbf7f5d00d20a5e364b2569"}
       * @param {string} bundle
       * @param {string} organizationId
       */
      async function decryptBundle(bundle, organizationId) {
        let encappedKeyBuf;
        let ciphertextBuf;
        let verified;

        // Parse the import bundle
        const bundleObj = JSON.parse(bundle);
        switch (bundleObj.version) {
          case "v1.0.0":
            // Validate fields exist
            if (!bundleObj.data) {
              throw new Error('missing "data" in bundle');
            }
            if (!bundleObj.dataSignature) {
              throw new Error('missing "dataSignature" in bundle');
            }
            if (!bundleObj.enclaveQuorumPublic) {
              throw new Error('missing "enclaveQuorumPublic" in bundle');
            }

            // Verify enclave signature
            if (!TKHQ.verifyEnclaveSignature) {
              throw new Error("method not loaded");
            }
            verified = await TKHQ.verifyEnclaveSignature(
              bundleObj.enclaveQuorumPublic,
              bundleObj.dataSignature,
              bundleObj.data
            );
            if (!verified) {
              throw new Error(`failed to verify enclave signature: ${bundle}`);
            }

            // Parse the signed data. The data is produced by JSON encoding followed by hex encoding. We reverse this here.
            const signedData = JSON.parse(
              new TextDecoder().decode(
                TKHQ.uint8arrayFromHexString(bundleObj.data)
              )
            );

            // Validate fields match
            if (!organizationId) {
              // todo: throw error if organization id is undefined once we've fully transitioned to v1.0.0 server messages and v2.0.0 iframe-stamper
              console.warn(
                'we highly recommend a version of @turnkey/iframe-stamper >= v2.0.0 to pass "organizationId" for security purposes.'
              );
            } else if (
              !signedData.organizationId ||
              signedData.organizationId !== organizationId
            ) {
              throw new Error(
                `organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`
              );
            }

            if (!signedData.encappedPublic) {
              throw new Error('missing "encappedPublic" in bundle signed data');
            }
            if (!signedData.ciphertext) {
              throw new Error('missing "ciphertext" in bundle signed data');
            }
            encappedKeyBuf = TKHQ.uint8arrayFromHexString(
              signedData.encappedPublic
            );
            ciphertextBuf = TKHQ.uint8arrayFromHexString(signedData.ciphertext);
            break;
          default:
            throw new Error(`unsupported version: ${bundleObj.version}`);
        }

        // Decrypt the ciphertext
        const embeddedKeyJwk = await TKHQ.getEmbeddedKey();
        return await HpkeDecrypt({
          ciphertextBuf,
          encappedKeyBuf,
          receiverPrivJwk: embeddedKeyJwk,
        });
      }

      /**
       * Function triggered when INJECT_KEY_EXPORT_BUNDLE event is received.
       * @param {string} bundle
       * @param {string} keyFormat
       * @param {string} organizationId
       * @param {string} requestId
       */
      async function onInjectKeyBundle(
        bundle,
        keyFormat,
        organizationId,
        requestId
      ) {
        // Decrypt the export bundle
        const keyBytes = await decryptBundle(bundle, organizationId);

        // Reset embedded key after using for decryption
        TKHQ.onResetEmbeddedKey();

        // Parse the decrypted key bytes
        var key;
        const privateKeyBytes = new Uint8Array(keyBytes);
        if (keyFormat === "SOLANA") {
          const privateKeyHex = TKHQ.uint8arrayToHexString(
            privateKeyBytes.subarray(0, 32)
          );
          const publicKeyBytes = TKHQ.getEd25519PublicKey(privateKeyHex);
          key = await TKHQ.encodeKey(
            privateKeyBytes,
            keyFormat,
            publicKeyBytes
          );
        } else {
          key = await TKHQ.encodeKey(privateKeyBytes, keyFormat);
        }

        // Display only the key
        displayKey(key);

        // Send up BUNDLE_INJECTED message
        TKHQ.sendMessageUp("BUNDLE_INJECTED", true, requestId);
      }

      /**
       * Function triggered when INJECT_WALLET_EXPORT_BUNDLE event is received.
       * @param {string} bundle
       * @param {string} organizationId
       * @param {string} requestId
       */
      async function onInjectWalletBundle(bundle, organizationId, requestId) {
        // Decrypt the export bundle
        const walletBytes = await decryptBundle(bundle, organizationId);

        // Reset embedded key after using for decryption
        TKHQ.onResetEmbeddedKey();

        // Parse the decrypted wallet bytes
        const wallet = TKHQ.encodeWallet(new Uint8Array(walletBytes));

        // Display only the wallet's mnemonic
        displayKey(wallet.mnemonic);

        // Send up BUNDLE_INJECTED message
        TKHQ.sendMessageUp("BUNDLE_INJECTED", true, requestId);
      }

      /**
       * Function triggered when APPLY_SETTINGS event is received.
       * For now, the only settings that can be applied are for "styles".
       * Persist them in local storage so they can be applied on every
       * page load.
       * @param {string} settings: JSON-stringified settings
       * @param {string} requestId
       */
      async function onApplySettings(settings, requestId) {
        // Apply settings
        const validSettings = TKHQ.applySettings(settings);

        // Persist in local storage
        TKHQ.setSettings(validSettings);

        // Send up SETTINGS_APPLIED message
        TKHQ.sendMessageUp("SETTINGS_APPLIED", true, requestId);
      }

      /**
       * Decrypt the ciphertext (ArrayBuffer) given an encapsulation key (ArrayBuffer)
       * and the receivers private key (JSON Web Key).
       */
      async function HpkeDecrypt({
        ciphertextBuf,
        encappedKeyBuf,
        receiverPrivJwk,
      }) {
        const kemContext = new hpke.DhkemP256HkdfSha256();
        var receiverPriv = await kemContext.importKey(
          "jwk",
          { ...receiverPrivJwk },
          false
        );

        var suite = new hpke.CipherSuite({
          kem: kemContext,
          kdf: new hpke.HkdfSha256(),
          aead: new hpke.Aes256Gcm(),
        });

        var recipientCtx = await suite.createRecipientContext({
          recipientKey: receiverPriv,
          enc: encappedKeyBuf,
          info: new TextEncoder().encode("turnkey_hpke"),
        });

        var receiverPubBuf = await TKHQ.p256JWKPrivateToPublic(receiverPrivJwk);
        var aad = TKHQ.additionalAssociatedData(encappedKeyBuf, receiverPubBuf);
        var res;
        try {
          res = await recipientCtx.open(ciphertextBuf, aad);
        } catch (e) {
          throw new Error(
            "unable to decrypt bundle using embedded key. the bundle may be incorrect. failed with error: " +
              e.toString()
          );
        }
        return res;
      }
    </script>
  </body>
</html>
