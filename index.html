<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title>Turnkey Recovery</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      text-align: center;
      font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
      max-width: 1024px;
      margin: auto;
    }
    label {
      display:inline-block;
      width: 8em;
    }
    input[type=text] {
      width: 40em;
      margin: 0.5em;
      font-family: 'Courier New', Courier, monospace;
      font-size: 1em;
      height: 1.8em;
      color: rgb(18, 87, 18);
      border: 1px rgb(217, 240, 221) solid;
      border-radius: 4px;
    }
    input:disabled {
      background-color: rgb(239, 243, 240);
    }
    #decrypted {
      width: 60em;
      background-color: rgb(58, 152, 81);
      color: white;
      height: 2em;
      font-weight: bold;
      text-align: center;
    }
    #clear {
      color: white;
      width: 7em;
      font-size: 1em;
      padding: 0.38em;
      border-radius: 4px;
      background-color: rgb(187, 100, 100);
      border: 1px rgb(112, 42, 42) solid;
      cursor: pointer;
    }
    #inject, #stamp {
      color: white;
      width: 7em;
      font-size: 1em;
      padding: 0.38em;
      border-radius: 4px;
      background-color: rgb(50, 44, 44);
      border: 1px rgb(33, 33, 33) solid;
      cursor: pointer;
    }
    #message-log {
      border: 1px #2a2828 solid;
      padding: 0 0.7em;
      border-radius: 4px;
      margin-top: 2em;
      max-width: 800px;
      margin: auto;
    }
    #message-log p {
      font-size: 0.9em;
      text-align: left;
      word-break: break-all;
    }
    .hidden { display: none; }
  </style>
</head>

<body>
  <h2>Init Recovery</h2>
  <p><em>This public key will be sent along with your email inside of a new <code>INIT_USER_EMAIL_RECOVERY</code> activity</em></p>
  <form>
    <label>Embedded key</label>
    <input type="text" name="embedded-key" id="embedded-key" disabled/>
    <button id="clear">Reset Key</button>
  </form>
  <br>
  <br>
  <br>
  <h2>Inject Recovery Bundle</h2>
  <p><em>The recovery bundle comes from your email. We can also simulate this locally: see instructions <a href="https://github.com/tkhq/recovery#running-a-fake-recovery" target="_blank">here</a>. A recovery bundle is composed of a public key and an encrypted payload. The payload is encrypted to this document's embedded key (stored in local storage and displayed above). The scheme relies on <a target="_blank" href="https://datatracker.ietf.org/doc/rfc9180/">HPKE (RFC 9180)</a></em>.</p>
  <form>
    <label>Bundle</label>
    <input type="text" name="recovery-bundle" id="recovery-bundle"/>
    <button id="inject">Inject Bundle</button>
  </form>
  <br>
  <br>
  <br>
  <h2>Stamp</h2>
  <p><em>Once you've injected the recovery bundle, the recovery credential is ready to sign. A new <code>RECOVER</code> activity for example. This iframe doesn't know anything about Turnkey activity however, it's a simple stamper!</em></p>
  <form>
    <label>Payload</label>
    <input type="text" name="payload" id="payload"/>
    <button id="stamp">Stamp</button>
  </form>
  <br>
  <br>
  <br>
  <h2>Message log</h2>
  <p><em>Below we display a log of the messages sent / received. The forms above send messages, and the code communicates results by sending events via the <code>postMessage</code> API.</em></p>
  <div id="message-log"></div>

  <!--
    Script defining important helpers.
    These helpers are unit-testable, so most of the logic should be written here.
  -->
  <script>
    window.TKHQ = function() {
      /** constant for LocalStorage */
      var TURNKEY_EMBEDDED_KEY = "TURNKEY_EMBEDDED_KEY"

      /**
       * Creates a new public/private key pair and persists it in localStorage
       */
      var initEmbeddedKey = async function() {
        var retrievedKey = await getEmbeddedKey();
        if (retrievedKey === null) {
          var targetKey = await generateTargetKey();
          setEmbeddedKey(targetKey)
        } else {
          // Nothing to do, key is correctly initialized!
        }
      }

      /*
      * Generate a key to encrypt to and export it as a JSON Web Key.
      */
      var generateTargetKey = async function() {
        var p256key = await crypto.subtle.generateKey({
          name: 'ECDSA',
          namedCurve: 'P-256',
        }, true, ['sign',]);

        return await crypto.subtle.exportKey("jwk", p256key.privateKey);
      }

      /**
       * Gets the current embedded private key JWK. Returns `null` if not found.
       */
      var getEmbeddedKey = function() {
        var jwtKey = window.localStorage.getItem(TURNKEY_EMBEDDED_KEY)
        if (!jwtKey) {
          return null
        } else {
          return JSON.parse(jwtKey);
        }
      }

      var setEmbeddedKey = function(targetKey) {
        return window.localStorage.setItem(TURNKEY_EMBEDDED_KEY, JSON.stringify(targetKey))
      }

      var clearEmbeddedKey = function() {
        window.localStorage.removeItem(TURNKEY_EMBEDDED_KEY)
      }

      /**
       * Takes a hex string (e.g. "e4567ab") and returns an array buffer (Uint8Array)
       * @param {string} hexString
       * @returns {Uint8Array}
       */
      var uint8arrayFromHexString = function(hexString) {
        return new Uint8Array(hexString.match(/../g).map(h=>parseInt(h,16)));
      }

      /**
        * Takes a Uint8Array and returns a hex string
        * @param {Uint8Array} buffer
        * @return {string}
        */
      var uint8arrayToHexString = function(buffer) {
        return [...buffer]
            .map(x => x.toString(16).padStart(2, '0'))
            .join('');
      }

      /**
       * Additional Associated Data (AAD) in the format dictated by the enclave_encrypt crate.
       */
      var additionalAssociatedData = function(
        senderPubBuf,
        receiverPubBuf,
      ) {
        var s = Array.from(new Uint8Array(senderPubBuf));
        var r = Array.from(new Uint8Array(receiverPubBuf));
        return new Uint8Array([...s, ...r]);
      }

      /**
       * Encodes a buffer into base64url
       * @param {Uint8Array} byteArray
       */
      function base64urlEncode(byteArray) {
        return btoa(Array.from(byteArray).map(val => {
          return String.fromCharCode(val);
        }).join('')).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
      }

      /**
       * Encodes a buffer into base64url
       * @param {string} s
       * @return {Uint8Array}
       */
      function base64urlDecode(s) {
        var binaryString = atob(s.replace(/\-/g, '+').replace(/\_/g, '/'));
        var bytes = new Uint8Array(binaryString.length);
        for (var i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
      }

      /**
       * `SubtleCrypto.sign(...)` outputs signature in IEEE P1363 format:
       * - https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#ecdsa
       *
       * Turnkey expects the signature encoding to be DER-encoded ASN.1:
       * - https://github.com/tkhq/tkcli/blob/7f0159af5a73387ff050647180d1db4d3a3aa033/src/internal/apikey/apikey.go#L149
       *
       * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L114
       *
       * Transform an ECDSA signature in IEEE 1363 encoding to DER encoding.
       *
       * @param {Uint8Array} ieee the ECDSA signature in IEEE encoding
       * @return ECDSA signature in DER encoding
       */
      function convertEcdsaIeee1363ToDer(ieee) {
        if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {
          throw new Error(
            "Invalid IEEE P1363 signature encoding. Length: " + ieee.length
          );
        }
        const r = toUnsignedBigNum(ieee.subarray(0, ieee.length / 2));
        const s = toUnsignedBigNum(ieee.subarray(ieee.length / 2, ieee.length));
        let offset = 0;
        const length = 1 + 1 + r.length + 1 + 1 + s.length;
        let der;
        if (length >= 128) {
          der = new Uint8Array(length + 3);
          der[offset++] = 48;
          der[offset++] = 128 + 1;
          der[offset++] = length;
        } else {
          der = new Uint8Array(length + 2);
          der[offset++] = 48;
          der[offset++] = length;
        }
        der[offset++] = 2;
        der[offset++] = r.length;
        der.set(r, offset);
        offset += r.length;
        der[offset++] = 2;
        der[offset++] = s.length;
        der.set(s, offset);
        return der;
      }

      /**
       * (private function, only called by `convertEcdsaIeee1363ToDer`)
       * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L311
       *
       * Transform a big integer in big endian to minimal unsigned form which has
       * no extra zero at the beginning except when the highest bit is set.
       *
       * @param {Uint8Array} bytes
       *
       */
      function toUnsignedBigNum(bytes) {
        // Remove zero prefixes.
        let start = 0;
        while (start < bytes.length && bytes[start] == 0) {
          start++;
        }
        if (start == bytes.length) {
          start = bytes.length - 1;
        }
        let extraZero = 0;

        // If the 1st bit is not zero, add 1 zero byte.
        if ((bytes[start] & 128) == 128) {
          // Add extra zero.
          extraZero = 1;
        }
        const res = new Uint8Array(bytes.length - start + extraZero);
        res.set(bytes.subarray(start), extraZero);
        return res;
      }

      /**
       * Code modified from https://github.com/github/webauthn-json/blob/e932b3585fa70b0bd5b5a4012ba7dbad7b0a0d0f/src/webauthn-json/base64url.ts#L23
       * @param {string} input
       */
      var stringToBase64urlString = function(input) {
          const base64String = btoa(input);
          return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
      }

      /**
       * Function to send a message. If this page is embedded as an iframe we'll use window.top.postMessage. Otherwise we'll display it in the DOM.
       * @param type message type. Can be "PUBLIC_KEY_CREATED", "BUNDLE_INJECTED" or "STAMP"
       * @param value message value
       */
      var sendMessageUp = function(type, value) {
        if (window.top !== null) {
          window.top.postMessage({
              "type": type,
              "value": value,
          }, '*')
        }
        logMessage(`⬆️ Sent message ${type}: ${value}`)
      }

      /**
       * Function to log a message and persist it in the page's DOM.
       */
      var logMessage = function(content) {
        var messageLog = document.getElementById("message-log");
        var message = document.createElement("p")
        message.innerText = content;
        messageLog.appendChild(message);
      }

      /**
      * Convert a JSON Web Key private key to a public key and export the public
      * key in raw format.
      * @return {Uint8array}
      */
      var p256JWKPrivateToPublic = async function(jwkPrivate) {
        // make a copy so we don't modify the underlying object
        const jwkPrivateCopy = { ... jwkPrivate }
        // change jwk so it will be imported as a public key
        delete jwkPrivateCopy.d;
        jwkPrivateCopy.key_ops = ["verify"];

        var publicKey =  await window.crypto.subtle
          .importKey("jwk", jwkPrivateCopy, { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
        var buffer = await crypto.subtle.exportKey("raw", publicKey);
        return new Uint8Array(buffer)
      }

      /**
       * Returns a CryptoKey from a P256 private key bytes
       * This is a bit awkward because webcrypto can't import raw private key bytes.
       * We use some custom crypto code to derive the public key from the private key bytes.
       * Note that this is NOT security sensitive because browsers validate x/y coordinate
       * when performing `crypto.subtle.importKey` operations.
       * @param {Uint8Array} privateKeyBytes
       */
      var importRecoveryCredential = async function(privateKeyBytes) {
        var privateKeyHexString = uint8arrayToHexString(privateKeyBytes);
        var privateKey = BigInt('0x' + privateKeyHexString);
        var publicKeyPoint = P256Generator.multiply(privateKey);

        return await window.crypto.subtle.importKey(
          "jwk",
          {
            kty: "EC",
            crv: "P-256",
            d: bigIntToBase64Url(privateKey),
            x: bigIntToBase64Url(publicKeyPoint.x.num),
            y: bigIntToBase64Url(publicKeyPoint.y.num),
            ext: true,
          },
          {
            name: "ECDSA",
            namedCurve: "P-256",
          },
          true,
          ["sign"]
        )
      }

      /**
       * Converts a `BigInt` into a base64url encoded string
       * @param {BigInt} num
       * @return {string}
       */
      var bigIntToBase64Url = function(num) {
          var hexString = num.toString(16);
          // Add an extra 0 to the start of the string to get a valid hex string (even length)
          // (e.g. 0x0123 instead of 0x123)
          var hexString = hexString.padStart(Math.ceil(hexString.length/2)*2, 0)
          var buffer = uint8arrayFromHexString(hexString);
          return base64urlEncode(buffer)
      }

      /**
       * Converts a `BigInt` into a hex encoded string
       * @param {BigInt} num
       * @param {number} length expected length of the resulting hex string
       * @return {string}
       */
       var bigIntToHex = function(num, length) {
          var hexString = num.toString(16);
          if (hexString.length > length) {
            throw new Error("number cannot fit in a hex string of " + length + " characters");
          }
          // Add an extra 0 to the start of the string to get to `length`
          return hexString.padStart(length, 0)
      }

      /**
       * Accepts a public key array buffer, and returns a buffer with the compressed version of the public key
       * @param {Uint8Array} rawPublicKey
       */
       var compressRawPublicKey = function(rawPublicKey) {
        const len = rawPublicKey.byteLength

        // Drop the y coordinate
        // Uncompressed key is in the form 0x04||x||y
        // `len >>> 1` is a more concise way to write `floor(len/2)`
        var compressedBytes = rawPublicKey.slice(0, 1 + len >>> 1)

        // Encode the parity of `y` in first bit
        // `BYTE & 0x01` tests for parity and returns 0x00 when even, or 0x01 when odd
        // Then `0x02 | <parity test result>` yields either 0x02 (even case) or 0x03 (odd).
        compressedBytes[0] = 0x02 | (rawPublicKey[len-1] & 0x01)
        return compressedBytes
      }

      /**
       * Accepts a public key array buffer, and returns a buffer with the uncomrpessed version of the public key
       * @param {Uint8Array} rawPublicKey
       * @return {Uint8Array} the uncompressed bytes
       */
       var uncompressRawPublicKey = function(rawPublicKey) {
        const len = rawPublicKey.byteLength

        // point[0] must be 2 (false) or 3 (true).
        // this maps to the initial "02" or "03" prefix
        const lsb = rawPublicKey[0] === 3;
        const x = BigInt("0x" + uint8arrayToHexString(rawPublicKey.subarray(1)));

        // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).
        const p = BigInt("115792089210356248762697446949407573530086143415290314195533631308867097853951");
        const b = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
        const a = p - BigInt(3);

        // Now compute y based on x
        const rhs = ((x * x + a) * x + b) % p;
        let y = modSqrt(rhs, p);
        if (lsb !== testBit(y, 0)) {
          y = (p - y) % p;
        }

        if (x < BigInt(0) || x >= p) {
          throw new Error("x is out of range");
        }

        if (y < BigInt(0) || y >= p) {
          throw new Error("y is out of range");
        }

        var uncompressedHexString = "04" + bigIntToHex(x, 64) + bigIntToHex(y, 64);
        return uint8arrayFromHexString(uncompressedHexString)
      }

      /**
       * Private helper to compute square root modulo p
       */
      function modSqrt(x, p) {
        if (p <= BigInt(0)) {
          throw new Error("p must be positive");
        }
        const base = x % p;
        // The currently supported NIST curves P-256, P-384, and P-521 all satisfy
        // p % 4 == 3.  However, although currently a no-op, the following check
        // should be left in place in case other curves are supported in the future.
        if (testBit(p, 0) && /* istanbul ignore next */ testBit(p, 1)) {
          // Case p % 4 == 3 (applies to NIST curves P-256, P-384, and P-521)
          // q = (p + 1) / 4
          const q = (p + BigInt(1)) >> BigInt(2);
          const squareRoot = modPow(base, q, p);
          if ((squareRoot * squareRoot) % p !== base) {
            throw new Error("could not find a modular square root");
          }
          return squareRoot;
        }
        // Skipping other elliptic curve types that require Cipolla's algorithm.
        throw new Error("unsupported modulus value");
      }

      /**
       * Private helper function used by `modSqrt`
       */
      function modPow(b, exp, p) {
        if (exp === BigInt(0)) {
          return BigInt(1);
        }
        let result = b;
        const exponentBitString = exp.toString(2);
        for (let i = 1; i < exponentBitString.length; ++i) {
          result = (result * result) % p;
          if (exponentBitString[i] === "1") {
            result = (result * b) % p;
          }
        }
        return result;
      }

      /**
       * Another private helper function used as part of `modSqrt`
       */
      function testBit(n, i) {
        const m = BigInt(1) << BigInt(i);
        return (n & m) !== BigInt(0);
      }

      /**********************************************************************************************
       * Start of private crypto implementation for P256 public key derivation from a private key.
       * ----
       * IMPORTANT NOTE: below we implement basic field arithmetic for P256
       * This is only used to compute public point from a secret key inside of
       * `importRecoveryCredential` above. If something goes wrong with the code below
       * the web crypto API will simply refuse to import the key.
       * None of the functions below are returned from the closure to minimize the risk of misuse.
       *********************************************************************************************/

      /**
       * P256FieldElement represents a finite field element
       * The field is set to be the P256 prime:
       * 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
       */
      var P256FieldElement = function(num) {
        this.num = BigInt(num);
        this.prime = BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff');
      };
      P256FieldElement.prototype.eq = function(other) {
        return this.num === other.num;
      }
      P256FieldElement.prototype.add = function(other) {
        num = this.num + other.num;
        return new P256FieldElement(num % this.prime);
      }
      P256FieldElement.prototype.sub = function(other) {
        res = (this.num - other.num) % this.prime;
        if (res < BigInt(0)) { res += this.prime }
        return new P256FieldElement(res);
      }
      P256FieldElement.prototype.mul = function(other) {
        if (typeof(other) === "bigint") {
          coefficient = other;
        } else if (typeof(other) === "number") {
          coefficient = BigInt(other)
        } else if (other instanceof P256FieldElement) {
          coefficient = other.num;
        } else {
          throw new Error("Cannot multiply element. Expected a BigInt, a Number or a P256FieldElement. Got: " + other);
        }
        num = (this.num * coefficient) % this.prime
        return new P256FieldElement(num);
      }
      P256FieldElement.prototype.div = function(other) {
        // This uses fermat's little theorem (https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)
        // => if p is prime, then for any integer a: a**(p-1) % p = 1
        // => we can compute inverses for any a: 1/a = a**(p-2) % p
        return new P256FieldElement(other.num).pow(this.prime - BigInt(2)).mul(this.num)
      }
      P256FieldElement.prototype.pow = function(exponent) {
        var exponent = BigInt(exponent);
        var base = this.num % this.prime;
        // Pretty standard double-and-add loop
        var result = 1n;
        while (exponent > BigInt(0)) {
          if (exponent % BigInt(2)) {
            result = (result * base) % this.prime;
          }
          exponent = exponent / BigInt(2);
          base = (base * base) % this.prime;
        }
        return new P256FieldElement(result);
      };

      /**
       * P256Point is a point (x, y) on the following elliptic curve:
       *     y**2 = x**3 + ax + b
       *     (where x and y are both finite field elements on the P256 field)
       * https://www.secg.org/sec2-v2.pdf, https://neuromancer.sk/std/nist/P-256
       *
       * We only define + and * since that's what's needed for public key derivation.
       */
      P256Point = function(x, y) {
        if (!x instanceof P256FieldElement) {
          throw new Error("expected a P256FieldElement for x. Got: " + x);
        }
        this.x = x;

        if (!y instanceof P256FieldElement) {
          throw new Error("expected a P256FieldElement for y. Got: " + y);
        }
        this.y = y;
        this.a = new P256FieldElement(BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'));
        this.b = new P256FieldElement(BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'));

        if (this.x === null && this.y === null) {
          // Point at infinity
          return
        }

        var left = this.y.pow(2).num;
        var right = this.x.pow(3).add(this.x.mul(this.a)).add(this.b).num;

        if (left != right){
          // y**2 = x**3 + 7 is the elliptic curve equation
          throw new Error('Not on the P256 curve! y**2 (' + left + ') != x3 + ax + b (' + right + ')');
        }
      }

      /**
       * Addition is a complex operation because of the number of cases involved.
       * The point at infinity is represented by (x=null, y=null), and represents the logical "0".
       * So, to compute `A.add(B)`:
       * - Case 1a: if A is 0, return B (0+B=B)
       * - Case 1b: if B is 0, return A (A+0=A)
       * - Case 2: if A and B have the same x but different y coordinates, they're
       *           opposite points: B is "-A". So, A+B=A+(-A)=0 (return point at infinity)
       * - Case 3: if A and B are the same and at y=0, the A->B line is tangent to the y axis
       *           -> return point at infinity
       * - Case 4: if A and B are the same (with y≠0), the formula for the result R (x3, y3):
       *           s = (3*x1**2 + a) / 2*y1
       *           x3 = s**2 - 2*x1
       *           y3 = s*(x1 - x3) - y1
       *           -> return (x3, y3)
       * - Case 5: general case (different x coordinates). To get R (x3, y3) from A and B:
       *           s = (y2 -y1) / (x2 - x1)
       *           x3 = s**2 - x1 - x2
       *           y3 = s*(x1 - x3) - y1
       *           -> return (x3, y3)
       *
       * See https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_addition for helpful visuals
       */
      P256Point.prototype.add = function(other) {
        if (this.x === null) { return other; }  /* 1a */
        if (other.x === null) { return this; }  /* 1b */

        /* 2 */
        if (this.x.eq(other.x) === true && this.y.eq(this.y) === false) {
            return new P256Point(null, null);
        }

        /* 3 */
        if (this.x.eq(other.x) && this.y.eq(other.y) && this.y.eq(new P256FieldElement(0))) {
            return new P256Point(null, null);
        }

        /* 4 */
        if (this.x.eq(other.x) && this.y.eq(other.y)) {
            s = (this.x.pow(2).mul(3).add(this.a)).div(this.y.mul(2))
            x = s.pow(2).sub(this.x.mul(2))
            y = s.mul(this.x.sub(x)).sub(this.y)
            return new P256Point(x, y)
        }

        /* 5 */
        if (this.x.eq(other.x) === false) {
            s = other.y.sub(this.y).div(other.x.sub(this.x));
            x = s.pow(2).sub(this.x).sub(other.x);
            y = s.mul(this.x.sub(x)).sub(this.y);
            return new P256Point(x, y);
        }

        throw new Error('cannot handle addition of (' + this.x +  ', ' + this.y + ') with (' + other.x +  ', ' + other.y + ')');
      }
      /**
       * Multiplication uses addition. Nothing crazy here.
       * We start with "0" (point at infinity). Then we add increasing powers of 2.
       * So, to multiply A by e.g. 25 (25 is 11001 in binary), we add 1*A, then compute
       * 2*A, 4*A, 8*A by successive additions. Then add 8*A, then compute 16*A, then
       * add 16*A.
       */
      P256Point.prototype.multiply = function(coefficient) {
          var coef = BigInt(coefficient);
          var current = this;
          var result = new P256Point(null, null);
          while(coef) {
              if (coef & BigInt(1)) {
                  result = result.add(current);
              }
              current = current.add(current);
              coef >>= BigInt(1);
          }
          return result;
      }

      /**
       * This is the P256 base point (aka generator)
       * See https://www.secg.org/sec2-v2.pdf and https://neuromancer.sk/std/nist/P-256
       */
      var P256Generator = new P256Point(
        new P256FieldElement(BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296')),
        new P256FieldElement(BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'))
      )

      /**********************************************************************************************
       * End of private crypto implementation for P256 public key derivation from a private key.
       *********************************************************************************************/

      return {
        initEmbeddedKey,
        generateTargetKey,
        getEmbeddedKey,
        setEmbeddedKey,
        clearEmbeddedKey,
        importRecoveryCredential,
        compressRawPublicKey,
        uncompressRawPublicKey,
        p256JWKPrivateToPublic,
        convertEcdsaIeee1363ToDer,
        sendMessageUp,
        logMessage,
        base64urlEncode,
        base64urlDecode,
        bigIntToHex,
        stringToBase64urlString,
        uint8arrayToHexString,
        uint8arrayFromHexString,
        additionalAssociatedData
      }
    }();
  </script>

  <!--
    Script importing HPKE lib until we can replace it
    Because this is loaded as a module JSDOM can't load it properly
    Code in here isn't tested, so let's keep this to a minimum!
  -->
  <script type="module">
    // TODO: this should be bundled at build time or replaced with code written by Turnkey entirely.
    import * as hpke from "https://esm.sh/@hpke/core";

    // In memory spot for the recovery credential to live. We do NOT persist it to localStorage.
    var RECOVERY_CREDENTIAL_BYTES = null;

    document.addEventListener("DOMContentLoaded", async function () {
      await TKHQ.initEmbeddedKey();
      var embeddedKeyJwk = await TKHQ.getEmbeddedKey();
      var targetPubBuf = await TKHQ.p256JWKPrivateToPublic(embeddedKeyJwk);
      var targetPubHex = TKHQ.uint8arrayToHexString(targetPubBuf);
      document.getElementById("embedded-key").value = targetPubHex;
      TKHQ.sendMessageUp("PUBLIC_KEY_READY", targetPubHex)

      // TODO: find a way to filter messages and ensure they're coming from the parent window?
      // We do not want to arbitrarily receive messages from all origins.
      window.addEventListener("message", function(event) {
        if (event.data && event.data["type"] == "INJECT_RECOVERY_BUNDLE") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}: ${event.data["value"]}`);
          onInjectBundle(event.data["value"])
        }
        if (event.data && event.data["type"] == "STAMP_REQUEST") {
          TKHQ.logMessage(`⬇️ Received message ${event.data["type"]}: ${event.data["value"]}`);
          onStampRequest(event.data["value"]);
        }
      }, false);

      /**
       * Event handlers to power the recovery flow in standalone mode
       * Instead of receiving events from the parent page, forms trigger them.
       * This is useful for debugging as well.
       */
      document.getElementById("inject").addEventListener("click", async function(e) {
        e.preventDefault();
        window.postMessage({
          "type": "INJECT_RECOVERY_BUNDLE",
          "value": document.getElementById("recovery-bundle").value,
        })
      }, false);
      document.getElementById("stamp").addEventListener("click", async function(e) {
        e.preventDefault();
        window.postMessage({
          "type": "STAMP_REQUEST",
          "value": document.getElementById("payload").value,
        })
      }, false);

      /**
       * DEBUG functionality only to clear the page's localStorage
       */
      document.getElementById("clear").addEventListener("click", TKHQ.clearEmbeddedKey);
    }, false);

    /**
     * Function triggered when INJECT_RECOVERY_BUNDLE event is received.
     * The `bundle` param is the concatenation of a public key and an encrypted payload, and then base64 encoded
     * Example: A6ZPGAlxBRZhjKWky4RpXnHVceGzJjTuBrzKvMGnIgZ3r6JD4D1iiSg_m-y_u0BgJKI397Xjn0wgu17w9wuRooEp-F38m4ql57FgQ7sX9nQA
     * @param {string} bundle
     */
    var onInjectBundle = async function(bundle) {
        var bundleBytes = TKHQ.base64urlDecode(bundle);
        if (bundleBytes.byteLength <= 33) {
          throw new Error("bundle size " + bundleBytes.byteLength + " is too low. Expecting a compressed public key (33 bytes) and an encrypted credential")
        }

        var compressedEncappedKeyBuf = bundleBytes.subarray(0,33);
        var ciphertextBuf = bundleBytes.subarray(33);
        var embeddedKeyJwk = await TKHQ.getEmbeddedKey();

        // Decompress the compressed key
        var encappedKeyBuf = TKHQ.uncompressRawPublicKey(compressedEncappedKeyBuf);

        var recoveryCredentialBytes = await HpkeDecrypt(
          {
            ciphertextBuf,
            encappedKeyBuf,
            receiverPrivJwk: embeddedKeyJwk,
          });

        RECOVERY_CREDENTIAL_BYTES = new Uint8Array(recoveryCredentialBytes);
        TKHQ.sendMessageUp("BUNDLE_INJECTED", true)
    }
    /**
     * Function triggered when STAMP_REQUEST event is received.
     * @param {string} payload to sign
     */
    var onStampRequest = async function(payload) {
      if (RECOVERY_CREDENTIAL_BYTES === null) {
        throw new Error("cannot sign payload without credential. Credential bytes are null");
      }
      var recoveryKey = await TKHQ.importRecoveryCredential(RECOVERY_CREDENTIAL_BYTES)
      var signatureIeee1363 = await window.crypto.subtle.sign(
        {
            name: "ECDSA",
            hash: {name: "SHA-256"},
        },
        recoveryKey,
        new TextEncoder().encode(payload)
      );

      var derSignature = TKHQ.convertEcdsaIeee1363ToDer(new Uint8Array(signatureIeee1363));
      var derSignatureHexString = TKHQ.uint8arrayToHexString(derSignature);

      // This is a bit of a pain, but we need to go through this:
      // - Key needs to be exported to JWK first
      // - Then imported without the private "d" component, and exported to get the public key
      //   ^^ (that's what `p256JWKPrivateToPublic` does)
      // - Finally, compress the public key.
      var jwkKey = await crypto.subtle.exportKey("jwk", recoveryKey);
      var publicKey = await TKHQ.p256JWKPrivateToPublic(jwkKey);
      var compressedPublicKey = TKHQ.compressRawPublicKey(publicKey);

      var stamp = {
        publicKey: TKHQ.uint8arrayToHexString(compressedPublicKey),
        scheme: "SIGNATURE_SCHEME_TK_API_P256",
        signature: derSignatureHexString,
      };

      var stampHeaderValue = TKHQ.stringToBase64urlString(JSON.stringify(stamp));
      TKHQ.sendMessageUp("STAMP", stampHeaderValue)
    }

    /**
     * Decrypt the ciphertext (ArrayBuffer) given an encapsulation key (ArrayBuffer)
     * and the receivers private key (JSON Web Key).
     */
    var HpkeDecrypt = async function({
      ciphertextBuf,
      encappedKeyBuf,
      receiverPrivJwk,
    }) {
      var kemContext = new hpke.DhkemP256HkdfSha256();
      var receiverPriv = await kemContext.importKey("jwk", {...receiverPrivJwk}, false);


      var suite = new hpke.CipherSuite({
        kem: kemContext,
        kdf: new hpke.HkdfSha256(),
        aead: new hpke.Aes256Gcm(),
      });

      var recipientCtx = await suite.createRecipientContext({
        recipientKey: receiverPriv,
        enc: encappedKeyBuf,
        info: new TextEncoder().encode("turnkey_hpke"),
      });

      var receiverPubBuf = await TKHQ.p256JWKPrivateToPublic(receiverPrivJwk);
      var aad = TKHQ.additionalAssociatedData(encappedKeyBuf, receiverPubBuf);
      var res;
      try {
        res = await recipientCtx.open(ciphertextBuf, aad);
      } catch (e) {
        throw new Error("decryption failed: " + e);
      }
      return res
    }
  </script>
</body>
</html>
